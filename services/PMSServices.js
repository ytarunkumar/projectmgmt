/*
 * @Author: Prince John 
 * @Date: 2022-12-06 15:51:22 
 * @Last Modified by: Karthik P
 * @Last Modified time: 2023-09-01 18:14:16
 */
let appLogger = require('../logger/Logger').applicationLogger;
let meteringLogger = require('../logger/Logger').meteringLogger;
let dbOperations = require('../../common/connection/mysql/DbOperations');
let mysqlQueries = require('../queries/PMSQueries');
let apiSignatures = require('../config/APISignature.json');
let responseHandler = require('../../common/main/ResponseHandler')
let moment = require('moment');
let supportHandler = require('../services/PMSSupport')
let validationHandler = require('../../common/main/ValidationHandler');
const PMSSupport = require('../services/PMSSupport');
const mongoOperations = require('../../common/connection/mongodb/MongoOperations');
const ImageHandler = require('../../common/connection/redis/ImageHandler');
let TSMsupportHandler = require('../../timesheetManagement/services/TSMSupport')
let configData = require('../config/Config.json');
const { sendMails, sendMail } = require("../../common/main/Mailer");
const mailConfig = require("../../common/config/MailConfig.json");
const fs = require('fs')
const path = require('path')
var request = require('request');
const axios = require('axios');
const nodemailer = require('nodemailer');
const ejs = require('ejs');
const BudgetSupport = require('./BudgetSupport');
const dashboardConfig = require('../config/DashboardConfig.json');
const dashboardService = require('../..//userManagement/services/dashboard/DashboardService');
const { getBalanceAmtOfProject } = require('./BudgetService');
const clientService = require('../..//userManagement/services/client/CLMService');
const { timeStamp, log } = require('console');
const { getSupportEmailAPIToken } = require('../../common/main/GraphHandler');
const OneDrive = require('../../common/main/OneDrive');
const ObjectID = require('mongodb').ObjectId;
const config = require('../config/Config.json');
let startDateTime;
let endDateTime;
let diffInMS;
let moduleName = 'PM'
let className = "PMSServices";
module.exports = {
    createProject: async function (req) {
        appLogger.logMessage("debug", "createProject function called with the payload: " + JSON.stringify(req.body), className, "createProject", req.body.loggedUser, req.body.tenant);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully created new project",
            data: {}
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.createProject);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to create new project due to missing parameters: " + JSON.stringify(missingParams), className, "createNewProject", body.loggedUser, body.tenant);
                    out.status = "Failed";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    let formatedProjectName = await validationHandler.validateString(body.name, body.loggedUser, body.tenant, appLogger, meteringLogger, moduleName);
                    body.name = formatedProjectName;
                    let isExists = await supportHandler.isProjectNameExists(body.name, body.projectTypeCode, body.tenantId, body.loggedUser, body.tenant);
                    if (isExists != null) {
                        if (isExists == 0) {
                            let query = mysqlQueries.createProject;
                            let param = [
                                body.tenantId,
                                body.name,
                                body.description,
                                body.projectTypeCode,
                                body.locationName,
                                body.locationCoordinates,
                                body.estimatedStartDate,
                                body.estimatedCompletionDate,
                                body.actualStartDate,
                                body.actualCompletionDate,
                                body.projectStatusTypeCode,
                                body.approvalRequired ||'N'
                            ];
                            let result = await dbOperations.executeQuery(query, param, body.loggedUser, "createProject", true, [12, 13], body.tenant, appLogger, meteringLogger, moduleName);
                            if (result) {
                                if (result.affectedRows > 0) {
                                    let projectId = result.insertId;
                                    param = await supportHandler.generateDefaultMilestone(projectId,body.tenantId,body.loggedUserId,body.loggedUser, body.tenant,body.actualStartDate, body.actualCompletionDate)
                                    result = await dbOperations.executeQuery(mysqlQueries.createDefaultMilestones, [param], body.loggedUser, "createDefaultMilestones", false, null, body.tenant, appLogger, meteringLogger, moduleName);
                                    out = await supportHandler.assignProjectOwner(req, projectId);
                                    out.data = {
                                        "projectId": projectId
                                    }
                                    body['projectId']=JSON.stringify([projectId])
                                    if(body.clientId!=null && body.clientId!=undefined && body.clientId!='' && body.clientId!='null' && body.clientId!='undefined'){
                                        body['projectCreation']=true
                                        let mappingResult=await clientService.mapProjectToClient(body,body.loggedUser,body.tenant)
                                        if(mappingResult.type!='Success'){
                                            appLogger.logMessage("debug", "Failed to  map project to client " + JSON.stringify(mappingResult), className, "createProject", body.loggedUser, body.tenant);
                                            out.message = "Failed to map proejct to client";
                                            out.status="Warning"
                                        }else{
                                            appLogger.logMessage("info", "Successfully maped project to client" , className, "createProject", body.loggedUser, body.tenant);
                                        }
                                    }
                                    await BudgetSupport.addBudget(projectId, body.classType, body.tenantId, body.currencyCode, body.type, body.maxAmount, body.minAmount, body.loggedUserId, body.loggedUser, body.tenant);
                                    if (body.fromTemplate != 'true' || body.fromTemplate == null || body.fromTemplate == undefined) {
                                        let payload = {
                                            'tenantId': body.tenantId, 'loggedUserId': body.loggedUserId, 'projectId': projectId,
                                            'groupName': 'General', 'groupDescription': 'General', 'groupStatus': 'NS'
                                        }
                                        let groupResult = await this.createGroup(payload, body.loggedUser, body.tenant)
                                        if (groupResult.type == 'Success') {
                                            appLogger.logMessage("info", "Group created successfully.", className, "createProject", body.loggedUser, body.tenant);
                                        } else {
                                            appLogger.logMessage("info", "Failed to create group.", className, "createProject", body.loggedUser, body.tenant);
                                            out.status = "Warning";
                                            out.message = "Failed to create group.";
                                            out.statusTypeCode = 400
                                        }
                                    }
                                } else {
                                    appLogger.logMessage("debug", "Failed to insert into project table. result received after executing the query: " + JSON.stringify(result), className, "createProject", body.loggedUser, body.tenant);
                                    out.status = "Failed";
                                    out.message = "Failed to create new project due to internal error";
                                }
                            }
                        } else {
                            out.status = "Warning";
                            out.message = "Project name already exists";
                        }

                    } else {
                        out.status = "Failed";
                        out.message = "Failed to create project";
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to create new project due to invalid request body", className, "createProject", "USER", req.body.tenant);
                out.status = "Failed";
                out.message = "Failed to create new project due to invalid request body";
            }
        } catch (error) {
            appLogger.logMessage("error", "Failed to create new project due to: " + JSON.stringify(error.message), className, "createNewProject", req.body.loggedUser, req.body.tenant);
            out.status = "Failed";
            out.message = "Internal Server Error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "createProject", startDateTime, endDateTime, diffInMS);
        return out;
    },
    //VIEW PROJECTS
    viewProjectsByManager: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "viewProjectsByManager function called with the payload: " + JSON.stringify(req.body), className, "viewProjectsByManager", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        let i = 0
        let closedProjects = [];
        let formattedResult = [];
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.viewProjects);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to fetch  projects due to missing parameters : " + JSON.stringify(missingParams), className, "viewProjects", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters : " + JSON.stringify(missingParams), 404, null, false, "viewProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    let query, param;
                    if (body.projectId != undefined && body.projectId != null) {
                        query = mysqlQueries.getProjectDetailData;
                        param = [
                            body.loggedUserId,
                            body.tenantId,
                            body.loggedUserId,
                            body.projectId
                        ];

                    } else if (body.isArchive == 'true') {
                        query = mysqlQueries.viewArchiveProjects
                        param = [
                            body.loggedUserId,
                            body.tenantId,
                            body.loggedUserId
                        ];
                    } else {
                        query = mysqlQueries.viewProjectsByManager;
                        param = [
                            body.loggedUserId,
                            body.tenantId,
                            body.loggedUserId


                        ];
                    }

                    let result = await dbOperations.executeQuery(query, param, loggedUser, "viewProjectsByManager", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "Error") {
                        if (result.length > 0) {
                            let lookup = await dbOperations.executeQuery(mysqlQueries.getLookupStatus, ['PROJECT_STATUS', body.tenantId], loggedUser, "getLookupStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                            for (let row of result) {
                                let timeSpend = row.TOTAL_HOURS
                                let result
                                if (timeSpend > 40) {
                                    modeValue = timeSpend % configData.maxHoursPerDay
                                    integerValue = Math.floor(timeSpend / configData.maxHoursPerDay)
                                    timeSpend = timeSpend / configData.maxHoursPerDay
                                    if (timeSpend > 30) {
                                        integerValue = Math.floor(timeSpend / 30)
                                        modeValue = timeSpend % 30
                                        timeSpend = timeSpend / 30
                                        if (timeSpend > 12) {
                                            integerValue = Math.floor(timeSpend / 12)
                                            modeValue = timeSpend % 12
                                            row.TOTAL_HOURS = integerValue + " y " + Math.ceil(modeValue) + " m "

                                        } else {
                                            //timeSpend=Math.ceil(data.HOURS?data.HOURS/8:0),

                                            row.TOTAL_HOURS = integerValue + " m " + Math.ceil(modeValue) + " d "

                                        }
                                    } else {

                                        row.TOTAL_HOURS = integerValue + " d " + Math.ceil(modeValue) + " hr "

                                    }

                                } else {
                                    row.TOTAL_HOURS = timeSpend + " hr"
                                }



                                if (row.PROJECT_OWNERS != null && row.PROJECT_OWNERS != undefined) {
                                    let projectOwners = (row.PROJECT_OWNERS).split(',')
                                    let projectOwnerDetails = await dbOperations.executeQuery(mysqlQueries.getProjectOwnerDetails, [projectOwners], loggedUser, "getProjectOwnerDetails", false, null, tenant, appLogger, meteringLogger, moduleName)
                                    let ownerDetails = [];
                                    if (projectOwnerDetails != null && projectOwnerDetails != undefined && projectOwnerDetails.length > 0) {
                                        for (let owner of projectOwnerDetails) {
                                            let key = String(tenant).toUpperCase() + "_" + owner.EMPLOYEE_NUMBER;
                                            image = await ImageHandler.fetchPhoto(req.body.tenantType, key, owner.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                            ownerDetails.push({
                                                'Name': owner.FULL_NAME,
                                                'Image': image
                                            })
                                        }
                                        row['OWNERS'] = ownerDetails;
                                    }
                                }
                                if ((moment(row.CREATION_DATE).format("YYYY-MM-DD") == moment().format('YYYY-MM-DD')) && row.PROJECT_STATUS_TYPE_CODE != 'COM' &&
                                    row.PROJECT_STATUS_TYPE_CODE != 'HOLD') {
                                    row["IS_NEW"] = true;
                                } else {
                                    row["IS_NEW"] = false;
                                }
                                let lookupAction = [{
                                    "LOOKUP_CODE": row.PROJECT_STATUS_TYPE_CODE,
                                    "DISPLAY_VALUE": row.DISPLAY_VALUE
                                }]
                                if (lookup != undefined && lookup != null && lookup.length > 0) {
                                    let index = lookup.findIndex(x => x.LOOKUP_CODE === "CLOSED")
                                    lookup[index].DISPLAY_VALUE = "Close";
                                    index = lookup.findIndex(x => x.LOOKUP_CODE === "COM")
                                    lookup[index].DISPLAY_VALUE = "Complete";
                                    if (row.PROJECT_STATUS_TYPE_CODE == "NS" && row.CREATED_BY == body.loggedUserId) {
                                        lookupAction = lookupAction.concat(lookup.filter(x => ['CLOSED'].includes(x.LOOKUP_CODE)))
                                    } else if (row.PROJECT_STATUS_TYPE_CODE == "IP" && row.CREATED_BY == body.loggedUserId) {
                                        lookupAction = lookupAction.concat(lookup.filter(x => ['HOLD', 'COM', 'CLOSED'].includes(x.LOOKUP_CODE)))
                                    } else if (row.PROJECT_STATUS_TYPE_CODE == "HOLD" && row.CREATED_BY == body.loggedUserId) {
                                        index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                        lookup[index].DISPLAY_VALUE = "Resume";
                                        lookupAction = lookupAction.concat(lookup.filter(x => ['IP', 'COM', 'CLOSED'].includes(x.LOOKUP_CODE)))
                                    }
                                }
                                row["LOOKUP_ACTION"] = lookupAction
                                row["PROGRESS"] = (row.TOTAL_TASKS > 0) ? ((row.COMPLETED_TASK / row.TOTAL_TASKS) * 100).toFixed(2) : 0
                                let obj = {
                                    'projectId': row.PROJECT_ID,
                                    'tenantId': body.tenantId,
                                    'loggedUserId':body.loggedUserId
                                }
                                row["budgetHealth"] = await this.getOverallProjectBudget(obj,loggedUser,tenant);
                                row["projectHealth"] = await this.getOverallProjectStatus(obj,loggedUser,tenant);
                                row["taskProgressHealth"] = await this.getOverallProjectProgress(obj,loggedUser,tenant);
                            }
                            let holdProjects = [];
                            let completedProjects = []
                            for (let res of result) {
                                if (res.PROJECT_STATUS_TYPE_CODE != 'CLOSED' && res.PROJECT_STATUS_TYPE_CODE != "HOLD" && res.PROJECT_STATUS_TYPE_CODE != 'COM') {
                                    formattedResult.push(res);
                                } else if (res.PROJECT_STATUS_TYPE_CODE == 'HOLD') {
                                    holdProjects.push(i);
                                } else if (res.PROJECT_STATUS_TYPE_CODE == 'CLOSED') {
                                    closedProjects.push(i)
                                }
                                else if (res.PROJECT_STATUS_TYPE_CODE == 'COM') {
                                    completedProjects.push(i)
                                }
                                i++
                            }


                            for (let cp of holdProjects) {
                                formattedResult.push(result[cp])
                            }
                            for (let cp of completedProjects) {
                                formattedResult.push(result[cp])
                            }

                            for (let cp of closedProjects) {
                                formattedResult.push(result[cp])
                            }

                            appLogger.logMessage("debug", "projects fetched successfully ", className, "viewProjectsByManager", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Success", "Project details fetched successfully", 200, formattedResult, false, "viewProjectsByManager", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("debug", "No projects are available . Result received after executing the query: " + JSON.stringify(result), className, "viewProjectsByManager", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Warning", "No projects are available", 404, null, false, "viewProjectsByManager", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    }
                }
            } else {
                appLogger.logMessage("debug", "Failed to fetch projects due to invalid request body", className, "viewProjectsByManager", loggedUser, tenant, moduleName);
                response = await responseHandler.sendResponse("Warning", "Failed to fetch project due to invalid request body", 404, null, false, "viewProjectsByManager", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "viewProjectsByManager", startDateTime, endDateTime, diffInMS, moduleName);

        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch project due to: " + JSON.stringify(error.message), className, "viewProjectsByManager", loggedUser, tenant, moduleName);
            response = await responseHandler.sendResponse("Failure", "Internal Server Error:" + error.message, 500, null, false, "viewProjectsByManager", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "viewProjects completed and the result is returned ", className, "viewProjectsByManager", loggedUser, tenant, moduleName);
        return response;
    },

    viewProjectsByEmployee: async function (req, loggedUser, tenant) {

        appLogger.logMessage("debug", "viewProjects function called with the payload: " + JSON.stringify(req.body), className, "viewProjectsByEmployee", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.viewProjects);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to fetch  projects due to missing parameters : " + JSON.stringify(missingParams), className, "viewProjectsByEmployee", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters : " + JSON.stringify(missingParams), 404, null, false, "viewProjectsByEmployee", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    let query = mysqlQueries.viewAllProjectsOfUser;
                    let param = [
                        body.tenantId, body.loggedUserId, body.loggedUserId
                    ];
                    let result = await dbOperations.executeQuery(query, param, loggedUser, "viewProjectsByEmployee", true, [2], tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result.length > 0) {
                            for (let row of result) {
                                if (moment(row.PROJECT_CREATION_DATE).format("YYYY-MM-DD") == moment().format("YYYY-MM-DD")) {
                                    row["IS_NEW"] = true;
                                } else {
                                    row["IS_NEW"] = false;
                                }
                            }
                            appLogger.logMessage("debug", "projects fetched successfully " + JSON.stringify(result), className, "viewProjectsByEmployee", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Success", "Project details fetched successfully", 200, result, true, "viewProjectsByEmployee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("debug", "No projects are available . Result received after executing the query: " + JSON.stringify(result), className, "viewProjectsByEmployee", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Warning", "No projects are available", 404, null, false, "viewProjectsByEmployee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    }
                }
            } else {
                appLogger.logMessage("debug", "Failed to fetch projects due to invalid request body", className, "viewProjectsByEmployee", loggedUser, tenant, moduleName);
                response = await responseHandler.sendResponse("Warning", "Failed to fetch project due to invalid request body", 404, null, false, "viewProjectsByEmployee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "viewProjectsByEmployee", startDateTime, endDateTime, diffInMS, moduleName);

        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch project due to: " + JSON.stringify(error.message), className, "viewProjectsByEmployee", loggedUser, tenant, moduleName);
            response = await responseHandler.sendResponse("Failure", "Internal Server Error:" + error.message, 500, null, false, "viewProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "viewProjectsByEmployee completetd and the result is returned ", className, "viewProjectsByEmployee", loggedUser, tenant, moduleName);
        return response;
    },

    reassignTask: async function (req) {

        appLogger.logMessage("info", "reassignTask service invoked by: " + req.loggedUser, className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully re-assigned the task",
            statusCode: 200,
            data: {}
        }
        try {
            let body = req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.reassignTask);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to reassign tasks due to missing parameters: " + JSON.stringify(missingParams), className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 400;
            } else {

                let updateTask = mysqlQueries.updateTaskAssignedTo;
                let param = [req.body.assignedTo, req.body.loggedUserId,
                req.body.loggedUserId,
                req.body.taskId];
                appLogger.logMessage("debug", "Assign parameters: " + req.body.assignedTo + " and taskId: " + req.body.taskId, className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                result = await dbOperations.executeQuery(updateTask, param, req.body.loggedUser, "reassignTask", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                if (result) {
                    if (result.affectedRows > 0) {
                        out.status = "Success";
                        out.statusCode = 200;
                        out.message = "Reassigned successfully";
                        if (body.assignedTo != body.loggedUserId) {
                            if (body.projectName != null && body.projectName != undefined
                                && body.taskId != null && body.taskId != undefined
                                && body.assignedToName != null && body.assignedToName != undefined
                                && body.taskName != null && body.taskName != undefined
                                && body.groupName != null && body.groupName != undefined
                                && body.createdByName != null && body.createdByName != undefined
                                && body.taskDescription != null && body.taskDescription != undefined
                                && body.estimatedStartDate != null && body.estimatedStartDate != undefined
                                && body.estimatedCompletionDate != null && body.estimatedCompletionDate != undefined
                                && body.assignedByName != null && body.assignedByName != undefined) {
                                let sub = mailConfig.task.reassign.sub
                                let mes = mailConfig.task.reassign.message
                                let message;
                                sub = sub.replace('{projectName}', body.projectName)
                                sub = sub.replace('{assignedByName}', body.assignedByName)
                                sub = sub.replace('{taskId}', body.taskId)
                                mes = mes.replace('{taskId}', body.taskId)
                                mes = mes.replace('{assignedToName}', body.assignedToName)
                                mes = mes.replace('{projectName}', body.projectName)
                                mes = mes.replace('{taskName}', body.taskName)
                                mes = mes.replace('{groupName}', body.groupName)
                                mes = mes.replace('{createdByName}', body.createdByName)
                                mes = mes.replace('{taskDescription}', body.taskDescription)
                                mes = mes.replace('{estimatedStartDate}', body.estimatedStartDate)
                                mes = mes.replace('{estimatedCompletionDate}', body.estimatedCompletionDate)
                                mes = mes.replace('{assignedByName}', body.assignedByName)
                                message = mes
                                let userData = [{ 'Id': body.assignedTo, 'Email': body.userMail }]
                                sendMails(userData, null, null, sub, message, body.loggedUser, body.tenant, null, false, body.tenantId, appLogger, meteringLogger, moduleName)
                            } else {
                                appLogger.logMessage("info", "Invalid paameters for email.", className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                            }

                        }

                        // if task added to watch list , notify watch list users on assigning 
                        //body['addedToWatchList']=true
                        if(body.addedToWatchList=='true'){
                            let nofifyResult=await supportHandler.watchListNotification(body,'task_reassign',body.loggedUser,body.tenant)
                            appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                        }

                        let notifyResult = await supportHandler.onBoardAndAssignTask(req.body.taskId, null, req.body.assignedTo, req.body.loggedUser, req.body.tenant, false, req.body.tenantId);
                        appLogger.logMessage("debug", "Response after notifying user about reassiged task: " + JSON.stringify(notifyResult), className, "reassigntask", req.body.loggedUser, req.body.tenant, moduleName);
                        appLogger.logMessage("debug", "successfully re assigned the task to userId: " + req.body.assignedTo, className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                    } else {
                        appLogger.logMessage("Success", "Reassignd to the same employee ", className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                        out.status = "Success";
                        out.statusCode = 200;
                        out.message = "Reassignd to the same employee";
                    }
                } else {
                    appLogger.logMessage("error", "Failed to reassign task due to query failed", className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                    out.status = "Warning";
                    out.statusCode = 404;
                    out.message = "Failed to reassign task";
                }




                //--------------
                // let endDateCurrentTask = mysqlQueries.reassignTaskEndDate;
                // param = [
                //     req.body.taskId
                // ];
                // let result = await dbOperations.executeQuery(endDateCurrentTask, param, req.body.loggedUser, "enddateCurrentTaskforReassign", true, [1], req.body.tenant);
                // appLogger.logMessage("debug", "Result after updating the project team for reassigning the task: " + JSON.stringify(result), className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                // if (result) {
                //     if (result.affectedRows > 0) {
                //         let assignQuery = mysqlQueries.assignUserToTask;
                //         let param = [
                //             req.body.tenantId,
                //             req.body.assignedTo,
                //             req.body.projectId,
                //             req.body.taskId,
                //             moment().format('YYYY-MM-DD'),
                //             req.body.roleTypeCode
                //         ]
                //         result = await dbOperations.executeQuery(assignQuery, param, req.body.loggedUser, "reassignTask", true, [7, 8], req.body.tenant);
                //         appLogger.logMessage("debug", "result after inserting new task to project team: " + JSON.stringify(result), className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                //         if (result) {
                //             if (result.affectedRows > 0) {
                //                 let updateTask = mysqlQueries.updateTaskAssignedTo;
                //                 let param = [req.body.assignedTo,req.body.loggedUserId, req.body.taskId];
                //                 appLogger.logMessage("debug", "Assign parameters: " + req.body.assignedTo + " and taskId: " + req.body.taskId, className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                //                 result = await dbOperations.executeQuery(updateTask, param, req.body.loggedUser, "reassignTask", false, null, req.body.tenant);
                //                 if (result) {
                //                     if (result.affectedRows > 0) {
                //                         out.status = "Success";
                //                         out.statusCode = 200;
                //                         out.message = "Reassigned successfully";
                //                         // let notifyUser = await dbOperations.executeQuery(mysqlQueries.getTasksDataToNotify, [req.body.taskId], req.body.loggedUser, "getTaskDataToNotify", false, null, req.body.tenant);
                //                         // if (notifyUser) {
                //                         //     if (notifyUser.length > 0) {
                //                         //         let notifyResult = await PMSSupport.sendWhatsappNotification(notifyUser, req.body.loggedUser, req.body.tenant);
                //                         //         appLogger.logMessage("debug", "Response after sendingNotification: " + JSON.stringify(notifyResult), className, "assignUserToTask", req.body.loggedUser, req.body.tenant, moduleName);
                //                         //     } else {
                //                         //         appLogger.logMessage("debug", "Failed to fetch taskUserDetails to notify in whatsapp due to no data found", className, "assignUserToTask", req.body.loggedUser, req.body.tenant, moduleName);
                //                         //     }
                //                         // } else {
                //                         //     appLogger.logMessage("debug", "Failed to fetch taskUserDetails to notify in whatsapp due to invalid server response", className, "assignUserToTask", req.body.loggedUser, req.body.tenant, moduleName);
                //                         // }
                //                         appLogger.logMessage("debug", "successfully re assigned the task to userId: " + req.body.assignedTo, className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                //                     } else {
                //                         appLogger.logMessage("Success", "Reassignd to the same employee " , className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                //                         out.status = "Success";
                //                         out.statusCode = 200;
                //                         out.message = "Reassignd to the same employee";
                //                     }
                //                 } else {
                //                     appLogger.logMessage("error", "Failed to reassign task due to query failed", className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                //                     out.status = "Failed";
                //                     out.statusCode = 500;
                //                     out.message = "Internal server error. Please check the logs for more details";
                //                 }
                //             } else {
                //                 appLogger.logMessage("error", "Failed to insert into project teams. The result after executing insert query: " + JSON.stringify(result), className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                //                 out.status = "Failed";
                //                 out.statusCode = 500;
                //                 out.message = "Internal server error. Please check logs for more details";
                //             }
                //         } else {
                //             appLogger.logMessage("error", "Failed to reassign task due to query failed", className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                //             out.status = "Failed";
                //             out.statusCode = 500;
                //             out.message = "Internal server error. Please check the logs for more details";
                //         }
                //     } else {
                //         appLogger.logMessage("error", "Failed to re assign task due to invalid task/user", className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                //         out.status = "Failed";
                //         out.statusCode = 500;
                //         out.message = "No tasks found by the given task Id";
                //     }
                // } else {
                //     appLogger.logMessage("debug", "Failed to update the project team as part of re assigning the task", className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
                //     out.status = "Failed";
                //     out.statusCode = 500;
                //     out.message = "Failed to re assin the task due to internal server error";
                // }
            }
        } catch (error) {
            appLogger.logMessage("error", "Error while re-assigning task due to: " + JSON.stringify(error.message), className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
            out.statusCode = 500;
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "reassignTask", startDateTime, endDateTime, diffInMS, moduleName);
        appLogger.logMessage("info", "reassignTask is completed", className, "reassignTask", req.body.loggedUser, req.body.tenant, moduleName);
        return out;
    },
    getProjectDetails: async function (req) {
        appLogger.logMessage("debug", "getProjectDetails called with the payload: " + JSON.stringify(req.body), className, "getProjectDetails", req.body.loggedUser, req.body.tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully fetched project details",
            statusCode: 200,
            data: {}
        }
        try {
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getProjectDetails);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to view tasks due to missing parameters: " + JSON.stringify(missingParams), className, "getProjectDetails", body.loggedUser, body.tenant, moduleName);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 400;
            } else {
                let query = mysqlQueries.getProjectDetails;
                let param = [req.body.tenantId, req.body.projectId];
                let result = await dbOperations.executeQuery(query, param, req.body.loggedUser, "getProjectDetails", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                if (result) {
                    if (Array.isArray(result)) {
                        if (result.length > 0) {
                            appLogger.logMessage("debug", "Project details received from server: " + JSON.stringify(result), className, "getProjectDetails", req.body.loggedUser, req.body.tenant, moduleName);
                            let lookup = await dbOperations.executeQuery(mysqlQueries.getLookupStatus, ['PROJECT_STATUS', body.tenantId], loggedUser, "getLookupStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                            let lookupAction = [{
                                "LOOKUP_CODE": result[0].PROJECT_STATUS_TYPE_CODE,
                                "DISPLAY_VALUE": result[0].DISPLAY_VALUE
                            }]
                            if (lookup != undefined && lookup != null && lookup.length > 0) {
                                let index = lookup.findIndex(x => x.LOOKUP_CODE === "CLOSED")
                                lookup[index].DISPLAY_VALUE = "Close";
                                index = lookup.findIndex(x => x.LOOKUP_CODE === "COM")
                                lookup[index].DISPLAY_VALUE = "Complete";
                                if (result[0].PROJECT_STATUS_TYPE_CODE == "NS" && result[0].CREATED_BY == body.loggedUserId) {
                                    lookupAction = lookupAction.concat(lookup.filter(x => ['CLOSED'].includes(x.LOOKUP_CODE)))
                                } else if (result[0].PROJECT_STATUS_TYPE_CODE == "IP" && result[0].CREATED_BY == body.loggedUserId) {
                                    lookupAction = lookupAction.concat(lookup.filter(x => ['HOLD', 'COM', 'CLOSED'].includes(x.LOOKUP_CODE)))
                                } else if (result[0].PROJECT_STATUS_TYPE_CODE == "HOLD" && result[0].CREATED_BY == body.loggedUserId) {
                                    index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                    lookup[index].DISPLAY_VALUE = "Resume";
                                    lookupAction = lookupAction.concat(lookup.filter(x => ['IP', 'COM', 'CLOSED'].includes(x.LOOKUP_CODE)))
                                }
                            }

                            out.data = {
                                ID: result[0].ID,
                                projectName: result[0].PROJECT_NAME,
                                description: result[0].PROJECT_DESCRIPTION,
                                locationName: result[0].LOCATION_NAME,
                                locationCoordinates: result[0].LOCATION_COORDINATES,
                                projectTypeCode: result[0].PROJECT_TYPE_CODE,
                                projectStatusTypeCode: result[0].PROJECT_STATUS_TYPE_CODE,
                                estimatedStartDate: result[0].ESTIMATED_START_DATE,
                                estimatedCompletionDate: result[0].ESTIMATED_COMPLETION_DATE,
                                actualStartDate: result[0].ACTUAL_START_DATE,
                                actualCompletionDate: "Not Completed",
                                "LOOKUP_ACTION": lookupAction
                            }
                        } else {
                            appLogger.logMessage("debug", "No project found with the id: " + req.body.projectId, className, "getProjectDetails", req.body.loggedUser, req.body.tenant, moduleName);
                            out.status = "Warning";
                            out.message = "No project found!";
                        }
                    } else {
                        appLogger.logMessage("debug", "Invalid response from the server", className, "getProjectDetails", req.body.loggedUser, req.body.tenant, moduleName);
                        out.status = "Failed";
                        out.message = "Invalid response received from server"
                        out.statusCode = 500;
                    }
                } else {
                    appLogger.logMessage("debug", "Failed to fetch project details from the server", className, "getProjectDetails", req.body.loggedUser, req.body.tenant, moduleName);
                    out.status = "Failed";
                    out.message = "Invalid response from the server";
                    out.statusCode = 500;
                }
            }
        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch project details due to: " + JSON.stringify(error.message), className, "getProjectDetails", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failed";
            out.message = "Internal server error";
            out.statusCode = 500;
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "viewProjectDetals", startDateTime, endDateTime, diffInMS, moduleName);
        appLogger.logMessage("info", "viewProjectDetails is completed", className, "getProjectDetails", req.body.loggedUser, req.body.tenant, moduleName);
        return out;
    },
    //VIEW TASKS IN A PROJECT
    viewTasks: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "viewTasks function called with the payload: " + JSON.stringify(req.body), className, "viewTasks", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.viewTasks);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to view tasks due to missing parameters: " + JSON.stringify(missingParams), className, "viewTasks", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "viewTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    let query;
                    let param;
                    if (String(body.role).toLowerCase() == "employee") {
                        param = [
                            body.tenantId,
                            body.projectId,
                            body.loggedUserId
                        ];
                        query = mysqlQueries.viewAllTasksByEmployee
                    } else if (String(body.role).toLowerCase() == "project_manager") {
                        param = [
                            body.tenantId,
                            body.projectId
                        ];
                        query = mysqlQueries.viewAllTasks;
                    } else {
                        appLogger.logMessage("debug", "Invalid role given to fetch tasks: " + body.role, className, "viewTasks", loggedUser, tenant, moduleName);
                        return await responseHandler.sendResponse("Warning", "Invalid role: " + body.role, 400, null, false, "viewTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "viewTasks", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "Error") {
                        if (result.length > 0) {
                            let date = moment().format('YYYY-MM-DD');
                            for (let data of result) {
                                let estimatedStartDate = moment(data.ESTIMATED_START_DATE).format('YYYY-MM-DD')
                                if (data.PRIORITY_TYPE_CODE == 'HIGH' && data.TASK_STATUS_TYPE_CODE == 'NS' && estimatedStartDate < date) {
                                    data['LEVEL'] = 1;
                                } else if (data.TASK_STATUS_TYPE_CODE == 'NS' && estimatedStartDate < date) {
                                    data['LEVEL'] = 2;
                                } else if (data.ACTUAL_EFFORT > data.ESTIMATED_EFFORT) {
                                    data['LEVEL'] = 3;
                                } else {
                                    data['LEVEL'] = 0;
                                }
                            }
                            appLogger.logMessage("info", "Result received after executing the query: " + JSON.stringify(result), className, "viewTasks", loggedUser, tenant, moduleName)
                            response = await responseHandler.sendResponse("Success", "Task  fetched successfully", 200, result, true, "viewTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("debug", "No tasks are available . Result received after executing the query: " + JSON.stringify(result), className, "viewTasks", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Warning", "No task are available ", 404, null, false, "viewTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                        }
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to fetch tasks due to invalid request body", className, "viewTasks", loggedUser, tenant, moduleName);
                response = await responseHandler.sendResponse("Warning", "Failed to fetch tasks  due to invalid request body ", 404, null, false, "viewTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "viewTasks", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch tasks due to: " + JSON.stringify(error.message), className, "viewTasks", req.body.loggedUser, req.body.tenant, moduleName);
            response = await responseHandler.sendResponse("Failure", "Internal server error " + error.message, 404, null, false, "viewTasks", tenant, loggedUser);
        }
        appLogger.logMessage("info", "viewTasks completed and the result is returned", className, "viewTasks", loggedUser, tenant, moduleName);
        return response;
    },

    //VIEW DETAILS OF SPECIFIC TASK
    viewTaskDetails: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "viewTaskDetails function called with the payload: " + JSON.stringify(req.body), className, "viewTaskDetails", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.viewTaskDetails);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to fetch  task details due to missing parameters: " + JSON.stringify(missingParams), className, "viewTaskDetails", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "viewTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    let query = mysqlQueries.viewTaskDetails;
                    let param = [
                        body.tenantId,
                        body.projectId,
                        body.taskId
                    ];
                    let result = await dbOperations.executeQuery(query, param, loggedUser, "viewTaskDetails", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result.length > 0) {
                            let dependencyTasks = await supportHandler.getDependencyTask(body.taskId, body.tenantId, body.loggedUser, body.tenant)
                            result[0]['PREDECESSOR_TASK'] = dependencyTasks.PREDECESSOR
                            result[0]['SUCCESSOR_TASK'] = dependencyTasks.SUCCESSOR
                            result[0]['CAN_START']=true
                            result[0]['CAN_COMPLETE']=true
                            if(dependencyTasks.pIdArray.length>0){
                                // if task has some predecessor, 
                                
                                for(let task of dependencyTasks.PREDECESSOR){
                                    if(task.CANNOT_START=='Y' ){
                                        // if the dependency rule is CS , check whether that task is complete
                                        // then only  we can start the selected task
                                        // if the dependency  rule with task is CC , check whether the task is completed
                                        // then only we can complete complete task
                                        if(task.TASK_STATUS!='COM'){
                                            result[0]['CAN_START']=false
                                        }

                                    }else if(task.CANNOT_COMPLETE=='Y'){
                                        if(task.TASK_STATUS!='COM'){
                                            result[0]['CAN_COMPLETE']=false
                                        }
                                    }
                                }
                            }else if(dependencyTasks.sIdArray.length>0){
                                result[0]['CAN_START']=true
                                result[0]['CAN_COMPLETE']=true
                                // for(let task of dependencyTasks.SUCCESSOR){
                                //     if(result[0].CANNOT_START=='Y' ){
                                //         if(task.TASK_STATUS!='COM'){
                                //             result[0]['CAN_START']=false

                                //         }

                                //     }else if(result[0].CANNOT_COMPLETE=='Y'){
                                //         if(task.TASK_STATUS!='COM'){
                                //             result[0]['CAN_COMPLETE']=false
                                //         }
                                //     }
                                // }
                            }
                            let lookupAction = [{
                                "LOOKUP_CODE": result[0].TASK_STATUS_TYPE_CODE,
                                "DISPLAY_VALUE": result[0].DISPLAY_VALUE
                            }]
                            let lookup = await dbOperations.executeQuery(mysqlQueries.getLookupStatus, ['PROJECT_STATUS', body.tenantId], loggedUser, "getLookupStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                            if (lookup != undefined && lookup != null && lookup.length > 0) {
                                let index = lookup.findIndex(x => x.LOOKUP_CODE === "CLOSED")
                                lookup[index].DISPLAY_VALUE = "Close";
                                index = lookup.findIndex(x => x.LOOKUP_CODE === "COM")
                                lookup[index].DISPLAY_VALUE = "Complete";
                                let lookupArr;
                                if (result[0].TASK_STATUS_TYPE_CODE == "OPEN" && (result[0].CREATED_BY == body.loggedUserId || result[0].ASSIGNED_TO == body.loggedUserId || result[0].ASSIGNED_BY == body.loggedUserId || result[0].PROJECT_OWNERS.includes(body.loggedUserId))) {
                                    let index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                    lookup[index].DISPLAY_VALUE = "Start";
                                     lookupArr = ['IP', 'COM', "CLOSED"]
                                    // if(!result[0]['CAN_COMPLETE']){
                                    //     lookupArr = ['IP', "CLOSED"]
                                    // }else if(!result[0]['CAN_START']){
                                    //     lookupArr = ["CLOSED"]
                                    // }
                                    lookupAction = lookupAction.concat(lookup.filter(x => lookupArr.includes(x.LOOKUP_CODE)))
                                } else if (result[0].TASK_STATUS_TYPE_CODE == "IP" && (result[0].CREATED_BY == body.loggedUserId || result[0].ASSIGNED_TO == body.loggedUserId || result[0].ASSIGNED_BY == body.loggedUserId || result[0].PROJECT_OWNERS.includes(body.loggedUserId))) {
                                    // if(!result[0]['CAN_COMPLETE']){
                                    //     lookupArr = ['HOLD', "CLOSED"]
                                    // }else if(!result[0]['CAN_START']){
                                    //     lookupArr = ["CLOSED"]
                                    // }
                                    lookupAction = lookupAction.concat(lookup.filter(x => ['HOLD', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                                } else if (result[0].TASK_STATUS_TYPE_CODE == "HOLD" && (result[0].CREATED_BY == body.loggedUserId || result[0].ASSIGNED_TO == body.loggedUserId || result[0].ASSIGNED_BY == body.loggedUserId || result[0].PROJECT_OWNERS.includes(body.loggedUserId))) {
                                    let index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                    lookup[index].DISPLAY_VALUE = "Resume";
                                    lookupAction = lookupAction.concat(lookup.filter(x => ['IP', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                                }
                            }
                            if(result[0]['CAN_START']==false){
                                let index = lookupAction.findIndex(x => x.LOOKUP_CODE == "IP")
                                if(index!=null && index !=undefined && index>=0){
                                    lookupAction.splice(index, 1)
                                }
                                index = lookupAction.findIndex(x => x.LOOKUP_CODE == "COM")
                                if(index!=null && index !=undefined && index>=0){
                                    lookupAction.splice(index, 1)
                                }
                                index = lookupAction.findIndex(x => x.LOOKUP_CODE == "CLOSED")
                                if(index!=null && index !=undefined && index>=0){
                                    lookupAction.splice(index, 1)
                                }

                            }
                            if(result[0]['CAN_COMPLETE']==false){
                                let index = lookupAction.findIndex(x => x.LOOKUP_CODE === "COM")
                                if(index!=null && index !=undefined && index>=0){
                                    lookupAction.splice(index, 1)
                                }
                                index = lookupAction.findIndex(x => x.LOOKUP_CODE === "CLOSED")
                                if(index!=null && index !=undefined && index>=0){
                                    lookupAction.splice(index, 1)
                                }
                            }
                            //lookupAction=lookupAction.filter(x => ['IP', 'COM', "CLOSED"].includes(x.LOOKUP_CODE))
                            result[0]["LOOKUP_ACTION"] = lookupAction
                            appLogger.logMessage("debug", " Result received after executing the query: " + JSON.stringify(result), className, "viewTaskDetails", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Success", "Task details are fetched successfully", 200, result, true, "viewTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                        } else {
                            appLogger.logMessage("debug", "Details of the task is not  available . Result received after executing the query: " + JSON.stringify(result), className, "viewTaskDetails", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Warning", "Task details are not available", 404, null, false, "viewTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to fetch task details due to invalid request body", className, "viewTaskDetails", req.body.loggedUser, req.body.tenant, moduleName);
                response = await responseHandler.sendResponse("Warning", "Failed to fetch task details due to invalid request body", 404, null, false, "viewTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "viewTaskDetails", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch task details due to: " + JSON.stringify(error.message), className, "viewTaskDetails", loggedUser, tenant, moduleName);
            response = await responseHandler.sendResponse("Failure", "Failed to fetch task details due to" + error.message, 404, null, false, "viewTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "viewTaskDetails completed and the result is returned", className, "viewTaskDetails", req.body.loggedUser, req.body.tenant, moduleName);
        return response
    },

    //DELETE TASK
    deleteTask: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "deleteTask function called with the payload: " + JSON.stringify(req.body), className, "deleteTask", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;

        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.deleteTask);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to delete  task details due to missing parameters: " + JSON.stringify(missingParams), className, "deleteTask", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "deleteTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    let subTaskExists = await supportHandler.anySubTaskExits(body.taskId, 'CLOSED', body.tenantId, body.loggedUserId, body.loggedUser, body.tenant)
                    if (subTaskExists) {
                        appLogger.logMessage("info", "Task cannot be completed as it has active subtask(s) ", className, "deleteTask", loggedUser, tenant, moduleName);
                        response = await responseHandler.sendResponse("Warning", "Task cannot be deleted as it has  subtask(s)", 404, null, false, "deleteTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        let query = mysqlQueries.deleteTask;
                        let param = [
                            body.statusTypeCode,
                            body.tenantId,
                            body.projectId,
                            body.taskId
                        ];
                        let result = await dbOperations.executeQuery(query, param, loggedUser, "deleteTask", false, null, tenant, appLogger, meteringLogger, moduleName);
                        if (result != null && result != undefined && result != "error") {
                            if (result.affectedRows > 0) {
                                let updateTaskObj = {
                                    'actualCompletionDate': body.actualCompletionDate,
                                    'estimatedStartDate': body.estimatedStartDate,
                                    'estimatedCompletionDate': body.estimatedCompletionDate,
                                    'taskStatusTypeCode': body.statusTypeCode, 'mainTaskStatus': body.mainTaskStatus,
                                    'groupId': body.groupId, 'mainTaskId': body.mainTaskId, 'projectId': body.projectId,
                                    'type': body.type, 'loggedUserId': body.loggedUserId, 'tenantId': body.tenantId, 'taskId': body.taskId
                                }
                                let res = await supportHandler.taskDateChange(updateTaskObj, body.loggedUser, body.tenant)
                                await supportHandler.taskStatusChange(updateTaskObj, loggedUser, tenant)
                                if (body.type == "SUB") {
                                    await BudgetSupport.updateMainTaskBudget(body.mainTaskId, body.tenantId, loggedUser, tenant, body.loggedUserId);
                                } else {
                                    await BudgetSupport.updateBudgetOfGroup(body.groupId, body.tenantId, body.loggedUserId, loggedUser, tenant);
                                }


                                // if task added to watch list , notify watch list users on assigning 
                                //body['addedToWatchList']=true
                                if(body.addedToWatchList=='true'){
                                    let nofifyResult=await supportHandler.watchListNotification(body,'task_closed',body.loggedUser,body.tenant)
                                    appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                                }
                                appLogger.logMessage("debug", "Task is deleted successfully and the result is " + result, className, "deleteTask", loggedUser, tenant, moduleName);
                                response = await responseHandler.sendResponse("Success", "Task deleted successfully.", 200, result, true, "deleteTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                            } else {
                                appLogger.logMessage("debug", "Failed to delete task . Result received after executing the query: " + JSON.stringify(result), className, "deleteTask", loggedUser, tenant, moduleName);
                                response = await responseHandler.sendResponse("Warning", "No task found with the given taskId under the given project", 404, null, false, "deleteTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                            }
                        }
                    }



                }
            } else {
                appLogger.logMessage("info", "Failed to delete task details due to invalid request body", className, "deleteTask", req.body.loggedUser, req.body.tenant, moduleName);
                response = await responseHandler.sendResponse("warning", "Failed to fetch task details due to invalid request body", 404, null, false, "deleteTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "deleteTask", startDateTime, endDateTime, diffInMS);
        } catch (error) {
            appLogger.logMessage("error", "Failed to delete task details due to: " + JSON.stringify(error.message), className, "deleteTask", loggedUser, tenant);
            response = await responseHandler.sendResponse("Failure", "Error occured and the error is" + error.message, 404, null, false, "deleteTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "deleteTask completed", className, "deleteTask", req.body.loggedUser, req.body.tenant, moduleName);
        return response;
    },

    //UPDATE TASK
    updateTask: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "updateTask function called with the payload: " + JSON.stringify(req.body), className, "updateTask", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.updateTask);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to update  task details due to missing parameters: " + JSON.stringify(missingParams), className, "updateTask", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "updateTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    let formatedTaskName = await validationHandler.validateString(body.taskName, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                    body.taskName = formatedTaskName;
                    if (body.oldGroupId != body.groupId) {
                        let recursiveGroup = await supportHandler.checkRecurringGroup(body, body.loggedUser, body.tenant)
                        if (recursiveGroup.type.toUpperCase() == "WARNING") {
                            return recursiveGroup
                        }
                    }

                    if (body.groupName != null && body.groupName != undefined && body.groupDescription != null && body.groupDescription != undefined) {
                        let groupResult = await this.createGroup(body, body.loggedUser, body.tenant)
                        if (groupResult.type.toUpperCase() == 'SUCCESS') {
                            body['groupId'] = groupResult.data[0].ID
                        }
                    }

                    body.estimatedCompletionDate = moment(body.estimatedStartDate).add(Math.round((body.estimatedEffort / 8) - 1), 'd').format("YYYY-MM-DD")
                    body.actualCompletionDate = moment(body.estimatedStartDate).add(Math.round((body.estimatedEffort / 8) - 1), 'd').format("YYYY-MM-DD")

                    let query = mysqlQueries.updateTask;
                    let param = [
                        body.taskName,
                        body.taskDescription,
                        body.estimatedStartDate,
                        body.estimatedCompletionDate,
                        body.estimatedStartDate,
                        body.estimatedCompletionDate,
                        body.newProjectId,
                        body.estimatedEffort,
                        body.groupId,
                        body.assignedTo,
                        body.priorityTypeCode,
                        body.tenantId,
                        body.projectId,
                        body.taskId
                    ];
                    let result = await dbOperations.executeQuery(query, param, loggedUser, "updateTask", true, [9], tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result) {
                            // if any updation in recurring type
                            let recurringUpdate = await supportHandler.editRecurringTask(body, body.loggedUser, body.tenant)
                            let updateTaskObj = {
                                'actualCompletionDate': body.actualCompletionDate,
                                'estimatedStartDate': body.estimatedStartDate,
                                'estimatedCompletionDate': body.estimatedCompletionDate,
                                'taskStatusTypeCode': body.taskStatusTypeCode, 'mainTaskStatus': body.mainTaskStatus,
                                'groupId': body.groupId, 'mainTaskId': body.mainTaskId, 'projectId': body.projectId,
                                'type': body.type, 'loggedUserId': body.loggedUserId, 'tenantId': body.tenantId
                            }

                            let res = await supportHandler.taskDateChange(updateTaskObj, body.loggedUser, body.tenant)
                            if (body.oldGroupId != body.groupId && body.type == 'MAIN') {
                                let updateResult = await supportHandler.changeSubTaskGroup(body.groupId, body.loggedUserId, body.tenantId, body.mainTaskId, body.loggedUser, body.tenant)
                                await supportHandler.taskStatusChange(updateTaskObj, loggedUser, tenant)
                                updateTaskObj['groupId'] = body.oldGroupId;
                                await supportHandler.taskStatusChange(updateTaskObj, loggedUser, tenant)

                            }
                            if (body.addedToWatchList == 'true') {
                                let nofifyResult = await supportHandler.watchListNotification(body, 'task_edit', body.loggedUser, body.tenant)
                                appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                            }

                            appLogger.logMessage("debug", "Task updated successfully . Result received after executing the query: " + JSON.stringify(result), className, "updateTask", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Success", "Task updated successfully", 200, result, true, "updateTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                        } else {
                            appLogger.logMessage("debug", "Failed to update task . Result received after executing the query: " + JSON.stringify(result), className, "updateTask", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Warning", "Failed to update task", 404, null, false, "updateTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to update task details due to invalid request body", className, "updateTask", loggedUser, tenant, moduleName);
                response = await responseHandler.sendResponse("Warning", "Failed to update task details due to invalid request body", 404, null, false, "updateTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "updateTask", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to update task details due to: " + JSON.stringify(error.message), className, "updateTask", loggedUser, moduleName);
            response = await responseHandler.sendResponse("Failure", "Internal server error" + error.message, 404, null, false, "updateTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

        }
        appLogger.logMessage("info", "updateTask is completed", className, "updateTask", loggedUser, tenant, moduleName);
        return response;
    },

    //GET LOOKUP CODES
    getLookups: async function (req) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully fetched lookup codes",
            data: []
        }
        try {
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getLookup);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("error", "Failed to fetch lookup codes due to missing parameters: " + JSON.stringify(missingParams), className, "getLookups", req.body.loggedUser, req.body.tenant);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
            } else {
                if (String(req.body.loadAll).toLowerCase() != "false") {
                    let query = mysqlQueries.getAllLookups;
                    let param = [req.body.tenantId];
                    let result = await dbOperations.executeQuery(query, param, req.body.loggedUser, "getAllLookups", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                    if (result) {
                        if (Array.isArray(result)) {
                            if (result.length > 0) {
                                let resp = {};
                                let keyArr = []
                                for (let lookup of result) {
                                    if (!keyArr.includes(lookup.LOOKUP_TYPE)) {
                                        resp[lookup.LOOKUP_TYPE] = [];
                                        keyArr.push(lookup.LOOKUP_TYPE);
                                        for (let row of result) {
                                            if (row.LOOKUP_TYPE == lookup.LOOKUP_TYPE) {
                                                resp[lookup.LOOKUP_TYPE].push({
                                                    lookupCode: row.LOOKUP_CODE,
                                                    displayValue: row.DISPLAY_VALUE
                                                })
                                            }
                                        }
                                    } else {
                                        continue;
                                    }
                                }
                                appLogger.logMessage("debug", "lookup data received from server: " + JSON.stringify(resp), className, "getLookups", req.body.loggedUser, req.body.tenant);
                                out.data = resp;
                            } else {
                                appLogger.logMessage("error", "No look up code found for the tenant: " + req.body.tenant, className, "getLookups", req.body.loggedUser, req.body.tenant);
                                out.status = "Failed";
                                out.message = "No lookups found for the tenant: " + req.body.tenant;
                            }
                        } else {
                            appLogger.logMessage("error", "Invalid data received from server for lookup codes", className, "getLookups", req.body.loggedUser, req.body.tenant);
                            out.status = "Failed";
                            out.message = "Invalid data received from server"
                        }
                    } else {
                        appLogger.logMessage("error", "Failed to fetch lookups from the server", className, "getLookups", req.body.loggedUser, req.body.tenant);
                        out.status = "Failed";
                        out.message = "Failed to fetch lookup due to internal server error";
                    }
                } else {
                    let type = req.body.type;
                    if (type) {
                        if (!Array.isArray(type)) {
                            type = String(type).split(',');
                        }
                        if (Array.isArray(type)) {
                            if (type.length > 0) {
                                let query = mysqlQueries.getSpecificLookup;
                                let param = [req.body.tenantId, type];
                                let result = await dbOperations.executeQuery(query, param, req.body.loggedUser, "getSpecificLookups", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                                if (result) {
                                    if (Array.isArray(result)) {
                                        if (result.length > 0) {
                                            let resp = {};
                                            let keyArr = []
                                            for (let lookup of result) {
                                                if (!keyArr.includes(lookup.LOOKUP_TYPE)) {
                                                    resp[lookup.LOOKUP_TYPE] = [];
                                                    keyArr.push(lookup.LOOKUP_TYPE);
                                                    for (let row of result) {
                                                        if (row.LOOKUP_TYPE == lookup.LOOKUP_TYPE) {
                                                            resp[lookup.LOOKUP_TYPE].push({
                                                                lookupCode: row.LOOKUP_CODE,
                                                                displayValue: row.DISPLAY_VALUE
                                                            })
                                                        }
                                                    }
                                                } else {
                                                    continue;
                                                }
                                            }
                                            appLogger.logMessage("debug", "lookup data received from server: " + JSON.stringify(resp), className, "getLookups", req.body.loggedUser, req.body.tenant);
                                            out.data = resp;
                                        } else {
                                            appLogger.logMessage("error", "No look up code found for the tenant: " + req.body.tenant, className, "getLookups", req.body.loggedUser, req.body.tenant);
                                            out.status = "Failed";
                                            out.message = "No lookups found for the tenant: " + req.body.tenant;
                                        }
                                    } else {
                                        appLogger.logMessage("error", "Invalid data received from server for lookup codes", className, "getLookups", req.body.loggedUser, req.body.tenant);
                                        out.status = "Failed";
                                        out.message = "Invalid data received from server"
                                    }
                                }
                            } else {
                                appLogger.logMessage("error", "Failed to fetch lookups due to no lookup type received.", className, "getLookups", req.body.loggedUser, req.body.tenant);
                                out.status = "Failed";
                                out.message = "At least one lookup type required fetch the lookups";
                            }
                        } else {
                            appLogger.logMessage("error", "Failed to fetch lookups due to invalid type received. Expected an array of lookup types as inputs", className, "getLookups", req.body.loggedUser, req.body.tenant);
                            out.status = "Failed";
                            out.message = "Invalid attribute(type) expected an array of type as inputs";
                        }
                    } else {
                        appLogger.logMessage("error", "Failed to fetch lookups due to invalid lookup type received", className, "getLookups", req.body.loggedUser, req.body.tenant);
                        out.status = "Failed";
                        out.message = "Invalid lookup type reveived";
                    }
                }
            }
        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch lookups due to: " + JSON.stringify(error.message), className, "getLookups", req.body.loggedUser, req.body.tenant);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "getLookups", startDateTime, endDateTime, diffInMS);
        return out;
    },

    //DELETE/CLOSE PROJECT
    closeProject: async function (req) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully closed the project",
            data: []
        }
        try {

            let body = req.body;
            //body['taskCheck']=true
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.closeProject);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to create new project due to missing parameters: " + JSON.stringify(missingParams), className, "closeProject", body.loggedUser, body.tenant);
                    out.status = "Failed";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    if (body.taskCheck == 'true') {
                        let res = await supportHandler.anyActiveTasksOrIssueUnderProject(body.projectId, body.tenantId, body.loggedUser, body.tenant)
                        if (res.TASK_COUNT > 0 || res.ISSUE_COUNT > 0) {
                            out.status = "Warning";
                            out.statusCode = 404
                            out.message = "Active tasks (" + res.TASK_COUNT + ") and issues (" + res.ISSUE_COUNT + ") exists in project";
                            out.data = [res];
                        } else {
                            body.taskCheck = 'false'
                        }
                    }
                    if (body.taskCheck == 'false') {
                        let closeAlIssues = await supportHandler.closeAllIssues(body.projectId, body.loggedUserId, body.loggedUser, body.tenantId, body.tenant)
                        if (closeAlIssues.status == "Success") {
                            let closeAllTasks = await supportHandler.closeAllTasks(body.projectId, body.projectStatusType, body.loggedUser, body.tenant);
                            if (closeAllTasks.status == "Success") {
                                let query = mysqlQueries.deleteProject;
                                let param = [moment().format('YYYY-MM-DD'), body.projectStatusType, body.projectId, body.tenantId];
                                let result = await dbOperations.executeQuery(query, param, body.loggedUser, "closeProject", false, null, body.tenant, appLogger, meteringLogger, moduleName);
                                if (result) {
                                    if (result.affectedRows > 0) {
                                        let userData = await supportHandler.getTeamMailData(body.projectId, body.tenantId, body.loggedUser, body.tenant)
                                        let sub, message, mes
                                        if (body.projectName != null && body.projectName != undefined
                                            && body.closedByName != null && body.closedByName != undefined
                                            && body.projectDescription != null && body.projectDescription != undefined
                                            && body.actualStartDate != null && body.actualStartDate != undefined
                                            && body.actualCompletionDate != null && body.actualCompletionDate != undefined) {

                                            if (body.projectStatusType == 'COM') {
                                                sub = mailConfig.project.complete.sub
                                                sub = sub.replace('{projectName}', body.projectName)
                                                mes = mailConfig.project.complete.message
                                                out.message = "Project completed successfully"
                                            } else {
                                                sub = mailConfig.project.close.sub
                                                sub = sub.replace('{projectName}', body.projectName)
                                                sub = sub.replace('{closedByName}', body.closedByName)
                                                mes = mailConfig.project.close.message
                                                out.message = "Project closed successfully"
                                            }
                                            mes = mes.replace('{projectName}', body.projectName)
                                            mes = mes.replace('{projectDescription}', body.projectDescription)
                                            mes = mes.replace('{actualStartDate}', moment(body.actualStartDate).format('DD-MM-YYYY'))
                                            mes = mes.replace('{actualCompletionDate}', moment(body.actualCompletionDate).format('DD-MM-YYYY'))
                                            message = mes
                                            if (userData.length > 0) {
                                                sendMails(userData, null, null, sub, message, body.loggedUser, body.tenant, null, false, body.tenantId, appLogger, meteringLogger, moduleName)
                                            }
                                        } else {
                                            appLogger.logMessage("info", "Invalid parameters of email.", "ProjectHandler", "closeProject", req.body.loggedUser, req.body.tenant);

                                        }
                                        appLogger.logMessage("debug", "Successfully closed the project with the id: " + req.body.projectId, "ProjectHandler", "closeProject", req.body.loggedUser, req.body.tenant);

                                    } else {
                                        appLogger.logMessage("debug", "Failed to close the project due to no such project found in the server", "ProjectHandler", "closeProject", req.body.loggedUser, req.body.tenant);
                                        out.status = "Failed";
                                        out.message = "No such project found "
                                    }
                                } else {
                                    appLogger.logMessage("error", "Failed to close project due to null/undefined data received from server", "ProjectHandler", "closeProject", req.body.loggedUser, req.body.tenant);
                                    out.status = "Failed";
                                    out.message = "Failed to close project due to null/undefined data received from server";
                                }
                                //let closeProjectTeam = await supportHandler.closeProjectTeams(body.projectId, body.loggedUser, body.tenant);
                                // if (closeProjectTeam.status == "Success") {
                                //     let query = mysqlQueries.deleteProject;
                                //     let param = [moment().format('YYYY-MM-DD'), body.projectStatusType, body.projectId, body.tenantId];
                                //     let result = await dbOperations.executeQuery(query, param, body.loggedUser, "closeProject", false, null, req, body.tenant);
                                //     if (result) {
                                //         if (result.affectedRows > 0) {
                                //             appLogger.logMessage("debug", "Successfully closed the project with the id: " + req.body.projectId, "ProjectHandler", "closeProject", req.body.loggedUser, req.body.tenant);

                                //         } else {
                                //             appLogger.logMessage("debug", "Failed to close the project due to no such project found in the server", "ProjectHandler", "closeProject", req.body.loggedUser, req.body.tenant);
                                //             out.status = "Failed";
                                //             out.message = "No such project found to close"
                                //         }
                                //     } else {
                                //         appLogger.logMessage("error", "Failed to close project due to null/undefined data received from server", "ProjectHandler", "closeProject", req.body.loggedUser, req.body.tenant);
                                //         out.status = "Failed";
                                //         out.message = "Failed to close project due to null/undefined data received from server";
                                //     }
                                // } else {
                                //     out = closeProjectTeam;
                                // }
                            } else {
                                appLogger.logMessage("error", "Failed to delete project due to the open tasks under the projects not able to close", className, "closeProject", body.loggedUser, body.tenant);
                                out = closeAllTasks;
                            }
                        } else {
                            appLogger.logMessage("error", "Failed to complete project due to the open issues under the projects not able to close", className, "closeProject", body.loggedUser, body.tenant);
                            out = closeAlIssues;
                        }
                    }

                }
            } else {
                appLogger.logMessage("error", "Failed to close project due to invalid request body", className, "closeProject", "SELF", "SELF_TENANT");
                out.status = "Failed";
                out.message = "Invalid request body";
            }

        } catch (error) {
            appLogger.logMessage("error", "Failed to close project due to: " + JSON.stringify(error.message), className, "closeProject", req.body.loggedUser, req.body.tenant);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "closeProject", startDateTime, endDateTime, diffInMS);
        return out;
    },
    //CREATE TASK
    createTask: async function (req, loggedUser, tenant) {
        appLogger.logMessage("info", "createTask function called with the payload: " + JSON.stringify(req.body), className, "createTask", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.createTask);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to create new task due to missing parameters: " + JSON.stringify(missingParams), className, "createTask", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    let formatedTaskName = await validationHandler.validateString(body.taskName, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                    body.taskName = formatedTaskName;
                    let isExists = await supportHandler.isTaskNameExists(body.taskName, body.tenantId, body.projectId, loggedUser, tenant);
                    if (isExists != null) {
                        if (isExists == 0) {
                            let query;
                            let param = [];
                            let result;
                            let groupId
                            if (body.groupId != undefined && body.groupId != null) {
                                groupId = body.groupId
                            } else if (body.groupName != undefined && body.groupName != null && body.type == 'MAIN') {
                                let groupResult = await this.createGroup(body, body.loggedUser, body.tenant)
                                if (groupResult.type.toUpperCase() == 'SUCCESS') {
                                    groupId = groupResult.data[0].ID
                                }
                            } else if (body.groupName == undefined && body.groupName == null && body.groupId == undefined && body.groupId == null && body.type == 'MAIN') {
                                let payload = {
                                    'tenantId': body.tenantId, 'loggedUserId': body.loggedUserId, 'projectId': body.projectId,
                                    'groupName': 'General', 'groupDescription': 'General', 'groupStatus': body.taskTypeCode
                                }
                                let groupResult = await this.createGroup(payload, body.loggedUser, body.tenant)
                                if (groupResult.type.toUpperCase() == 'SUCCESS') {
                                    groupId = groupResult.data[0].ID
                                }
                            }
                            
                            let recursiveGroup = await supportHandler.checkRecurringGroup(body, body.loggedUser, body.tenant)
                            if (recursiveGroup.type.toUpperCase() == "SUCCESS") {
                                let mainTaskId;
                                if (body.mainTaskId == '' || body.mainTaskId == "NULL" || body.mainTaskId == undefined) {
                                    mainTaskId = null
                                } else {
                                    mainTaskId = body.mainTaskId
                                }

                                if(body.createFromTimesheet=='true'){
                                    body.estimatedCompletionDate = moment(body.estimatedCompletionDate).format("YYYY-MM-DD")
                                    body.actualCompletionDate = moment(body.actualCompletionDate).format("YYYY-MM-DD")
     
                                }else{
                                    body.estimatedCompletionDate = moment(body.actualStartDate).add(Math.round((body.estimatedEffort / 8) - 1), 'd').format("YYYY-MM-DD")
                                    body.actualCompletionDate = moment(body.actualStartDate).add(Math.round((body.estimatedEffort / 8) - 1), 'd').format("YYYY-MM-DD")
                                }
                                if (String(body.role).toLowerCase() == "employee") {
                                    query = mysqlQueries.createTaskByEmp;

                                    param = [
                                        body.projectId,
                                        body.tenantId,
                                        body.taskName,
                                        body.taskDescription,
                                        body.taskTypeCode,
                                        body.assignedTo || null,
                                        body.assignedBy,
                                        body.taskStatusTypeCode,
                                        body.priorityTypeCode,
                                        body.estimatedStartDate,
                                        body.estimatedCompletionDate,
                                        body.estimatedEffort,
                                        body.actualStartDate,
                                        body.actualCompletionDate,
                                        body.actualEffort,
                                        body.type,
                                        mainTaskId,
                                        groupId,
                                        body.tag||null

                                    ];
                                    result = await dbOperations.executeQuery(query, param, loggedUser, "createTask", true, [16, 17], tenant, appLogger, meteringLogger, moduleName);
                                } else if (String(body.role).toLowerCase() == "project_manager") {
                                    query = mysqlQueries.createTask;
                                    param = [
                                        body.projectId,
                                        body.tenantId,
                                        body.taskName,
                                        body.taskDescription,
                                        body.taskTypeCode,
                                        body.taskStatusTypeCode,
                                        body.priorityTypeCode,
                                        body.estimatedStartDate,
                                        body.estimatedCompletionDate,
                                        body.estimatedEffort,
                                        body.actualStartDate,
                                        body.actualCompletionDate,
                                        body.actualEffort,
                                        body.type,
                                        mainTaskId,
                                        groupId,
                                        body.assignedTo || null,
                                        body.tag||null
                                    ];
                                    result = await dbOperations.executeQuery(query, param, loggedUser, "createTask", true, [6, 15, 16], tenant, appLogger, meteringLogger, moduleName);
                                } else {
                                    appLogger.logMessage("error", "Failed to create task due to invalid role: " + body.role, className, "createTask", loggedUser, tenant, moduleName);
                                    return await responseHandler.sendResponse("Warning", "Failed to create task due to invalid role: " + body.role, 400, null, false, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                }


                                if (result) {
                                    if (result.affectedRows > 0) {
                                        let newTaskId = result.insertId
                                        // task set as recurring task
                                        let recurringResult = await this.isRecurringTask(newTaskId, body, loggedUser, tenant)
                                        //change status of the project NS->IP
                                        query = mysqlQueries.projectStatusQuery
                                        param = [body.projectId, body.tenantId]
                                        let result1 = await dbOperations.executeQuery(query, param, loggedUser, "createTask", false, null, tenant, appLogger, meteringLogger, moduleName);
                                        if (result1 != undefined && result1 != null && result1 != 'Error') {
                                            if (result1[0].PROJECT_STATUS_TYPE_CODE == 'NS') {
                                                query = mysqlQueries.setProjectStatusIP
                                                param = [body.projectId, body.tenantId]
                                                let result2 = await dbOperations.executeQuery(query, param, loggedUser, "createTask", true, [1], tenant, appLogger, meteringLogger, moduleName);
                                                if (result2 != undefined && result2 != null && result2 != 'Error') {
                                                    if (result2.affectedRows > 0) {                                                      
                                                        appLogger.logMessage("debug", "Task created successfully.Project status changed to In Progress. Result received after executing the query: " + JSON.stringify(result), className, "createTask", loggedUser, tenant, moduleName);
                                                        response = await responseHandler.sendResponse("Success", "Task is  created successfully.", 200, result, true, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                                    }
                                                }
                                            } else {
                                                appLogger.logMessage("debug", "Task created successfully and Result received after executing the query: " + JSON.stringify(result), className, "createTask", loggedUser, tenant, moduleName);
                                                response = await responseHandler.sendResponse("Success", "Task is  created successfully", 200, result, true, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                                            }
                                        } else {
                                            appLogger.logMessage("debug", " Error occurred while fetching project status .Result received after executing the query: " + JSON.stringify(result), className, "createTask", loggedUser, tenant, moduleName);
                                        }
                                        if(body.assignedTo != null && body.assignedTo != undefined){
                                          let msg = "You have been assigned to new task " + " '" + body.taskName + "' "+" in " + body.projectName + " project"
                                         await dbOperations.executeQuery(mysqlQueries.addNotification, [body.tenantId, body.assignedTo, msg, newTaskId, 'TASK'], body.loggedUser, "assignUserToTask", true, [2, 7, 8], tenant, appLogger, meteringLogger, moduleName);
                                        }
                                        
                                        //Add sub task to miletsone if its main task is added to milestone
                                        if (mainTaskId != null && mainTaskId != undefined) {
                                            let milestoneResult = await supportHandler.addSubTaskToMilestone(mainTaskId, newTaskId, body.loggedUserId, body.tenantId, body.loggedUser, body.tenant)

                                        }
                                        let updateTaskObj = {
                                            'actualCompletionDate': body.actualCompletionDate,
                                            'estimatedStartDate': body.estimatedStartDate,
                                            'estimatedCompletionDate': body.estimatedCompletionDate,
                                            'taskStatusTypeCode': body.taskStatusTypeCode, 'mainTaskStatus': body.mainTaskStatus,
                                            'groupId': groupId, 'mainTaskId': mainTaskId, 'projectId': body.projectId,
                                            'type': body.type, 'loggedUserId': body.loggedUserId, 'tenantId': body.tenantId
                                        }

                                        let res = await supportHandler.taskDateChange(updateTaskObj, body.loggedUser, body.tenant)
                                        await supportHandler.taskStatusChange(updateTaskObj, body.loggedUser, body.tenant)
                                        // if (req.body.type == 'SUB') {
                                        //     await BudgetSupport.addClassBudget(newTaskId, body.classType, body.tenantId, body.currencyCode, body.type, body.maxAmount, body.minAmount, body.loggedUserId, loggedUser, tenant, mainTaskId, groupId, body.projectId);

                                        // } else if (req.body.type == 'MAIN') {
                                        //     await BudgetSupport.addClassBudget(newTaskId, body.classType, body.tenantId, body.currencyCode, body.type, body.maxAmount, body.minAmount, body.loggedUserId, loggedUser, tenant, null, groupId, body.projectId);
                                        // }

                                        let userData = await supportHandler.getTeamMailData(body.projectId, body.tenantId, body.loggedUser, body.tenant)
                                        if (userData.length > 0) {
                                            if (body.projectName != null && body.projectName != undefined
                                                && body.createdByName != null && body.createdByName != undefined
                                                && body.groupName != null && body.groupName != undefined
                                                && body.taskName != null && body.taskName != undefined
                                                && body.taskDescription != null && body.taskDescription != undefined) {


                                                let sub = mailConfig.task.create.sub
                                                sub = sub.replace('{projectName}', body.projectName)
                                                sub = sub.replace('{createdByName}', body.createdByName)
                                                sub = sub.replace('{taskId}', newTaskId)
                                                let mes;
                                                if(body.assignedTo != null){
                                                    mes = mailConfig.task.create.message1
                                                }
                                                else{
                                                    mes = mailConfig.task.create.message
                                                }
                                                let groupName1;

                                                if (body.groupName == null) {
                                                    groupName1='General'
                                                } else {
                                                    groupName1= body.groupName
                                                }
                                                const payLoad = {
                                                    taskId: newTaskId,
                                                    projectName:body.projectName,
                                                    taskName:body.taskName,
                                                    taskDescription:body.taskDescription,
                                                    groupName:groupName1,
                                                    createdByName:body.createdByName,
                                                    assignTo:body.assignedToName
                                                     
                                                  };
                                                  // Create an array of attachments
                                                const imageFilePath = path.join(__dirname,'..', '..', 'utils', 'pictures', '1.png');
                                                const imageData = fs.readFileSync(imageFilePath);
                                                // Encode the binary data to base64
                                                const base64Image = imageData.toString('base64');
                                                const attachments = [
                                                    {
                                                        "@odata.type": "#microsoft.graph.fileAttachment",
                                                        "name": "1.png",
                                                        "contentBytes": base64Image,
                                                        "isInline": true,
                                                        "contentId": "attached-image"
                                                    }
                                                   
                                                ];
                                                
                                                 ejs.renderFile(mes,payLoad,(err, message) => {
                                                    if (err) {
                                                      console.error('Error rendering email template:', err);
                                                      res.status(500).json({ error: 'Internal server error' });
                                                      return;
                                                    }
                                                sendMails(userData, null, null, sub, message, body.loggedUser, body.tenant,  attachments, true, body.tenantId, appLogger, meteringLogger, moduleName)
                                            });
                                               
                                                if(body.assignedTo !=null && body.assignedTo!=undefined && body.assignedTo!='null'){
                                                    
                                                    let notifyResult = await supportHandler.onBoardAndAssignTask(newTaskId, null, body.assignedTo, loggedUser, tenant, false, req.body.tenantId);

                                                }

                                            } else {
                                                appLogger.logMessage("info", "Invalid credentials for email", "PMService", "createTask", loggedUser, tenant, moduleName, moduleName);
                                            }

                                        } else {
                                            appLogger.logMessage("info", "Failed to get  team  members email", "PMService", "createTask", loggedUser, tenant, moduleName, moduleName);
                                        }
										


                                        let notify = await supportHandler.notifyProjectManagerforCreation(newTaskId, body.loggedUserId, loggedUser, tenant, body.tenantId, 'TASK', null, null, null, null, null)
                                        //if task added to watch list , notify watch list users on assigning 
                                        if(body.type=='SUB'){
                                            // update progress of main task when a sub task is created 
                                            await supportHandler.updateMainTaskProgress(body,body.loggedUser,body.tenant)
                                            // if task added to watch list , notify watch list users on assigning 
                                             //body['addedToWatchList'] = true
                                            if (body.addedToWatchList == 'true') {
                                                let nofifyResult = await supportHandler.watchListNotification(body, 'create_subtask', body.loggedUser, body.tenant)
                                                appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                                            }
						
                                            
                                        }
                                        appLogger.logMessage("debug", "Task created successfully and Result received after executing the query: " + JSON.stringify(result), className, "createTask", loggedUser, tenant, moduleName);
                                        response = await responseHandler.sendResponse("Success", "Task is  created successfully", 200, result, true, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                                    } else {
                                        appLogger.logMessage("debug", "Failed to insert into task table. result received after executing the query: " + JSON.stringify(result), className, "createTask", body.loggedUser);
                                        response = await responseHandler.sendResponse("Warning", "Failed to create new task", 404, null, false, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                    }
                                }
                            } else {
                                response = recursiveGroup
                            }

                        } else {
                            appLogger.logMessage("info", "Task with the same name exists", className, "createTask", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Warning", "Task with the same name exists", 404, null, false, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    } else {
                        appLogger.logMessage("info", "Failed to create task.", className, "createTask", loggedUser, tenant, loggedUser);
                        response = await responseHandler.sendResponse("Warning", "Failed to create task", 404, null, false, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to create new task due to invalid request body", className, "createTask", loggedUser, tenant, moduleName);
                response = await responseHandler.sendResponse("Warning", "Failed to create new task due to invalid request body", 404, null, false, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "createTask", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to create new task due to: " + JSON.stringify(error.message), className, "createTask", loggedUser, tenant, moduleName);
            response = await responseHandler.sendResponse("Failure", "Failed to create new task due the error" + error.message, 404, null, false, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "createTask completed", className, "createTask", loggedUser, tenant, moduleName);
        return response;
    },

    createTasksByTemplate: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "createTask function called with the payload: " + JSON.stringify(req.body), className, "createTask", loggedUser, tenant);
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.createTasksByTemplate);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to create new task due to missing parameters: " + JSON.stringify(missingParams), className, "createTask", body.email);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    let levels = [];
                    let groupData = JSON.parse(body.groups);
                    //get all levels 
                    for (let group of groupData) {
                        for (let task of group.tasks) {
                            if (!levels.includes(task.orderOfExecution)) {
                                levels.push(task.orderOfExecution);
                            }
                            for (let subTask of task.subTasks) {
                                if (!levels.includes(subTask.orderOfExecution)) {
                                    levels.push(subTask.orderOfExecution);
                                }
                            }
                        }
                    }
                    levels = levels.sort((a, b) => a - b);
                    let currentLevel = levels[0];
                    let prevLevel = null;
                    let nextLevel = levels[1];
                    if (currentLevel == 1) {
                        //first level
                        for (let group of groupData) {
                            for (let task of group.tasks) {
                                if (task.orderOfExecution == currentLevel) {
                                    task.estimatedStartDate = moment(body.projectStartDate).format("DD-MM-YYYY");
                                    if (task.subTasks.length > 0) {
                                        for (let subTask of task.subTasks) {
                                            if (subTask.orderOfExecution == currentLevel) {
                                                subTask.estimatedStartDate = moment(body.projectStartDate).format("DD-MM-YYYY");
                                                subTask.estimatedCompletionDate = moment(subTask.estimatedStartDate).add(subTask.durationInDays, 'days');
                                            }
                                        }
                                    } else {
                                        task.estimatedCompletionDate = moment(task.estimatedStartDate, "DD-MM-YYYY").add(task.durationInDays, 'days').format("DD-MM-YYYY");
                                    }
                                    if (levels.includes(currentLevel + 1)) {
                                        nextLevel = currentLevel + 1;
                                    }

                                } else {
                                    if (task.subTasks.length > 0) {
                                        for (let subTask of task.subTasks) {
                                            if (subTask.orderOfExecution == currentLevel) {
                                                subTask.estimatedStartDate = moment(body.projectStartDate).format("DD-MM-YYYY");
                                                subTask.estimatedCompletionDate = moment(subTask.estimatedStartDate, "DD-MM-YYYY").add(subTask.durationInDays, 'days');
                                                if (levels.includes(currentLevel + 1)) {
                                                    nextLevel = currentLevel + 1;
                                                }
                                            }
                                        }
                                    }
                                }

                            }
                        }
                    }
                    prevLevel = currentLevel
                    currentLevel = nextLevel;
                    let maxLevel = levels[levels.length - 1];
                    while (currentLevel != maxLevel + 1) {
                        for (let group of groupData) {
                            for (let task of group.tasks) {
                                if (task.orderOfExecution == currentLevel) {
                                    let predecessor = task.predecessor;
                                    if (predecessor != null && predecessor != undefined) {
                                        //getting predecessors endDate
                                        for (let grp of groupData) {
                                            for (let mainTask of grp.tasks) {
                                                if (String(mainTask.taskName).toLowerCase() == String(predecessor).toLowerCase()) {
                                                    task.estimatedStartDate = moment(mainTask.estimatedCompletionDate, "DD-MM-YYYY").add(1, 'days').format("DD-MM-YYYY");
                                                    task.estimatedCompletionDate = moment(task.estimatedStartDate, "DD-MM-YYYY").add(task.durationInDays, 'days').format("DD-MM-YYYY");
                                                }
                                                for (let st of mainTask.subTasks) {
                                                    if (String(st.subTaskName).toLowerCase() == String(predecessor).toLowerCase() && st.orderOfExecution == currentLevel - 1) {
                                                        task.estimatedStartDate = moment(st.estimatedCompletionDate, "DD-MM-YYYY").add(1, 'days').format("DD-MM-YYYY");
                                                        task.estimatedCompletionDate = moment(task.estimatedStartDate, "DD-MM-YYYY").add(task.durationInDays, 'days').format("DD-MM-YYYY");
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        //previous level's endDate +1 as the task/subTasks startDate
                                        let previousLevel = currentLevel - 1
                                        let previousLevelDates = [];
                                        for (let g of groupData) {
                                            for (let t of g.tasks) {
                                                if (t.orderOfExecution == previousLevel) {
                                                    if (!previousLevelDates.includes(t.estimatedCompletionDate) && t.estimatedCompletionDate != "Invalid date" && t.estimatedCompletionDate != undefined) {
                                                        previousLevelDates.push(t.estimatedCompletionDate);
                                                    }
                                                    for (let sT of t.subTasks) {
                                                        if (!previousLevelDates.includes(sT.estimatedCompletionDate) && sT.estimatedCompletionDate != "Invalid date" && sT.estimatedCompletionDate != undefined) {
                                                            previousLevelDates.push(sT.estimatedCompletionDate);
                                                        }
                                                    }
                                                } else {
                                                    for (let sT of t.subTasks) {
                                                        if (!previousLevelDates.includes(sT.estimatedCompletionDate) && sT.estimatedCompletionDate != "Invalid date" && sT.estimatedCompletionDate != undefined && sT.orderOfExecution == previousLevel) {
                                                            previousLevelDates.push(sT.estimatedCompletionDate);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        let sortedDates = previousLevelDates.sort((a, b) => new moment(a).format('DD-MM-YYYY') - new moment(b).format('DD-MM-YYYY'))
                                        task.estimatedStartDate = moment(sortedDates[sortedDates.length - 1], "DD-MM-YYYY").add(1, 'days').format("DD-MM-YYYY");
                                        task.estimatedCompletionDate = moment(task.estimatedStartDate, "DD-MM-YYYY").add(task.durationInDays, 'days').format("DD-MM-YYYY");
                                        previousLevelDates = [];
                                    }
                                }
                                for (let sTask of task.subTasks) {
                                    if (sTask.orderOfExecution == currentLevel) {
                                        let predecessor = sTask.predecessor;
                                        if (predecessor != null && predecessor != undefined) {
                                            //getting predecessor of subTasks
                                            //getting predecessors endDate
                                            for (let grp of groupData) {
                                                for (let mainTask of grp.tasks) {
                                                    if (String(mainTask.taskName).toLowerCase() == String(predecessor).toLowerCase()) {
                                                        sTask.estimatedStartDate = moment(mainTask.estimatedCompletionDate, "DD-MM-YYYY").add(1, 'days').format("DD-MM-YYYY");
                                                        sTask.estimatedCompletionDate = moment(sTask.estimatedStartDate, "DD-MM-YYYY").add(sTask.durationInDays, 'days').format("DD-MM-YYYY");
                                                    }
                                                    for (let st of mainTask.subTasks) {
                                                        if (String(st.subTaskName).toLowerCase() == String(predecessor).toLowerCase() && st.orderOfExecution == currentLevel - 1) {
                                                            sTask.estimatedStartDate = moment(st.estimatedCompletionDate, "DD-MM-YYYY").add(1, 'days').format("DD-MM-YYYY");
                                                            sTask.estimatedCompletionDate = moment(sTask.estimatedStartDate, "DD-MM-YYYY").add(sTask.durationInDays, 'days').format("DD-MM-YYYY");
                                                        }
                                                    }
                                                }
                                            }

                                        } else {
                                            let previousLevel = currentLevel - 1
                                            let previousLevelDates = [];
                                            for (let g of groupData) {
                                                for (let t of g.tasks) {
                                                    if (t.orderOfExecution == previousLevel) {
                                                        if (!previousLevelDates.includes(t.estimatedCompletionDate) && t.estimatedCompletionDate != "Invalid date" && t.estimatedCompletionDate != undefined) {
                                                            previousLevelDates.push(t.estimatedCompletionDate);
                                                        }
                                                        for (let sT of t.subTasks) {
                                                            if (!previousLevelDates.includes(sT.estimatedCompletionDate) && sT.estimatedCompletionDate != "Invalid date" && sT.estimatedCompletionDate != undefined) {
                                                                previousLevelDates.push(sT.estimatedCompletionDate);
                                                            }
                                                        }
                                                    } else {
                                                        for (let sT of t.subTasks) {
                                                            if (!previousLevelDates.includes(sT.estimatedCompletionDate) && sT.estimatedCompletionDate != "Invalid date" && sT.estimatedCompletionDate != undefined && sT.orderOfExecution == previousLevel) {
                                                                previousLevelDates.push(sT.estimatedCompletionDate);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            let sortedDates = previousLevelDates.sort((a, b) => new moment(a).format('DD-MM-YYYY') - new moment(b).format('DD-MM-YYYY'))

                                            sTask.estimatedStartDate = moment(sortedDates[sortedDates.length - 1], "DD-MM-YYYY").add(1, 'days').format("DD-MM-YYYY");
                                            sTask.estimatedCompletionDate = moment(sTask.estimatedStartDate, "DD-MM-YYYY").add(sTask.durationInDays, 'days').format("DD-MM-YYYY");
                                            previousLevelDates = [];
                                            //previous levels highest end date+1 as this subTasks startDate
                                        }
                                    }
                                }
                            }
                        }
                        currentLevel += 1;
                    }

                    let out = await supportHandler.createTemplateTasks(groupData, body.projectId, body.tenantId, body.loggedUser, body.loggedUserId, body.tenant);
                    response = await responseHandler.sendResponse(out.status, out.message, 200, null, false, "createTemplate", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }

            } else {
                appLogger.logMessage("debug", "Failed to create new task due to invalid request body", className, "createTemplate", loggedUser, tenant);
                response = await responseHandler.sendResponse("Warning", "Failed to create new task due to invalid request body", 404, null, false, "createTemplate", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "createTask", startDateTime, endDateTime, diffInMS);
        } catch (error) {
            appLogger.logMessage("error", "Failed to create new task due to: " + JSON.stringify(error.message), className, "createTemplate", loggedUser, tenant);
            response = await responseHandler.sendResponse("Failure", "Failed to createTemplate due the error" + error.message, 404, null, false, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return response;
    },
    addTeamFromTemplate: async function (loggedUser, loggedUserId, projectId, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = false;
        try {
            let query = mysqlQueries.assignTeamFromTemplate;
            let param = [projectId];
            let result = await dbOperations.executeQuery(query, param, loggedUser, "getTemplateTasks", false, null, tenant, appLogger, meteringLogger, moduleName);
            if (result) {
                if (result.length > 0) {
                    let teamParam = [];
                    for (let row of result) {
                        let rowArr = [
                            row.TENANT_ID,
                            row.ASSIGNED_TO,
                            row.PROJECT_ID,
                            //row.ID,
                            moment().format('YYYY-MM-DD'),
                            "ENG",
                            loggedUserId,
                            loggedUserId
                        ];
                        teamParam.push(rowArr);
                    }
                    let teamInsert = await dbOperations.executeQuery(mysqlQueries.addBulkTeam, [teamParam], loggedUser, "addBulkTeam", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (teamInsert) {
                        if (teamInsert.affectedRows > 0) {
                            out = true;
                        } else {
                            appLogger.logMessage("debug", "Failed to insert. No rows were affected", className, "addBulkTeam", loggedUser, tenant, moduleName);
                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to insert teams from template tasks due to invalid response from the server", className, "addBulkTeam", loggedUser, tenant, moduleName);
                    }
                } else {
                    appLogger.logMessage("debug", "No task found under the project: " + projectId, className, "addTeamFromTemplate", loggedUser, tenant, moduleName);
                }
            } else {
                appLogger.logMessage("debug", "Failed to fetch template task due to invalid project id or there is no task created under the project: " + projectId, className, "addTeamFromTemplate", loggedUser, tenant, moduleName);
            }
        } catch (error) {
            appLogger.logMessage("error", "Error while creating team from template: " + JSON.stringify(error.message), className, "addTeamFromTemplate", loggedUser, tenant, moduleName);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(tenant, loggedUser, className, "addTeamFromTemplate", startDateTime, endDateTime, diffInMS);
        return out;
    },
    //UPDATE A PROJECT
    updateProject: async function (req, loggedUser, tenant) {
        appLogger.logMessage("info", "updateProject function called with the payload: " + JSON.stringify(req.body), className, "updateProject", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.updateProject);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to update  project details due to missing parameters: " + JSON.stringify(missingParams), className, "updateProject", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "updateProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    let formatedProjectName = await validationHandler.validateString(body.projectName, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                    body.projectName = formatedProjectName;
                    let query = mysqlQueries.updateProject;
                    let param = [
                        body.projectName,
                        body.projectDescription,
                        body.projectTypeCode,
                        body.locationName,
                        body.locationCoordinates,
                        body.estimatedStartDate,
                        body.estimatedCompletionDate,
                        body.actualStartDate,
                        body.actualCompletionDate,
                        body.projectStatusTypeCode,
                        body.tenantId,
                        body.projectId
                    ];
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "updateProject", true, [11], tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result.affectedRows > 0) {
                            appLogger.logMessage("info", "Project updated successfully ", className, "updateProject", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Success", "Successfully updated the project", 200, null, false, "updateProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("debug", "Failed to update the project . Result received after executing the query: " + JSON.stringify(result), className, "updateProject", body.loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Warning", "Failed to update the project", 404, null, false, "updateProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to update project details due to invalid request body", className, "updateProject", loggedUser, tenant, moduleName);
                out.status = "Failed";
                out.message = "Failed to update project details due to invalid request body";
                response = await responseHandler.sendResponse("Warning", "Failed to update project details due to invalid request body", 404, null, false, "updateProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "updateProject", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to update project details due to: " + JSON.stringify(error.message), className, "updateProject", req.body.loggedUser, moduleName);
            response = await responseHandler.sendResponse("Failure", "Failed to update project due to the internal error:" + error.message, 404, null, false, "updateProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

        }
        appLogger.logMessage("info", "updateProject completed", className, "updateProject", loggedUser, tenant, moduleName);

        return response;
    },

    //ADD MEMBER TO THE PROJECT
    addMemberToProject: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "addMemberToProject function called with the payload: " + JSON.stringify(req.body), className, "addMemberToProject", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.addMemberToProject);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to add member to the  task  due to missing parameters: " + JSON.stringify(missingParams), className, "addMemberToProject", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "addMemberToProjectProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    let query = mysqlQueries.addMemberToProject;
                    let param = [
                        body.tenantId,
                        body.projectId,
                        body.taskId,
                        body.effectiveStartDate,
                        body.roleTypeCode
                    ];
                    let result = await dbOperations.executeQuery(query, param, loggedUser, "addMemberToProject", true, [2, 7, 8], tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result.affectedRows > 0) {
                            appLogger.logMessage("info", "Member is added to the task successfully ", className, "addMemberToProject", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Success", "Member is added to the project successfully", 200, null, false, "addMemberToProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("debug", "Failed to add member  . Result received after executing the query: " + JSON.stringify(result), className, "addMemberToProject", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Warning", "Failed to add members to the task ", 404, null, false, "addMemberToProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to add member to the task  due to invalid request body", className, "addMemberToProject", loggedUser, tenant, moduleName);
                response = await responseHandler.sendResponse("Warning", "Failed to add member to the task  due to invalid request body ", 404, null, false, "addMemberToProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "addMemberToProject", startDateTime, endDateTime, diffInMS, moduleName);

        } catch (error) {
            appLogger.logMessage("error", "Failed to add member to the  project  due to: " + JSON.stringify(error.message), className, "addMemberToProject", loggedUser, tenant, moduleName);
            response = await responseHandler.sendResponse("Failure", "Failed to add member to the project  due to internal server error " + error.message, 404, null, false, "addMemberToProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

        }
        appLogger.logMessage("info", "addMemberToProject is completed ", className, "addMemberToProject", loggedUser, tenant, moduleName);
        return response;
    },

    //FETCH ALL ACTIVE TASK UNDER A PROJECT
    viewActiveTasks: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "viewActiveTasks function called with the payload: " + JSON.stringify(req.body), className, "viewActiveTasks", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.viewActiveTasks);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to fetch active tasks due to missing parameters: " + JSON.stringify(missingParams), className, "viewActiveTasks", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "viewActiveTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    let query = mysqlQueries.viewActiveTasks;
                    let param = [
                        body.tenantId,
                        body.projectId
                    ];
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "viewActiveTasks", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result.length > 0) {
                            appLogger.logMessage("info", "Result received after executing the query", className, "viewActiveTasks", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Success", "Active tasks are fetched successfully", 200, result, true, "viewActiveTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("debug", "No tasks are available . Result received after executing the query: " + JSON.stringify(result), className, "viewActiveTasks", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Warning", "No active task are available ", 404, null, false, "viewActiveTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    } else {
                        appLogger.logMessage("info", "Failed to fetch active tasks ", className, "viewActiveTasks", loggedUser, tenant, moduleName);
                        response = await responseHandler.sendResponse("Warning", "Failed to fetch active tasks  ", 404, null, false, "viewActiveTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to fetch active tasks due to invalid request body", className, "viewActiveTasks", loggedUser, tenant, moduleName);
                response = await responseHandler.sendResponse("Warning", "Failed to fetch tasks  due to invalid request body ", 404, null, false, "viewActiveTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "viewActiveTasks", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch active tasks due to: " + JSON.stringify(error.message), className, "viewActiveTasks", req.body.loggedUser, moduleName);
            response = await responseHandler.sendResponse("Failure", "Internal server error " + error.message, 404, null, false, "viewActiveTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "viewActiveTasks completed", className, "viewActiveTasks", loggedUser, tenant, moduleName);
        return response;
    },

    //FETCH ALL USERS IN A TENANT
    getAllUsers: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "getAllUsers function called with the payload: " + JSON.stringify(req.body), className, "getAllUsers", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getAllUsers);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to fetch users due to missing parameters: " + JSON.stringify(missingParams), className, "getAllUsers", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "getAllUsers", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    let query = mysqlQueries.getAllUsers;
                    let param = [
                        body.tenantId,
                        body.projectId
                    ];
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "getAllUsers", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result.length > 0) {
                            appLogger.logMessage("info", "Users fetched successfully", className, "getAllUsers", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Success", "Users are fetched successfully", 200, result, true, "getAllUsers", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("debug", "No users are available . Result received after executing the query: " + JSON.stringify(result), className, "getAllUsers", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Warning", "No users are available ", 404, null, false, "getAllUsers", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    } else {
                        appLogger.logMessage("info", "Failed to fetch users ", className, "getAllUsers", loggedUser, tenant, moduleName);
                        response = await responseHandler.sendResponse("Warning", "Failed to fetch users  ", 404, null, false, "getAllUsers", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to fetch users due to invalid request body", className, "getAllUsers", loggedUser, tenant, moduleName);
                response = await responseHandler.sendResponse("Warning", "Failed to fetch users  due to invalid request body ", 404, null, false, "getAllUsers", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "getAllUsers", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch users due to: " + JSON.stringify(error.message), className, "getAllUsers", req.body.loggedUser, moduleName);
            response = await responseHandler.sendResponse("Failure", "Internal server error " + error.message, 500, null, false, "getAllUsers", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "getAllUsers completed ", className, "getAllUsers", loggedUser, tenant, moduleName);
        return response;
    },

    //ASSIGN USER TO TASK
    assignUserToTask: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "assignUserToTask function called with the payload: " + JSON.stringify(req.body), className, "assignUserToTask", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.assignUserToTask);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to assign  task due to missing parameters: " + JSON.stringify(missingParams), className, "assignUserToTask", loggedUser, tenant, moduleName);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "assignUserToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    let isExists = await supportHandler.isTaskAssigned(body, loggedUser, tenant);
                    if (isExists != undefined && isExists != null) {
                        if (isExists.data[0].notAssigned == true) {
                            param = [
                                body.userId,
                                body.tenantId,
                                body.projectId,
                                body.taskId,
                            ]
                            query = mysqlQueries.setActualStartDate;
                            let result = await dbOperations.executeQuery(query, param, body.loggedUser, "assignUserToTask", true, [2], tenant, appLogger, meteringLogger, moduleName);
                            if (result != null && result != undefined && result != "error") {
                                let updateTaskObj = {
                                    'actualCompletionDate': body.actualCompletionDate,
                                    'estimatedStartDate': body.estimatedStartDate,
                                    'estimatedCompletionDate': body.estimatedCompletionDate,
                                    'taskStatusTypeCode': 'OPEN', 'mainTaskStatus': body.mainTaskStatus,
                                    'groupId': body.groupId, 'mainTaskId': body.mainTaskId, 'projectId': body.projectId,
                                    'type': body.type, 'loggedUserId': body.loggedUserId, 'tenantId': body.tenantId, 'taskId': body.taskId
                                }

                                let res = await supportHandler.taskDateChange(updateTaskObj, body.loggedUser, body.tenant)
                                await supportHandler.taskStatusChange(updateTaskObj, body.loggedUser, body.tenant);
                                let msg = "You have been assigned to new task " + " '" + body.taskName + "' "+" in " + body.projectName + " project"
                                result = await dbOperations.executeQuery(mysqlQueries.addNotification, [body.tenantId, body.userId, msg, body.taskId, 'TASK'], body.loggedUser, "assignUserToTask", true, [2, 7, 8], tenant, appLogger, meteringLogger, moduleName);
                                appLogger.logMessage("info", "Task assigned successfully", className, "assignUserToTask", loggedUser, tenant, moduleName);
                                if (body.loggedUserId != body.userId) {
                                    
                                        let signatureKeys = Object.keys(apiSignatures.mailAssignUserToTask);
                                        for (let key of signatureKeys) {
                                            if (!requestParams.includes(key)) {
                                                missingParams.push(key);
                                            }
                                        }  

                                        if (missingParams.length > 0) {
                                            appLogger.logMessage("debug", "Invalid parameters for email.", className, "assignUserToTask", loggedUser, tenant, moduleName);
                                        }
                                         else 
                                        {
                                         let sub = mailConfig.task.assign.sub
                                        sub = sub.replace('{taskId}', body.taskId)
                                        sub = sub.replace('{projectName}', body.projectName)
                                        sub = sub.replace('{assignedByName}', body.assignedByName)
                                        let mes = mailConfig.task.assign.message
                                        let message;
                                        // Example dynamic data
                                        const payLoad = {
                                            taskId:body.taskId,
                                            projectName:body.projectName,
                                            taskName:body.taskName,
                                            taskDescription:body.taskDescription,
                                            estimatedStartDate:moment(body.estimatedStartDate).format("DD-MM-YYYY"),
                                            estimatedCompletionDate: moment(body.estimatedCompletionDate).format("DD-MM-YYYY"),
                                            assignedByName:body.assignedByName,
                                            groupName:body.groupName,
                                            createdByName:body.createdByName   
                                          };
                                          const templatePath=mes;
                                        ejs.renderFile(templatePath,payLoad,(err, htmlContent) => {
                                            if (err) {
                                              console.error('Error rendering email template:', err);
                                              res.status(500).json({ error: 'Internal server error' });
                                              return;
                                            }
                                        
                                        let userData = []
                                        if (body.loggedUserId != body.assignedTo) {
                                            userData = [{ 'Id': body.userId, 'Email': body.userMail }]
                                        }
                                        if (userData.length > 0) {
                                            sendMails(userData, null, null, sub, htmlContent, body.loggedUser, body.tenant, null, false, body.tenantId, appLogger, meteringLogger, moduleName)
                                        }
                                        
                                    });
                                    }
                                    
                                }
                                // if task added to watch list , notify watch list users on assigning 
                                //body['addedToWatchList']==true
                                if(body.addedToWatchList=='true'){
                                    let nofifyResult=await supportHandler.watchListNotification(body,'task_assign',body.loggedUser,body.tenant)
                                    appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                                }
								

                                let notifyResult = await supportHandler.onBoardAndAssignTask(body.taskId, null, body.userId, loggedUser, tenant, false, req.body.tenantId);

                                appLogger.logMessage("debug", "Response after notifying the user about assigned a new task: " + JSON.stringify(notifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                                response = await responseHandler.sendResponse("Success", "Task assigned successfully", 200, result, true, "assignUserToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            } else {
                                appLogger.logMessage("debug", "Failed to assign user to task . Result received after executing the query: " + JSON.stringify(result), className, "assignUserToTask", loggedUser, tenant, moduleName);
                                response = await responseHandler.sendResponse("Warning", "Failed to assign task", 404, null, false, "assignUserToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            }
                            //.......................
                            // let query = mysqlQueries.assignUserToTask;
                            // let param = [
                            //     body.tenantId,
                            //     body.userId,
                            //     body.projectId,
                            //     body.taskId,
                            //     moment().format('YYYY-MM-DD'),
                            //     body.roleTypeCode
                            
                        } else {
                            appLogger.logMessage("info", "The task is already assigned to this user", className, "assignUserToTask", loggedUser, tenant, moduleName);
                            response = await responseHandler.sendResponse("Warning", " The task is already assigned to this user", 404, null, false, "assignUserToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                        }
                    } else {
                        appLogger.logMessage("info", "Failed to assign task", className, "assignUserToTask", loggedUser, tenant, moduleName);
                        response = await responseHandler.sendResponse("Warning", "Failed to assign task  ", 404, null, false, "assignUserToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to assign user to the task due to invalid request body", className, "assignUserToTask", loggedUser, tenant, moduleName);
                response = await responseHandler.sendResponse("Warning", "Failed to assign task due to invalid request body ", 404, null, false, "assignUserToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "assignUserToTask", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to assign user to the task due to: " + JSON.stringify(error.message), className, "assignUserToTask", req.body.loggedUser, moduleName);
            response = await responseHandler.sendResponse("Failure", "Internal server error " + error.message, 404, null, false, "assignUserToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "assignUserToTask", className, "assignUserToTask", loggedUser, tenant, moduleName);
        return response;
    },
    terminateAllLookUp: async function (req) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            type: "Success",
            message: "Successfully terminated",
            data: []
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.terminateAllLookUp);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to create new project due to missing parameters: " + JSON.stringify(missingParams), className, "terminateLookUp", body.loggedUser, body.tenant);
                    out.type = "Warning";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    let query = mysqlQueries.deleteAllLookup;
                    let param = [body.tenantId];
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "terminateLookup", true, [1], req, body.tenant, appLogger, meteringLogger, moduleName);
                    if (result) {
                        if (result.affectedRows > 0) {
                            appLogger.logMessage("debug", "Successfully terminated  the lookup with tenant id: " + req.body.tenantId, "ProjectHandler", "terminateLookUp", req.body.loggedUser, req.body.tenant);
                        } else {
                            appLogger.logMessage("debug", "Failed to terminate the lookup due to no such lookup found in the server", "ProjectHandler", "terminateLookUp", req.body.loggedUser, req.body.tenant);
                            out.type = "Warning";
                            out.message = "No such LookUp found to close"
                        }
                    } else {
                        appLogger.logMessage("error", "Failed to close lookup due to null/undefined data received from server", "ProjectHandler", "terminateLookUp", req.body.loggedUser, req.body.tenant);
                        out.type = "Warning";
                        out.message = "Failed to terminate LookUP due to null/undefined data received from server";
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to terminate Lookup due to invalid request body", className, "terminateLookUp", "SELF", "SELF_TENANT");
                out.type = "Warning";
                out.message = "Invalid request body";
            }

        } catch (error) {
            appLogger.logMessage("error", "Failed to close project due to: " + JSON.stringify(error.message), className, "terminateLookUp", req.body.loggedUser, req.body.tenant);
            out.type = "Failure";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "closeProject", startDateTime, endDateTime, diffInMS);
        return out;
    },

    terminateLookupType: async function (req) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            type: "Success",
            message: "Successfully terminated",
            data: []
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.terminateLookupType);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to create new project due to missing parameters: " + JSON.stringify(missingParams), className, " terminateLookupType", body.loggedUser, body.tenant);
                    out.type = "Warning";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    let query = mysqlQueries.deleteLookupType;
                    let param = [body.tenantId, body.lookupType];
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "terminateLookupType", false, null, req, body.tenant, appLogger, meteringLogger, moduleName);
                    if (result) {
                        if (result.affectedRows > 0) {
                            appLogger.logMessage("debug", "Successfully terminated  the lookup with tenant id: " + req.body.tenantId + "and lookupType:" + req.body.lookupType, "ProjectHandler", " terminateLookupType", req.body.loggedUser, req.body.tenant);
                        } else {
                            appLogger.logMessage("debug", "Failed to terminate the lookup due to no such lookup found in the server", "ProjectHandler", " terminateLookupType", req.body.loggedUser, req.body.tenant);
                            out.type = "Warning";
                            out.message = "No such LookUp found to close"
                        }
                    } else {
                        appLogger.logMessage("error", "Failed to close lookup due to null/undefined data received from server", "ProjectHandler", " terminateLookupType", req.body.loggedUser, req.body.tenant);
                        out.type = "Warning";
                        out.message = "Failed to terminate LookUP due to null/undefined data received from server";
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to terminate Lookup due to invalid request body", className, "terminateLookupType", "SELF", "SELF_TENANT");
                out.type = "Warning";
                out.message = "Invalid request body";
            }

        } catch (error) {
            appLogger.logMessage("error", "Failed to terminate project due to: " + JSON.stringify(error.message), className, "terminateLookupType", req.body.loggedUser, req.body.tenant);
            out.type = "Failure";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, " terminateLookupType", startDateTime, endDateTime, diffInMS);
        return out;
    },

    terminateLookupTypeField: async function (req) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            type: "Success",
            message: "Successfully terminated",
            data: []
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.terminateLookupTypeField);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to create new project due to missing parameters: " + JSON.stringify(missingParams), className, " terminateLookupTypeField", body.loggedUser, body.tenant);
                    out.type = "Warning";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    let query = mysqlQueries.deleteLookupTypeField;
                    let param = [body.tenantId, body.lookupType, body.lookupCode];
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "terminateLookupType", false, null, req, body.tenant, appLogger, meteringLogger, moduleName);
                    if (result) {
                        if (result.affectedRows > 0) {
                            appLogger.logMessage("debug", "Successfully terminated  the lookup with tenant id: " + req.body.tenantId + ", lookupType:" + req.body.lookupType + "and lookupCode:" + req.body.lookupCode, "ProjectHandler", " terminateLookupType", req.body.loggedUser, req.body.tenant);
                        } else {
                            appLogger.logMessage("debug", "Failed to terminate the lookup due to no such lookup found in the server", "ProjectHandler", " terminateLookupType", req.body.loggedUser, req.body.tenant);
                            out.type = "Warning";
                            out.message = "No such LookUp found to close"
                        }
                    } else {
                        appLogger.logMessage("error", "Failed to close lookup due to null/undefined data received from server", "ProjectHandler", " terminateLookupType", req.body.loggedUser, req.body.tenant);
                        out.type = "Warning";
                        out.message = "Failed to terminate LookUP due to null/undefined data received from server";
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to terminate Lookup due to invalid request body", className, "terminateLookupType", "SELF", "SELF_TENANT");
                out.type = "Warning";
                out.message = "Invalid request body";
            }

        } catch (error) {
            appLogger.logMessage("error", "Failed to terminate project due to: " + JSON.stringify(error.message), className, "terminateLookupType", req.body.loggedUser, req.body.tenant);
            out.type = "Failure";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, " terminateLookupTypeField", startDateTime, endDateTime, diffInMS);
        return out;
    },

    updateLookup: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "updateLookup function called with the payload: " + JSON.stringify(req.body), className, "updateLookup", loggedUser, tenant);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.updateLookup);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to update  project details due to missing parameters: " + JSON.stringify(missingParams), className, "updateLookup", loggedUser, tenant);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "updateLookup", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    let formatedLookupType = await validationHandler.validateString(body.lookupType, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                    body.lookupType = formatedLookupType;
                    let parsedLookupData = JSON.parse(body.lookupData);
                    let query = mysqlQueries.updateLookupType;
                    let param = [
                        parsedLookupData.lookupCode,
                        parsedLookupData.displayValue,
                        // body.lookupData.lookupCode,
                        // body.lookupData.displayValue,
                        body.tenantId,
                        body.lookupType
                    ];
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "updateLookup", true, [3], tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result.affectedRows > 0) {
                            appLogger.logMessage("debug", "Failed to updateLookup . Result received after executing the query: " + JSON.stringify(result), className, "updateLookup", loggedUser, tenant);
                            response = await responseHandler.sendResponse("Success", "Successfully updated the Lookup", 200, null, false, "update", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("debug", "Failed to update lookup . Result received after executing the query: " + JSON.stringify(result), className, "updateLookup", body.loggedUser, tenant);
                            response = await responseHandler.sendResponse("Warning", "Failed to updateLookup ", 404, null, false, "updateLookup", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to update project details due to invalid request body", className, "update", "USER");

                response = await responseHandler.sendResponse("Warning", "Failed to update project details due to invalid request body", 404, null, false, "updateLookUp", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "updateLookup", startDateTime, endDateTime, diffInMS);
        } catch (error) {
            appLogger.logMessage("error", "Failed to update project details due to: " + JSON.stringify(error.message), className, "updateLookup", req.body.email);
            response = await responseHandler.sendResponse("Failure", "Failed to update lookup due to the internal error:" + error.message, 404, null, false, "updateLookup", tenant, loggedUser, moduleName, appLogger, meteringLogger);

        }
        return response;
    },

    addLookup: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "createLookup function called with the payload: " + JSON.stringify(req.body), className, "addLookup", loggedUser, tenant);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.addLookup);

                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to create lookup due to missing parameters: " + JSON.stringify(missingParams), className, "addLookup", body.email);
                    response = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "addLookup", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    let formatedLookupType = await validationHandler.validateString(body.lookupType, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                    body.lookupType = formatedLookupType;

                    let isExists = await supportHandler.isLookupFieldExists(body, loggedUser, tenant);
                    if (isExists != null) {
                        if (isExists == 0) {
                            let userData = await supportHandler.getUserId(body.loggedUser, body.tenant);
                            if (String(userData.status).toLowerCase("success")) {
                                let userId = userData.data["userId"];
                                let query = mysqlQueries.addLookups;
                                let param = [];
                                let records = [];
                                if (body.lookupData) {
                                    if (Array.isArray(body.lookupData)) {
                                        for (let data of body.lookupData) {
                                            records.push(body.tenantId);
                                            records.push(body.lookupType);
                                            records.push(data.lookupCode);
                                            records.push(data.displayValue);
                                            records.push(moment().format('YYYY-MM-DD'));
                                            records.push(userId);
                                            records.push(userId);
                                            param.push(records);
                                            records = [];
                                        }
                                        if (param.length > 0) {
                                            appLogger.logMessage("debug", "Parameters created for batch insert lookupData: " + JSON.stringify(param), className, "createLookup", loggedUser, tenant);
                                            let result = await dbOperations.executeQuery(query, param, loggedUser, "createLookup", false, null, tenant, appLogger, meteringLogger, moduleName);
                                            if (result) {
                                                if (result.affectedRows > 0) {
                                                    appLogger.logMessage("info", "lookup created successfully and Result received after executing the query: " + JSON.stringify(result), className, "createTask", loggedUser, tenant);
                                                    response = await responseHandler.sendResponse("Success", "Lookup is  created successfully", 200, result, true, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                                                } else {
                                                    appLogger.logMessage("debug", "Failed to insert to lookup table. result received after executing the query: " + JSON.stringify(result), className, "createTask", body.email);
                                                    response = await responseHandler.sendResponse("Warning", "Failed to create new task", 404, null, false, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                                }
                                            }
                                        } else {
                                            response = responseHandler.sendResponse("Warning", "Invalid parameter created.", 501, [], false, "addLookups", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                        }
                                    } else {
                                        response = responseHandler.sendResponse("Warning", "Invalid data received. Expected an array of lookupData", 501, [], false, "addLookups", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                    }
                                } else {
                                    response = responseHandler.sendResponse("Warning", "Invalid parameter", 501, [], false, "addLookups", tenant, loggedUser);
                                }

                            } else {
                                response = responseHandler.sendResponse(userData.status, userData.message, 500, userData.data, false, "getUserId", body.tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            }
                        } else {
                            response = responseHandler.sendResponse("Warning", "Lookup already exsist", 501, [], false, "addLookups", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }

                    } else {
                        response = responseHandler.sendResponse("Warning", "Failed to create lookup", 501, [], false, "addLookups", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }

                }
            } else {
                appLogger.logMessage("error", "Failed to create new lookup due to invalid request body", className, "createTask", loggedUser, tenant);
                response = await responseHandler.sendResponse("Warning", "Failed to create new lookup due to invalid request body", 404, null, false, "createTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "createLookup", startDateTime, endDateTime, diffInMS);
        } catch (error) {
            appLogger.logMessage("error", "Failed to create new lookup due to: " + JSON.stringify(error.message), className, "createlookup", loggedUser, tenant);
            response = await responseHandler.sendResponse("Failure", "Failed to create new lookup due the error" + error.message, 404, null, false, "createLookup", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return response;
    },

    addLookupField: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "addLookupField function called with the payload: " + JSON.stringify(req.body), className, "addLookupField", req.body.loggedUser, req.body.tenant);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            type: "Success",
            message: "Successfully created new LookupField",
            data: {}
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.addLookupField);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to create lookupField due to missing parameters: " + JSON.stringify(missingParams), className, "addLookupField", body.loggedUser, body.tenant);
                    out.type = "Warning";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    let formatedLookupType = await validationHandler.validateString(body.lookupType, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                    body.lookupType = formatedLookupType;
                    let parsedLookupData = JSON.parse(body.lookupData);
                    let isExists = await supportHandler.isLookupExists(body, loggedUser, tenant);
                    if (isExists != null) {
                        if (isExists == 0) {
                            let query = mysqlQueries.createLookupField;
                            let param = [
                                body.tenantId,
                                body.lookupType,
                                parsedLookupData.lookupCode,
                                parsedLookupData.displayValue
                                // body.lookupData.lookupCode,
                                // body.lookupData.displayValue, 
                            ];
                            let result = await dbOperations.executeQuery(query, param, body.loggedUser, "createLookup", true, [6, 7], body.tenant, appLogger, meteringLogger, moduleName);
                            if (result) {
                                if (result.affectedRows > 0) {
                                    appLogger.logMessage("debug", "Successfully added  the lookup with the tenantId: " + req.body.tenantId, "ProjectHandler", "createLookup", req.body.loggedUser, req.body.tenant);

                                } else {
                                    appLogger.logMessage("debug", "Failed to insert into lookup table. result received after executing the query: " + JSON.stringify(result), className, "createLookup", body.loggedUser, body.tenant);
                                    out.type = "Warning";
                                    out.message = "Failed to create lookup due to internal error";
                                }
                            } else {
                                out.type = "Warning";
                                out.message = "Failed to create lookup ";
                            }
                        } else {
                            out.type = "Warning";
                            out.message = "Lookup  already exists";
                        }

                    } else {
                        out.type = "Warning";
                        out.message = "Failed to create Lookup";
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to create lookup due to invalid request body", className, "(?,?,?,?,?,?,?)", "USER", req.body.tenant);
                out.type = "Warning";
                out.message = "Failed to create lookup due to invalid request body";
            }
        } catch (error) {
            appLogger.logMessage("error", "Failed to create lookup due to: " + JSON.stringify(error.message), className, "createLookup", req.body.loggedUser, req.body.tenant);
            out.type = "Failure";
            out.message = "Internal Server Error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "createLookup", startDateTime, endDateTime, diffInMS);
        return out;
    },

    //MARK TASK AS COMPLETED
    completeTask: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "completeTask function called with the payload: " + JSON.stringify(req.body), className, "completeTask", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Task completed successfully ",
            statusCode: '200',
            data: []
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.completeTask);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to complete task due to missing parameters: " + JSON.stringify(missingParams), className, "completeTask", loggedUser, tenant, moduleName);
                    out.status = "warning"
                    out.message = "Failed to complete task due to missing parameters: " + JSON.stringify(missingParams)
                    out.statusCode = 404
                } else {
                    let subTaskExists = await supportHandler.anySubTaskExits(body.taskId, 'COM', body.tenantId, body.loggedUserId, body.loggedUser, body.tenant)
                    if (subTaskExists) {
                        appLogger.logMessage("info", "Task cannot be completed as it has active subtask(s) ", className, "completeTask", loggedUser, tenant, moduleName);
                        out.status = "Warning"
                        out.message = "Cannot complete the main task since it has active subtasks "
                        out.statusCode = 404
                        out.data = []
                    } else {
                        let completedDate
                        if (body.completedDate) {
                            completedDate = body.completedDate
                        } else {
                            completedDate = moment().format('YYYY-MM-DD');
                        }
                        let approvalStatus = (body.approvalRequired == "Y") ? "Awaiting Approval" : null
                        let query = mysqlQueries.completeTask;
                        // when task is completed progress is set to be 100%
                        let param = [
                            100,
                            completedDate,
                            body.loggedUserId,
                            approvalStatus,
                            body.tenantId,
                            body.projectId,
                            body.taskId
                        ];
                        let result = await dbOperations.executeQuery(query, param, body.loggedUser, "completeTask", false, null, tenant, appLogger, meteringLogger, moduleName);
                        if (result != null && result != undefined && result != "error") {
                            if (result.affectedRows > 0) {
                                let updateTaskObj = {
                                    'actualCompletionDate': body.actualCompletionDate,
                                    'estimatedStartDate': body.estimatedStartDate,
                                    'estimatedCompletionDate': body.estimatedCompletionDate,
                                    'taskStatusTypeCode': 'COM', 'mainTaskStatus': body.mainTaskStatus,
                                    'groupId': body.groupId, 'mainTaskId': body.mainTaskId, 'projectId': body.projectId,
                                    'type': body.type, 'loggedUserId': body.loggedUserId, 'tenantId': body.tenantId, 'taskId': body.taskId
                                }

                                let res = await supportHandler.taskDateChange(updateTaskObj, body.loggedUser, body.tenant)
                                await supportHandler.taskStatusChange(updateTaskObj, body.loggedUser, body.tenant)
                                // query = mysqlQueries.closeTaskAssigned;
                                // param = [
                                //     body.tenantId,
                                //     body.projectId,
                                //     body.taskId,
                                // ];
                                // let pos = [4];
                                // let result = await PMSSupport.closeTaskAssigned(query, param, pos, loggedUser, tenant)
                                appLogger.logMessage("info", "Successfully completed task", className, "completeTask", loggedUser, tenant, moduleName);
                                if(body.hasOwnProperty("approvers")){
                                    if(JSON.parse(body.approvers).length > 0){
                                        if(body.comment != null && body.comment != undefined ){
                                            let res = await dbOperations.executeQuery(mysqlQueries.addComment, [body.tenantId,body.taskId,'A1008',body.comment,null], loggedUser, "taskReq", true, [6,7], tenant, appLogger, meteringLogger, moduleName)
                                            if(res != undefined && res != null && res != 'Error'){
                                                if(res.affectedRows > 0){
                                                    await supportHandler.notifySelectedUser(body,JSON.parse(body.approvers),body.loggedUser, body.tenant);
                                                }else{
                                                    appLogger.logMessage("info", "Failed to save comment", "PMSSupport", "completeTAsk", loggedUser, tenant, moduleName);
                                                }
                                            }
                                        }else{
                                            await supportHandler.notifySelectedUser(body,JSON.parse(body.approvers),body.loggedUser, body.tenant);
                                        }
                                    }else{
                                        await supportHandler.notifyProjectManager(body.taskId, body.loggedUserId, 'COM', body.loggedUser, body.tenant, body.tenantId,body.approvalRequired);
                                    }
                                }else{
                                    await supportHandler.notifyProjectManager(body.taskId, body.loggedUserId, 'COM', body.loggedUser, body.tenant, body.tenantId,body.approvalRequired);
                                }
                                // if task added to watch list , notify watch list users on assigning 
                                //body['addedToWatchList']=true
                                if(body.addedToWatchList=='true'){
                                    let nofifyResult=await supportHandler.watchListNotification(body,'task_complete',body.loggedUser,body.tenant)
                                    appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                                }
                                let templateTasks = await dbOperations.executeQuery(mysqlQueries.getAutomatedTasks, [body.projectId], loggedUser, "getAutomatedTasks", false, null, tenant, appLogger, meteringLogger, moduleName);
                                if (templateTasks) {
                                    if (templateTasks.length > 0) {
                                        let min = templateTasks[0].ORDER_OF_EXECUTION;
                                        if (min != null && min != undefined) {
                                            let upcomingTasks = [];
                                            let currentOrder = 0;
                                            for (let task of templateTasks) {
                                                if (task.TASK_ID == body.taskId) {
                                                    currentOrder = task.ORDER_OF_EXECUTION;
                                                }
                                            }
                                            for (let task of templateTasks) {
                                                if (task.ORDER_OF_EXECUTION > currentOrder) {
                                                    upcomingTasks.push(task);
                                                }
                                            }
                                            if (upcomingTasks.length > 0) {
                                                min = upcomingTasks[0].ORDER_OF_EXECUTION;
                                                for (let task of upcomingTasks) {
                                                    if (task.ORDER_OF_EXECUTION < min) {
                                                        min = task.ORDER_OF_EXECUTION
                                                    }
                                                }
                                                let usersToNotify = [];
                                                let startNextTasks = []
                                                for (let task of upcomingTasks) {
                                                    if (task.ORDER_OF_EXECUTION == min) {
                                                        usersToNotify.push(task);
                                                        startNextTasks.push(task.TASK_ID);
                                                    }
                                                }
                                                let startAutomatedTasks = await dbOperations.executeQuery(mysqlQueries.startAutomatedTask, ["IP", [startNextTasks]], loggedUser, "automateTasks", false, null, tenant, appLogger, meteringLogger, moduleName);
                                                if (startAutomatedTasks) {
                                                    if (usersToNotify[0].ASSIGNED_TO == null || usersToNotify[0].ASSIGNED_TO == undefined) {
                                                        //notify PM task started has not  assigned  to a person

                                                        //let userData=[{'Id':usersToNotify[0].USER_ID,'Email':usersToNotify[0].EMAIL}]
                                                        let ownerData = await supportHandler.getProjectOwnerDetails(usersToNotify[0].PROJECT_ID, body.loggedUser, body.tenantId, body.tenant)
                                                        if (ownerData.message == 'Success') {
                                                            let sub = "Task started before assigning"
                                                            let message = '<p>Hi,' + '<p><b><br> ' + '</b> Task <b> ' + body.TASK_NAME + 'in <b>' + body.projectName + 'started without assigning to a user';
                                                            let userData = out.data
                                                            sendMails(userData, null, null, sub, message, data.loggedUser, data.tenant, null, false, data.tenantId, appLogger, meteringLogger, moduleName)
                                                        }
                                                    }
                                                    else if (usersToNotify[0].ASSIGNED_TO) {
                                                        //notify  assigned to user
                                                        if (body.taskDescription != null && body.taskDescription != undefined
                                                            && body.estimatedStartDate != null && body.estimatedStartDate != undefined
                                                            && body.estimatedCompletionDate != null && body.estimatedCompletionDate != undefined
                                                            && body.assignedByName != null && body.assignedByName != undefined) {
                                                            sub = mailConfig.task.start.sub
                                                            mes = mailConfig.task.start.message
                                                            mes = mes.replace('{assignedToName}', usersToNotify[0].FULL_NAME)
                                                            mes = mes.replace('{projectName}', usersToNotify[0].PROJECT_NAME)
                                                            mes = mes.replace('{taskName}', usersToNotify[0].TASK_NAME)
                                                            mes = mes.replace('{taskDescription}', body.taskDescription)
                                                            mes = mes.replace('{estimatedStartDate}', body.estimatedStartDate)
                                                            mes = mes.replace('{estimatedCompletionDate}', body.estimatedCompletionDate)
                                                            mes = mes.replace('{assignedByName}', body.assignedByName)
                                                            //mes=mes.replace('{createdByName}',data.createdByName)
                                                            message = mes

                                                            let userData = [{ 'Id': usersToNotify[0].USER_ID, 'Email': usersToNotify[0].EMAIL }]
                                                            sendMails(userData, null, null, sub, message, body.loggedUser, body.tenant, null, false, body.tenantId, appLogger, meteringLogger, moduleName)
                                                        } else {
                                                            appLogger.logMessage("debug", "Invalid parameters for email", className, "completeTask", loggedUser, tenant, moduleName);
                                                        }
                                                    }
                                                    let notifyResponse = await PMSSupport.sendWhatsappNotification(usersToNotify, loggedUser, tenant);
                                                    appLogger.logMessage("debug", "Response after sending notification to users: " + JSON.stringify(notifyResponse), className, "completeTask", loggedUser, tenant, moduleName);
                                                } else {
                                                    appLogger.logMessage("debug", "Failed to start next task in queue due to invalid response from the server", className, "completeTask", loggedUser, tenant, moduleName);
                                                }
                                            } else {
                                                appLogger.logMessage("debug", "All tasks have been completed. There is no tasks to start", className, "completeTask", loggedUser, tenant, moduleName);
                                            }
                                        } else {
                                            appLogger.logMessage("debug", "There is no order of execution for this project which means it is not an automated project", className, "completeTask", loggedUser, tenant, moduleName);
                                        }
                                    } else {
                                        appLogger.logMessage("debug", "No tasks found to start automatically", className, "completeTask", loggedUser, tenant, moduleName);
                                    }
                                } else {
                                    appLogger.logMessage("debug", "Failed to start next automated task due to invalid response from server", className, "completeTask", loggedUser, tenant, moduleName);
                                }
                                // if (result) {
                                //     appLogger.logMessage("info", "Successfully complete task", className, "completeTask", loggedUser, tenant, moduleName);
                                //     let templateTasks = await dbOperations.executeQuery(mysqlQueries.getAutomatedTasks, [body.projectId], loggedUser, "getAutomatedTasks", false, null, tenant);
                                //     if (templateTasks) {
                                //         if (templateTasks.length > 0) {
                                //             let min = templateTasks[0].ORDER_OF_EXECUTION;
                                //             if (min != null && min != undefined) {
                                //                 let upcomingTasks = [];
                                //                 let currentOrder = 0;
                                //                 for (let task of templateTasks) {
                                //                     if (task.TASK_ID == body.taskId) {
                                //                         currentOrder = task.ORDER_OF_EXECUTION;
                                //                     }
                                //                 }
                                //                 for(let task of templateTasks){
                                //                     if (task.ORDER_OF_EXECUTION > currentOrder) {
                                //                         upcomingTasks.push(task);
                                //                     }
                                //                 }
                                //                 if (upcomingTasks.length > 0) {
                                //                     min = upcomingTasks[0].ORDER_OF_EXECUTION;
                                //                     for (let task of upcomingTasks) {
                                //                         if (task.ORDER_OF_EXECUTION < min) {
                                //                             min = task.ORDER_OF_EXECUTION
                                //                         }
                                //                     }
                                //                     let usersToNotify = [];
                                //                     let startNextTasks = []
                                //                     for (let task of upcomingTasks) {
                                //                         if (task.ORDER_OF_EXECUTION == min) {
                                //                             usersToNotify.push(task);
                                //                             startNextTasks.push(task.TASK_ID);
                                //                         }
                                //                     }
                                //                     let startAutomatedTasks = await dbOperations.executeQuery(mysqlQueries.startAutomatedTask, ["IP", [startNextTasks]], loggedUser, "automateTasks", false, null, tenant);
                                //                     if (startAutomatedTasks) {
                                //                         // let notifyResponse = await PMSSupport.sendWhatsappNotification(usersToNotify, loggedUser, tenant);
                                //                         // appLogger.logMessage("debug", "Response after sending notification to users: " + JSON.stringify(notifyResponse), className, "completeTask", loggedUser, tenant, moduleName);
                                //                     } else {
                                //                         appLogger.logMessage("debug", "Failed to start next task in queue due to invalid response from the server", className, "completeTask", loggedUser, tenant, moduleName);
                                //                     }
                                //                 } else {
                                //                     appLogger.logMessage("debug", "All tasks have been completed. There is no tasks to start", className, "completeTask", loggedUser, tenant, moduleName);
                                //                 }
                                //             } else {
                                //                 appLogger.logMessage("debug", "There is no order of execution for this project which means it is not an automated project", className, "completeTask", loggedUser, tenant, moduleName);
                                //             }
                                //         } else {
                                //             appLogger.logMessage("debug", "No tasks found to start automatically", className, "completeTask", loggedUser, tenant, moduleName);
                                //         }
                                //     } else {
                                //         appLogger.logMessage("debug", "Failed to start next automated task due to invalid response from server", className, "completeTask", loggedUser, tenant, moduleName);
                                //     }
                                // } else {
                                //     appLogger.logMessage("debug", "Failed to complete  task  assigned . Result received after executing the query: " + JSON.stringify(result), className, "completeTask", loggedUser, tenant, moduleName);
                                //     out.status = "Warning"
                                //     out.message = "Failed to  complete the task"
                                //     out.code = 404
                                // }
                            } else {
                                appLogger.logMessage("debug", "Failed to  complete the task. Result received after executing the query: " + JSON.stringify(result), className, "completeTask", loggedUser, tenant, moduleName);
                                out.status = "Warning"
                                out.message = "Failed to complete the task"
                                out.statusCode = 404
                            }
                        } else {
                            appLogger.logMessage("debug", "Failed to complete task ", className, "completeTask", loggedUser, tenant, moduleName);
                            out.status = "Warning"
                            out.message = "Failed to  complete task"
                            out.statusCode = 404
                        }

                    }

                }
            } else {
                appLogger.logMessage("info", "Failed to complete task due to invalid request body", className, "completeTask", loggedUser, tenant, moduleName);
                out.status = "Warning"
                out.message = "Failed to  complete task due to invalid request body"
                out.statusCode = 404
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "completeTask", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to mark task as completed due to: " + JSON.stringify(error.message), className, "completeTask", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failure"
            out.message = "Internal server error " + error.message
            out.statusCode = 500
        }
        appLogger.logMessage("info", "completeTask is completed ", className, "completeTask", loggedUser, tenant, moduleName);
        return out;
    },

    //get all lookups
    getAllLookups: async function (loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let response;
        try {
            let result = await dbOperations.executeQuery(mysqlQueries.getLookups, [], loggedUser, "getAllLookups", false, null, tenant, appLogger, meteringLogger, moduleName);
            if (result != null && result != undefined && result != "error") {
                if (result.length > 0) {
                    response = await supportHandler.formatLookupData(result, loggedUser, tenant);
                } else {
                    appLogger.logMessage("debug", "No lookups found.", className, "getAllLookups", loggedUser, tenant);
                    response = await responseHandler.sendResponse("Warning", "No lookups found.", 404, null, false, "getAllLookups", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("debug", "Failed to get lookups.", className, "getAllLookups", loggedUser, tenant);
                response = await responseHandler.sendResponse("Warning", "Failed to get lookups.", 404, null, false, "getAllLookups", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "getAllLookups", startDateTime, endDateTime, diffInMS);
        } catch (error) {
            appLogger.logMessage("error", "Failed to get all lookups due to: " + JSON.stringify(error.message), className, "getAllLookups", req.body.email);
            response = await responseHandler.sendResponse("Failure", "Internal server error " + error.message, 404, null, false, "getAllLookups", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return response;
    },


    // complete all tasks
    completeAllTask: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "completeAllTask function called with the payload: " + JSON.stringify(req.body), className, "completeAllTask", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Task completed successfully ",
            statusCode: '200',
            data: []
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.completeAllTask);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to  complete all tasks due to missing parameters: " + JSON.stringify(missingParams), className, "completeAllTask", loggedUser, tenant, moduleName);
                    out.status = "warning"
                    out.message = "Failed to  complete all tasks due to missing parameters: " + JSON.stringify(missingParams)
                    out.statusCode = 404
                } else {
                    let query = mysqlQueries.completeAllTask;
                    let param = [
                        body.tenantId,
                        body.projectId,

                    ];
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "completeAllTask", true, [3], tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result.affectedRows > 0) {
                            appLogger.logMessage("info", "Successfully completed  all tasks ", className, "completeTask", loggedUser, tenant, moduleName);

                            // query = mysqlQueries.closeAllTaskAssigned;
                            // param = [
                            //     body.tenantId,
                            //     body.projectId,
                            // ];
                            // let pos = [3];
                            // let result = await PMSSupport.closeTaskAssigned(query, param, pos, loggedUser, tenant)
                            // if (result) {
                            //     appLogger.logMessage("info", "Successfully completed  all tasks ", className, "completeTask", loggedUser, tenant, moduleName);
                            // } else {
                            //     appLogger.logMessage("debug", "Failed to complete task assigned  . Result received after executing the query: " + JSON.stringify(result), className, "completeTask", loggedUser, tenant, moduleName);
                            //     out.status = "Warning"
                            //     out.message = "Failed to complete all tasks"
                            //     out.statusCode = 404
                            // }
                        } else {
                            appLogger.logMessage("debug", "Failed to  complete all tasks. Result received after executing the query: " + JSON.stringify(result), className, "completeTask", loggedUser, tenant, moduleName);
                            out.status = "Warning"
                            out.message = "Failed to  complete all tasks"
                            out.statusCode = 404
                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to  complete all tasks . Result received after executing the query: " + JSON.stringify(result), className, "completeTask", loggedUser, tenant, moduleName);
                        out.status = "Warning"
                        out.message = "Failed to complete all tasks"
                        out.statusCode = 404
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to  complete all tasks due to invalid request body", className, "completeAllTask", loggedUser, tenant, moduleName);
                out.status = "Warning"
                out.message = "Failed tocomplete all tasks due to invalid request body"
                out.statusCode = 404
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "completeAllTask", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to  complete all tasks due to: " + JSON.stringify(error.message), className, "completeAllTask", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failure"
            out.message = "Internal server error " + error.message
            out.statusCode = 500
        }
        appLogger.logMessage("info", "completeAllTask  is completed ", className, "completeAllTask", loggedUser, tenant, moduleName);
        return out;
    },

    //check  any task is already assigned to the user
    isTaskAssigned: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "isTaskAssigned function called with the payload: " + JSON.stringify(req.body), className, "isTaskAssigned", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "User is not assigned with any task",
            statusCode: '200',
            data: [true]
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.isTaskAssigned);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Missing parameters: " + JSON.stringify(missingParams), className, "completeAllTask", loggedUser, tenant, moduleName);
                    out.status = "warning"
                    out.message = "Missing parameters: " + JSON.stringify(missingParams)
                    out.statusCode = 404
                } else {
                    let query = mysqlQueries.isTaskAssigned;
                    let param = [
                        body.userId,
                        body.taskId,
                        body.projectId,
                        body.tenantId,
                    ];
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "isTaskAssigned", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result.length == 0) {
                            appLogger.logMessage("info", "No task is assigned to the user ", className, "completeTask", loggedUser, tenant, moduleName);

                        } else {
                            appLogger.logMessage("debug", "User is already assigned with task. Result received after executing the query: " + JSON.stringify(result), className, "completeTask", loggedUser, tenant, moduleName);
                            out.message = "User is already assigned with task"
                            out.data = [{ 'assigned': false }]
                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to check assigned task . Result received after executing the query: " + JSON.stringify(result), className, "isTaskAssigned", loggedUser, tenant, moduleName);
                        out.status = "Warning"
                        out.message = "Failed to check assigned task"
                        out.statusCode = 404
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to  check assigned task due to invalid request body", className, "isTaskAssigned", loggedUser, tenant, moduleName);
                out.status = "Warning"
                out.message = "Failed to check assigned task due to invalid request body"
                out.statusCode = 404
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "isTaskassigned", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to check assigned task ", "PMSSupport", "isTaskAssigned", loggedUser);
            out.status = "Failure"
            out.message = "Internal server error " + error.message
            out.statusCode = 500
        }
        appLogger.logMessage("info", "isTaskAssigned is completed", className, "isTaskAssigned", loggedUser, tenant, moduleName);
        return out;
    },

    //ADD TEMPLATE TO MONGODB
    addTemplate: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "addTemplate function called with the payload: " + JSON.stringify(req.body), className, "addTemplate", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Warning",
            message: "Failed to add template",
            statusCode: '200',
            data: []
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.addTemplate);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Missing parameters: " + JSON.stringify(missingParams), className, "completeAllTask", loggedUser, tenant);
                    out.status = "warning"
                    out.message = "Missing parameters: " + JSON.stringify(missingParams)
                    out.statusCode = 404
                } else {
                    let createQuery = { "projectType": body.projectType, "templateName": body.templateName, "description": body.description, "groups": req.body.groups }
                    let result = await mongoOperations.executeMongoInsert(loggedUser, "pmsTemplate", createQuery, "addTemplate", tenant, appLogger, meteringLogger, moduleName);

                    if (result != null && result != undefined) {
                        if (result.insertedId) {
                            out.status = "Success";
                            out.message = "Template is added";
                            out.statusCode = 200;
                            out.data = [{ 'insertedId': result.insertedId }]
                            appLogger.logMessage("debug", "Template  added  successfully. Result received after executing the query: " + JSON.stringify(result), className, "addTemplate", loggedUser, tenant, moduleName);

                        } else {
                            appLogger.logMessage("debug", "Failed to add template. Result received after executing the query: " + JSON.stringify(result), className, "addTemplate", loggedUser, tenant, moduleName);

                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to add template", className, "addTemplate", loggedUser, tenant, moduleName);

                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to  add template due to invalid request body", className, "addTemplate", loggedUser, tenant, moduleName);
                out.status = "Warning"
                out.message = "Failed to add template due to invalid request body"
                out.statusCode = 404
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "addTemplate", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to add template due to " + error.message, "PMSSupport", "addTemplate", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failure"
            out.message = "Internal server error " + error.message
            out.statusCode = 500
        }
        appLogger.logMessage("info", "addTemplate completed", className, "addTemplate", loggedUser, tenant, moduleName);
        return out;
    },

    addProjectOwner: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "addProjectOwner", loggedUser, tenant, moduleName);
        let result;
        try {
            let date = moment().format('YYYY-MM-DD');
            if (data.userId != undefined && data.userId != null && data.projectId != undefined && data.projectId != null && data.mapTenantId != undefined && data.mapTenantId != null) {
                result = await dbOperations.executeQuery(mysqlQueries.checkRoleExists, ['DELEGATED PROJECT MANAGER', data.mapTenantId], loggedUser, "assignProjectOwner", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (result != undefined && result != null && result.length > 0) {
                    result = await dbOperations.executeQuery(mysqlQueries.updateProjectRole, ["OWNER", result[0].ID, data.userId, data.projectId], loggedUser, "updateProjectRole", false, null, tenant, appLogger, meteringLogger, moduleName)
                    if (result != undefined && result != null && result.affectedRows > 0) {
                        let notifyResult = await supportHandler.notifyNewOwner(data.userEmail, data.projectName, data.tenantId, data.loggedUser, data.tenant);

                        result = await responseHandler.sendResponse("Success", "Project owner added successfully.", 200, null, false, "addProjectOwner", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        result = await responseHandler.sendResponse("Warning", "Failed to add proect owner .", 400, null, false, "addProjectOwner", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "addProjectOwner", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addProjectOwner", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "addProjectOwner", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addProjectOwner", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addProjectOwner", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },





    //GET TEMPLATE FROM MONGODB
    getTemplate: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "getTemplate function called with the payload: " + JSON.stringify(req.body), className, "addTemplate", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Warning",
            message: "Failed to get template",
            statusCode: '200',
            data: []
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getTemplate);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Missing parameters: " + JSON.stringify(missingParams), className, "getTemplate", loggedUser, tenant, moduleName);
                    out.status = "warning"
                    out.message = "Missing parameters: " + JSON.stringify(missingParams)
                    out.statusCode = 404
                } else {
                    let result = await mongoOperations.executeMongoGet(loggedUser, "pmsTemplate", null, "getTemplate", tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined) {
                        if (result.length) {
                            if (result.length > 0) {
                                out.status = "Success";
                                out.message = "Template fetched successfully";
                                out.statusCode = 200;
                                let i = 0;
                                let totalTaskLength = 0;
                                for (let template of result) {
                                    let taskCardDisplayData = [];
                                    let levels = [];
                                    if (template.groups) {
                                        for (let group of template.groups) {
                                            totalTaskLength += group.tasks.length;
                                            for (let task of group.tasks) {
                                                if (!levels.includes(task.orderOfExecution)) {
                                                    levels.push(task.orderOfExecution)
                                                }
                                            }
                                            for (let task of group.tasks) {
                                                task["hasSubTasks"] = false;
                                                if (task.subTasks.length > 0) {
                                                    task["hasSubTasks"] = true;
                                                }
                                            }
                                            taskCardDisplayData.push({
                                                groupName: group.groupName,
                                                tasks: group.tasks
                                            })
                                        }
                                        let templateData = {
                                            templateName: template.templateName,
                                            description: template.description,
                                            projectType: template.projectType,
                                            groups: taskCardDisplayData,
                                            totalTasks: totalTaskLength
                                        }

                                        out.data[i] = [];
                                        out.data[i] = templateData;
                                        i++;
                                    }
                                }
                                appLogger.logMessage("info", "Template fetched successdully", className, "getTemplate", loggedUser, tenant, moduleName);
                            } else {
                                out.status = "Warning";
                                out.message = "No Template available";
                                out.statusCode = 404;
                                appLogger.logMessage("debug", "Failed to get template. Result received after executing the query: " + JSON.stringify(result), className, "getTemplate", loggedUser, tenant, moduleName);
                            }
                        } else {
                            appLogger.logMessage("debug", "Failed to get template. Result received after executing the query: " + JSON.stringify(result), className, "getTemplate", loggedUser, tenant, moduleName);
                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to get template", className, "getTemplate", loggedUser, tenant, moduleName);
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to  get template due to invalid request body", className, "getTemplate", loggedUser, tenant, moduleName);
                out.status = "Warning"
                out.message = "Failed to get template due to invalid request body"
                out.statusCode = 404
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "getTemplate", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to get template due to" + error.message, "PMSSupport", "getTemplate", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failure"
            out.message = "Internal server error " + error.message
            out.statusCode = 500
        }
        appLogger.logMessage("info", "getTemplate completed", className, "getTemplate", loggedUser, tenant, moduleName);
        return out;
    },
    getProjectCounts: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("debug", "getProjectCounts called", className, "getProjectCounts", loggedUser, tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully fetched project count",
            data: {},
            statusCode: 200
        }
        try {
            let body = req.body;
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getProjectCounts);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Missing parameters: " + JSON.stringify(missingParams), className, "getProjectCounts", loggedUser, tenant, moduleName);
                out.status = "warning"
                out.message = "Missing parameters: " + JSON.stringify(missingParams)
                out.statusCode = 404
            } else {
                let projectStatusCodes = body.projectStatusCodes;
                if (!Array.isArray(body.projectStatusCodes)) {
                    projectStatusCodes = String(projectStatusCodes).split(',')
                }
                if (Array.isArray(projectStatusCodes)) {
                    if (projectStatusCodes.length > 0) {
                        let queryStr = "SELECT COUNT(*) AS TOTAL,";
                        for (let statusCode of projectStatusCodes) {
                            queryStr += " COUNT(IF(PROJECT_STATUS_TYPE_CODE='" + statusCode + "',1,null)) AS '" + statusCode + "',"
                        }
                        queryStr = String(queryStr).substring(0, String(queryStr).length - 1);
                        if (String(body.role).toLowerCase() == "employee") {
                            queryStr += " FROM gnieprojectmanagement.GPM_PROJECTS GP WHERE GP.TENANT_ID=" + body.tenantId + " AND GP.ID IN " +
                                "(SELECT PROJECT_ID FROM gnieprojectmanagement.GPM_TASKS WHERE ASSIGNED_TO=" + body.loggedUserId + " " +
                                "GROUP BY PROJECT_ID);"
                        } else if (String(body.role).toLowerCase() == "project_manager") {
                            queryStr += " FROM gnieprojectmanagement.GPM_PROJECTS WHERE CREATED_BY = " + body.loggedUserId + " AND TENANT_ID=" + body.tenantId + ";"
                        } else {
                            appLogger.logMessage("error", "Failed to fetch project count due to invalid role given: " + body.role, className, "getProjectCounts", loggedUser, tenant, moduleName);
                            return { status: "Failed", message: "Failed to fetch project count due to invalid role: " + body.role, statusCode: 400 };
                        }
                        appLogger.logMessage("debug", "Query generated for fetching project counts: " + JSON.stringify(queryStr), className, "getProjectCounts", loggedUser, tenant, moduleName);
                        let result = await dbOperations.executeQuery(queryStr, [], loggedUser, "getProjectCounts", false, null, tenant, appLogger, meteringLogger, moduleName);
                        appLogger.logMessage("debug", "Project count data received from the server: " + JSON.stringify(result), className, "getProjectCounts", loggedUser, tenant, moduleName);
                        if (result) {
                            if (result.length > 0) {
                                for (let statusCode of projectStatusCodes) {
                                    out.data["TOTAL"] = result[0].TOTAL;
                                    out.data[statusCode] = result[0][statusCode];
                                }
                                if (Object.keys(out.data).length > 0) {
                                    appLogger.logMessage("debug", "Successfully fetched project counts", className, "getProjectCounts", loggedUser, tenant, moduleName);
                                } else {
                                    appLogger.logMessage("debug", "Failed to process project count data", className, "getProjectCounts", loggedUser, tenant, moduleName);
                                    out.status = "Failed";
                                    out.message = "Failed to process project count information";
                                    out.statusCode = 500
                                }
                            } else {
                                appLogger.logMessage("debug", "No projects found under the given tenant", className, "getProjectCounts", loggedUser, tenant, moduleName);
                                out.status = "Warning";
                                out.message = "No projects found";
                            }
                        } else {
                            appLogger.logMessage("error", "Failed to fetch project counts based on different status due to internal server error", className, "getProjectCounts", loggedUser, tenant, moduleName);
                            out.status = "Failed";
                            out.message = "Internal server error. Please check logs for more details";
                            out.statusCode = 500;
                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to fetch project counts due to no status given. At least one status required", className, "getProjectCounts", loggedUser, tenant, moduleName);
                        out.status = "Failed";
                        out.statusCode = 404;
                        out.message = "Failed to fetch project counts due to no status code given. At least one status is required";
                    }
                } else {
                    appLogger.logMessage("debug", "Failed to fetch project counts due to invalid parameter(projectStatusCodes) received expected an array", className, "getProjectCounts", loggedUser, tenant, moduleName);
                    out.status = "Failed";
                    out.statusCode = 404;
                    out.message = "Invalid parameter(projectStatusCodes). Expected an array";
                }
            }
        } catch (error) {
            out.status = "Failed";
            out.message = "Internal server error";
            out.statusCode = 500;
            out.data = JSON.stringify(error.message);
            appLogger.logMessage("error", "Failed to fetch project counts based on status code due to: " + JSON.stringify(error.message), className, "getProjectCounts", loggedUser, tenant, moduleName);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(tenant, loggedUser, className, "getProjectCounts", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },

    getProjectsByStatus: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("debug", "getProjectsByStatus called", className, "getProjectsByStatus", loggedUser, tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully fetched project count",
            data: {},
            statusCode: 200
        }
        try {
            let body = req.body;
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getProjectsByStatus);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Missing parameters: " + JSON.stringify(missingParams), className, "getProjectsByStatus", loggedUser, tenant, moduleName);
                out.status = "warning"
                out.message = "Missing parameters: " + JSON.stringify(missingParams)
                out.statusCode = 404
            } else {
                let query;
                let projectStatusCode = body.projectStatusCode;
                let param = [body.tenantId, projectStatusCode, body.loggedUserId];
                if (String(body.role).toLowerCase() == "project_manager") {
                    query = mysqlQueries.getProjectsByStatusManager;
                } else if (String(body.role).toLowerCase() == "employee") {
                    param = [body.tenantId, projectStatusCode, body.loggedUserId];
                    query = mysqlQueries.getProjectsByStatusEmp;
                } else {
                    return out = { status: "Failed", message: "Invalid role given to fetch projects by status. The given Role: " + body.role, statusCode: 400 };
                }
                let result = await dbOperations.executeQuery(query, param, loggedUser, "getProjectsByStatus", false, null, tenant, appLogger, meteringLogger, moduleName);
                appLogger.logMessage("debug", "Data recieved after fetching projects by status: " + JSON.stringify(result), className, "getProjectsByStatus", loggedUser, tenant, moduleName);
                if (result) {
                    out.data = result;
                } else {
                    appLogger.logMessage("debug", "Failed to fetch projects due to internal server error", className, "getProjectsByStatus", loggedUser, tenant, moduleName);
                    out.status = "Failed";
                    out.statusCode = 500;
                    out.message = "Invalid data received from the server";
                }

            }
            if (out.data.length > 0) {
                for (let project of out.data) {
                    await this.getProjectTeam(project, project.ID, loggedUser, tenant);
                    await this.populateTeamImage(project, req.body.tenantType, loggedUser, tenant);
                }
            }
        } catch (error) {
            out.status = "Failed";
            out.message = "Internal server error";
            out.statusCode = 500;
            out.data = JSON.stringify(error.message);
            appLogger.logMessage("error", "Failed to fetch project based on status code due to: " + JSON.stringify(error.message), className, "getProjectsByStatus", loggedUser, tenant, moduleName);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(tenant, loggedUser, className, "getProjectsByStatus", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },
    getProjectTeam: async function (projectData, projectId, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("debug", "getProjectTeam called", className, "getProjectTeam", loggedUser, tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully fetched project team",
            data: {},
            statusCode: 200
        }
        try {
            let param = [projectId, projectId];
            let query = mysqlQueries.getProjectTeam;
            let result = await dbOperations.executeQuery(query, param, loggedUser, "getProjectTeam", false, null, tenant, appLogger, meteringLogger, moduleName);
            if (result) {
                if (Array.isArray(result)) {
                    projectData["TEAM_DATA"] = result;
                } else {
                    appLogger.logMessage("error", "Invalid data received from server: " + JSON.stringify(result), className, "getProjectTeam", loggedUser, tenant, moduleName);
                    out.status = "Failed";
                    out.message = "Failed to fetch team details due to invalid data received from the server";
                    out.data = JSON.stringify(result);

                }
            } else {
                appLogger.logMessage("error", "Failed to fetch team details", className, "getProjectTeam", loggedUser, tenant, moduleName);
                out.status = "Failed";
                out.message = "Failed to fetch team details";
                out.statusCode = 500;
            }
        } catch (error) {
            appLogger.logMessage("error", "Error while fetching team details: " + JSON.stringify(error.message), className, "getProjectTeam", loggedUser, tenant, moduleName);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
            out.statusCode = 500;
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(tenant, loggedUser, className, "getProjectTeam", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },
    populateTeamImage: async function (project, tenantType, loggedUser, tenant) {
        appLogger.logMessage("info", "populateTeamImage function called", className, "populateTeamImage", loggedUser, tenant, moduleName);
        try {
            startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            let image;
            if (project["TEAM_DATA"] && project["TEAM_DATA"].length > 0) {
                for (let member of project["TEAM_DATA"]) {
                    let key = String(tenant).toUpperCase() + "_" + member.EMPLOYEE_NUMBER;
                    image = await ImageHandler.fetchPhoto(tenantType, key, member.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                    member["IMAGE"] = image || null;
                    image = null;
                }
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "populateTeamImage", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (e) {
            appLogger.logMessage("error", "Failed to populate image due to: " + JSON.stringify(e.message), className, "populateTeamImage", loggedUser, tenant, moduleName);
        }
    },

   
//FETCH TASK LIST SHOWN INSIDE THE PROJECT						
getTasksList: async function (req, loggedUser, tenant) {
    startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
    appLogger.logMessage("debug", "getTasksList called", className, "getTasksList", loggedUser, tenant, moduleName);
    let out = {
        status: "Success",
        message: "Successfully fetched tasks",
        data: {},
        statusCode: 200
    }
    try {
        let body = req.body;
        let requestParams = Object.keys(body);
        let missingParams = [];
        let signatureKeys = Object.keys(apiSignatures.getTasksList);
        for (let key of signatureKeys) {
            if (!requestParams.includes(key)) {
                missingParams.push(key);
            }
        }
        if (missingParams.length > 0) {
            appLogger.logMessage("debug", "Missing parameters: " + JSON.stringify(missingParams), className, "getTasksList", loggedUser, tenant, moduleName);
            out.status = "warning"
            out.message = "Missing parameters: " + JSON.stringify(missingParams)
            out.statusCode = 404
        } else {
            let query;
            let param = [];
            if (String(body.role).toLowerCase() == "project_manager") {
                param = [body.tenantId, body.projectId, ["COM", "IP", "NS", "OPEN", "HOLD"]];
                query = mysqlQueries.getTaskList;
            } else if (String(body.role).toLowerCase() == "employee") {
                param = [body.tenantId, body.projectId, body.loggedUserId, ["COM", "IP", "NS", "OPEN", "HOLD"]];
                query = mysqlQueries.getTaskListEmp;
            }
            else {
                appLogger.logMessage("debug", "Failed to fetch task list due to invalid role given: " + body.role, className, "getTaskList", loggedUser, tenant, moduleName);
                out.status = "Warning";
                out.data = {};
                out.message = "Invalid role received. Expected roles are [employee or project_manager]";
                return out;
            }
            let result = await dbOperations.executeQuery(query, param, loggedUser, "getTasksList", false, null, tenant, appLogger, meteringLogger, moduleName);
            // let taskIds = result.filter( x => x.HAS_SUB_TASK == "true").map(x => x.ID)
            // for(id of taskIds){
            //     let subResult = await dbOperations.executeQuery(mysqlQueries.getSubTasks, [id, body.tenantId], loggedUser, "getSubTasksList", false, null, tenant,appLogger,meteringLogger,moduleName);
            //     subResult = subResult.map(({SUB_TASK_NAME : TASK_NAME,ESTIMATED_COMPLETION_DATE:DUE_DATE, ...rest }) => ({ TASK_NAME,DUE_DATE, ...rest }));
            //     result = result.concat(subResult)
            // }
            appLogger.logMessage("debug", "Data recieved after fetching tasks by status: " + JSON.stringify(result), className, "getTasksList", loggedUser, tenant, moduleName);
            if (result) {
                let completedTasks = [];
                let inProgressTasks = [];
                let notStartedTasks = [];
                let openTasks = [];
                let onHoldTask = [];
                let awaitingApprovalTask=[];
                let rejectedTask=[];
                let countIP = 0
                let countOpen = 0
                let countNS = 0
                let countHOLD = 0
                let countCOM = 0
                let countAwaitingApproval=0
                let countRejected=0
                for (let row of result) {
                    let image = null;
                    let dueDate = moment(row.DUE_DATE).format("YYYY-MM-DD");
                    let currentDate = moment().format("YYYY-MM-DD");
                    let diff = moment(currentDate).diff(moment(dueDate), 'days');
                    row["DUE_IN"] = diff;
                    if (row.EMPLOYEE_NUMBER != null && row.EMPLOYEE_NUMBER != undefined) {
                        let key = String(req.body.tenant).toUpperCase() + "_" + row.EMPLOYEE_NUMBER;
                        image = await ImageHandler.fetchPhoto(req.body.tenantType, key, row.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                        row["IMAGE"] = image || null;
                    } else {
                        row["IMAGE"] = null;
                    }
                    if (row.TASK_STATUS_TYPE_CODE == "IP") {
                        inProgressTasks.push(row);
                    } else if(row.TASK_STATUS_TYPE_CODE == "COM" && String(row.APPROVAL_REQUIRED).toUpperCase()=='N'){
                        completedTasks.push(row);

                    }else if (row.TASK_STATUS_TYPE_CODE == "COM" && String(row.APPROVAL_REQUIRED).toUpperCase()=='Y') {
                        if(String(row.SUB_STATUS).toUpperCase()=='APPROVED'){
                            completedTasks.push(row)
                        }else if(String(row.SUB_STATUS).toUpperCase()=='REJECTED'){
                            rejectedTask.push(row)
                        }else if(String(row.SUB_STATUS).toUpperCase()=='AWAITING APPROVAL'){
                            awaitingApprovalTask.push(row)
                        }
                    }else if (row.TASK_STATUS_TYPE_CODE == "NS") {
                        notStartedTasks.push(row);
                    } else if (row.TASK_STATUS_TYPE_CODE == "OPEN") {
                        openTasks.push(row);
                    } else if (row.TASK_STATUS_TYPE_CODE == "HOLD") {
                        onHoldTask.push(row);
                    }

                }
                countIP = inProgressTasks.length
                countOpen = openTasks.length
                countNS = notStartedTasks.length
                countHOLD = onHoldTask.length
                countCOM = completedTasks.length
                countAwaitingApproval=awaitingApprovalTask.length
                countRejected=rejectedTask.length
                
                if (awaitingApprovalTask.length > 3) {
                    awaitingApprovalTask = awaitingApprovalTask.splice(0, 3)
                }
                if (countRejected.length > 3) {
                    countRejected = countRejected.splice(0, 3)
                }
                if (inProgressTasks.length > 3) {
                    inProgressTasks = inProgressTasks.splice(0, 3)
                }
                if (notStartedTasks.length > 3) {
                    notStartedTasks = notStartedTasks.splice(0, 3)
                }
                if (openTasks.length > 3) {
                    openTasks = openTasks.splice(0, 3)
                }
                if (onHoldTask.length > 3) {
                    onHoldTask = onHoldTask.splice(0, 3)
                }
                if (completedTasks.length > 3) {
                    completedTasks = completedTasks.splice(0, 3)
                }
                // inProgressTasks.sort((a, b) => {
                //     return b.DUE_IN - a.DUE_IN;
                // });
                // notStartedTasks.sort((a, b) => {
                //     return b.DUE_IN - a.DUE_IN;
                // });
                // openTasks.sort((a, b) => {
                //     return b.DUE_IN - a.DUE_IN;
                // });
                // onHoldTask.sort((a, b) => {
                //     return b.DUE_IN - a.DUE_IN;
                // });
                out.data["COM"] = completedTasks;
                out.data["IP"] = inProgressTasks;
                out.data["NS"] = notStartedTasks;
                out.data["OPEN"] = openTasks;
                out.data["HOLD"] = onHoldTask;
                out.data['AWAITING_APPROVAL']=awaitingApprovalTask
                out.data['REJECTED']=rejectedTask
                // count of tasks in all  status 
                out.data["COM_COUNT"] = countCOM;
                out.data["IP_COUNT"] = countIP;
                out.data["OPEN_COUNT"] = countOpen;
                out.data["HOLD_COUNT"] = countHOLD;
                out.data["NS_COUNT"] = countNS;
                out.data["AWAITING_APPROVAL_COUNT"] =countAwaitingApproval
                out.data["REJECTED_COUNT"] =countRejected

            } else {
                appLogger.logMessage("debug", "Failed to fetch tasks due to internal server error", className, "getTasksList", loggedUser, tenant, moduleName);
                out.status = "Failed";
                out.statusCode = 500;
                out.message = "Invalid data received from the server";
            }
        }
    } catch (error) {
        out.status = "Failed";
        out.message = "Internal server error";
        out.statusCode = 500;
        out.data = JSON.stringify(error.message);
        appLogger.logMessage("error", "Failed to fetch tasks based on status code due to: " + JSON.stringify(error.message), className, "getTasksList", loggedUser, tenant, moduleName);
    }
    endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
    diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
    meteringLogger.logMessage(tenant, loggedUser, className, "getTasksList", startDateTime, endDateTime, diffInMS, moduleName);
    return out;
    },
    sendNotification: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        let body = req.body;
        let out = {
            "status": "Success",
            "message": "Successfully send notification"
        }
        try {
            appLogger.logMessage("debug", "sendNotification function started with payload" + JSON.stringify(body), className, "sendNotification", body.loggedUser, body.tenant, moduleName);
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.sendNotification);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to  send notification due to missing parameters: " + JSON.stringify(missingParams), className, "sendNotification", body.loggedUser, body.tenant, moduleName);
                out.status = "Warning";
                out.message = "Failed to send notification  due to missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 404;
            } else {
                let query = mysqlQueries.sendNotification;
                let param = [
                    body.sendFrom,
                    body.sendTo,
                    body.message,
                    body.unitId,
                    body.unitType,
                    body.tenantId, startDateTime,
                    startDateTime

                ]

                result = await dbOperations.executeQuery(query, param, loggedUser, "sendNotification", true, [6, 7], tenant, appLogger, meteringLogger, moduleName);
                if (result != undefined && result != null && result != 'Error') {
                    if (result.affectedRows > 0) {
                        appLogger.logMessage("debug", "Notification sent successfully", className, "sendNotification", body.loggedUser, body.tenant, moduleName);
                        out.status = "Success";
                        out.message = "Notification sent successfully";
                        out.statusCode = 200;
                    } else {
                        appLogger.logMessage("debug", "Failed to send  notification due to " + JSON.stringify(result), className, "sendNotification", body.loggedUser, body.tenant, moduleName);
                        out.status = "Warning";
                        out.message = "Failed to send  notification due to " + JSON.stringify(result);
                        out.statusCode = 404;
                    }
                } else {
                    appLogger.logMessage("debug", "Failed to send  notification due to " + JSON.stringify(result), className, "sendNotification", body.loggedUser, body.tenant, moduleName);
                    out.status = "Warning";
                    out.message = " Failed to send notification due to invalid response from the server";
                    out.statusCode = 404;
                }
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, className, "sendNotification", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, className, "sendNotification", body.loggedUser, body.tenant, moduleName);
            out.status = "Failure";
            out.message = " Internal server error" + e.message;
            out.statusCode = 500;
        }
        appLogger.logMessage("info", "sendNotification is finished and the result is returnd ", className, "sendNotification", body.loggedUser, body.tenant, moduleName);
        return out;
    },
    // GET NOTIFICATION
    getNotification: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        let body = req.body;
        let out = {
            status: "Success",
            message: "Successfully fetched notifications"
        }
        try {
            appLogger.logMessage("debug", "getNotification function started with payload" + JSON.stringify(body), className, "getNotification", body.loggedUser, body.tenant, moduleName);
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getNotification);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to  get notification due to missing parameters: " + JSON.stringify(missingParams), className, "getNotification", body.loggedUser, body.tenant, moduleName);
                out.status = "Warning";
                out.message = "Failed to get notification  due to missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 404;
            } else {
                let query = mysqlQueries.getNotification;
                let param = [
                    body.userId,
                    body.tenantId
                ]
                result = await dbOperations.executeQuery(query, param, loggedUser, "getNotification", true, [4, 5], tenant, appLogger, meteringLogger, moduleName);
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("debug", "Notification fetched  successfully", className, "getNotification", body.loggedUser, body.tenant, moduleName);
                        out.status = "Success";
                        out.message = "Notifications fetched successfully";
                        out.statusCode = 200;
                        out.data = result
                    } else {
                        appLogger.logMessage("debug", "Failed to fetch  notification due to " + JSON.stringify(result), className, "getNotification", body.loggedUser, body.tenant, moduleName);
                        out.status = "Warning"
                        out.message = " Notifications fetched successfully"
                        out.statusCode = 404
                    }
                } else {
                    appLogger.logMessage("debug", "Failed to fetch  notification due to " + JSON.stringify(result), className, "getNotification", body.loggedUser, body.tenant, moduleName);
                    out.status = "Warning"
                    out.message = " Notifications fetched successfully"
                    out.statusCode = 404
                }
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, className, "getNotification", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, className, "getNotification", body.loggedUser, body.tenant, moduleName);
            out.status = "Failure"
            out.message = " Internal server error" + e.message
            out.statusCode = 500
        }
        appLogger.logMessage("info", "getNotification is finished and the result is returnd ", className, "getNotification", body.loggedUser, body.tenant, moduleName);
        return out;
    },
    getRiskTasks: async function (req, loggedUser, tenant) {
        return new Promise(async function (resolve, reject) {
            startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            let body = req.body;
            let output = {
                status: "Success",
                message: "Successfully fetched expired tasks",
                data: [],
                statusCode: 200
            }
            try {
                appLogger.logMessage("debug", "getRiskTasks function started with payload" + JSON.stringify(body), className, "getRiskTasks", body.loggedUser, body.tenant, moduleName);
                let requestParams = Object.keys(req.body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getRiskTasks);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to  get RiskTasks due to missing parameters: " + JSON.stringify(missingParams), className, "getRiskTasks", body.loggedUser, body.tenant, moduleName);
                    output.status = "Warning";
                    output.message = "Failed to get RiskTasks  due to missing parameters: " + JSON.stringify(missingParams);
                    output.statusCode = 404;
                } else {
                    let payload = {
                        loggedUser: req.body.loggedUser,
                        tenant: req.body.tenant,
                        tenantId: req.body.tenantId,
                        loggedUserId: req.body.loggedUserId,
                        projectId: req.body.projectId,
                        role: req.body.role
                    }
                    let expiredTasks = await PMSSupport.getTasksDueExpired(payload);
                    if (String(expiredTasks.status).toLowerCase() == "success") {
                        for (let task of expiredTasks.data) {
                            let image = null;
                            let dueDate = moment(task.DUE_DATE).format("YYYY-MM-DD");
                            let currentDate = moment().format("YYYY-MM-DD");
                            let diff = moment(currentDate).diff(moment(dueDate), 'days');
                            task["DUE_IN"] = diff;
                            if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                                let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                                image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                task["IMAGE"] = image || null;
                            } else {
                                task["IMAGE"] = null;
                            }
                            task["LEVEL"] = 1;
                            output.data.push(task);
                        }

                    }
                    let todayExpiringTasks = await PMSSupport.getTasksDueToday(payload);
                    if (String(todayExpiringTasks.status).toLowerCase() == "success") {
                        for (let task of todayExpiringTasks.data) {
                            let image = null;
                            if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                                let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                                image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                task["IMAGE"] = image || null;
                            } else {
                                task["IMAGE"] = null;
                            }
                            task["LEVEL"] = 2;
                            if (!output.data.includes(task)) {
                                output.data.push(task);
                            }
                        }
                        // output.data["expiringToday"] = todayExpiringTasks.data;
                    }

                    let expiringSoon = await PMSSupport.getTasksDueIsUpcoming(payload);
                    if (String(expiringSoon.status).toLowerCase() == "success") {
                        for (let task of expiringSoon.data) {
                            let image = null;
                            let dueDate = moment(task.DUE_DATE).format("YYYY-MM-DD");
                            let currentDate = moment().format("YYYY-MM-DD");
                            let diff = moment(dueDate).diff(moment(currentDate), 'days');
                            task["DUE_IN"] = diff;
                            if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                                let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                                image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                task["IMAGE"] = image || null;
                            } else {
                                task["IMAGE"] = null;
                            }
                            task["LEVEL"] = 3;
                            if (!output.data.includes(task)) {
                                output.data.push(task);
                            }
                        }
                        // output.data["expiringSoon"] = expiringSoon.data;
                    }


                    let exeedingEfforts = await PMSSupport.getTasksExeedsEffort(payload);
                    if (String(exeedingEfforts.status).toLowerCase() == "success") {
                        for (let task of exeedingEfforts.data) {
                            let image = null;
                            if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                                let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                                image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                task["IMAGE"] = image || null;
                            } else {
                                task["IMAGE"] = null;
                            }
                            task["LEVEL"] = 4;
                            if (!output.data.includes(task)) {
                                output.data.push(task);
                            }
                        }
                        // output.data["exeedingEfforts"] = exeedingEfforts.data;
                    }


                    // let taskNotStarted = await PMSSupport.getTasksNotStarted(payload);
                    // if (String(taskNotStarted.status).toLowerCase() == "success") {
                    //     for (let task of taskNotStarted.data) {
                    //         let image = null;
                    //         if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                    //             let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                    //             image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant,appLogger,meteringLogger,moduleName);
                    //             task["IMAGE"] = image || null;
                    //         } else {
                    //             task["IMAGE"] = null;
                    //         }
                    //         task["LEVEL"] = 5;
                    //         if (!output.data.includes(task)) {
                    //             output.data.push(task);
                    //         }
                    //     }
                    //     // output.data["exeedingEfforts"] = exeedingEfforts.data;
                    // }
                }
                endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
                diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
                meteringLogger.logMessage(tenant, loggedUser, className, "getRiskTasks", startDateTime, endDateTime, diffInMS, moduleName);
            } catch (e) {
                appLogger.logMessage("error", e.message, className, "getRiskTasks", body.loggedUser, body.tenant, moduleName);
                output.status = "Failure"
                output.message = " Internal server error" + e.message
                output.statusCode = 500
            }
            appLogger.logMessage("info", "getRiskTasks is finished and the result is returnd ", className, "getRiskTasks", body.loggedUser, body.tenant, moduleName);
            resolve(output);
        })
    },
    getRiskProjects: async function (req, loggedUser, tenant) {
        return new Promise(async function (resolve, reject) {
            startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            let body = req.body;
            let output = {
                status: "Success",
                message: "Successfully fetched expired projects",
                data: [],
                statusCode: 200
            }
            try {
                appLogger.logMessage("debug", "getRiskProjects function started with payload" + JSON.stringify(body), className, "getRiskProjects", body.loggedUser, body.tenant, moduleName);
                let requestParams = Object.keys(req.body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getRiskProjects);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to  get getRiskProjects due to missing parameters: " + JSON.stringify(missingParams), className, "getRiskProjects", body.loggedUser, body.tenant, moduleName);
                    output.status = "Warning";
                    output.message = "Failed to get getRiskProjects  due to missing parameters: " + JSON.stringify(missingParams);
                    output.statusCode = 404;
                } else {
                    let payload = {
                        loggedUser: req.body.loggedUser,
                        tenant: req.body.tenant,
                        tenantId: req.body.tenantId,
                        loggedUserId: req.body.loggedUserId,
                        role: req.body.role
                    }
                    let expiredProjects = await PMSSupport.getProjectsDueExpired(payload);
                    if (String(expiredProjects.status).toLowerCase() == "success") {
                        for (let project of expiredProjects.data) {

                            project["LEVEL"] = 1;
                            output.data.push(project);
                        }

                    }
                    let todayExpiringProjects = await PMSSupport.getProjectsDueToday(payload);
                    if (String(todayExpiringProjects.status).toLowerCase() == "success") {
                        for (let project of todayExpiringProjects.data) {

                            project["LEVEL"] = 2;
                            output.data.push(project);
                        }
                        // output.data["expiringToday"] = todayExpiringTasks.data;
                    }

                    let expiringSoon = await PMSSupport.getProjectsDueIsUpcoming(payload);
                    if (String(expiringSoon.status).toLowerCase() == "success") {
                        for (let project of expiringSoon.data) {
                            let image = null;

                            project["LEVEL"] = 3;
                            output.data.push(project);
                        }
                        // output.data["expiringSoon"] = expiringSoon.data;
                    }
                    let projectNotStarted = await PMSSupport.getProjectsNotStarted(payload);
                    if (String(projectNotStarted.status).toLowerCase() == "success") {
                        for (let project of projectNotStarted.data) {

                            project["LEVEL"] = 4;
                            output.data.push(project);
                        }
                        // output.data["exeedingEfforts"] = exeedingEfforts.data;
                    }
                }
                endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
                diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
                meteringLogger.logMessage(tenant, loggedUser, className, "getRiskProjects", startDateTime, endDateTime, diffInMS, moduleName);
            } catch (e) {
                appLogger.logMessage("error", e.message, className, "getRiskProjects", body.loggedUser, body.tenant, moduleName);
                output.status = "Failure"
                output.message = " Internal server error" + e.message
                output.statusCode = 500
            }
            appLogger.logMessage("info", "getRiskProjects is finished and the result is returnd ", className, "getRiskProjects", body.loggedUser, body.tenant, moduleName);
            resolve(output);
        })
    },

    // submit time from project management
    logWork: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result,maxHoursPerDay = 12,setWarningAt = 9;
        let body = req.body;
        let out = {
            status: "Success",
            message: "Logged the work successfully",
            data: {}
        }
        try {
            appLogger.logMessage("debug", "logWork function started with payload" + JSON.stringify(body), className, "logWork", body.loggedUser, body.tenant, moduleName);
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.logWork);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to log work due to missing parameters: " + JSON.stringify(missingParams), className, "logWork", body.loggedUser, body.tenant, moduleName);
                out.status = "Warning";
                out.message = "Failed to log work due to missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 404;
            } else {
                
                //check whether time submitted for the day has reached the limit
                let query = mysqlQueries.getTotalHours;
                let param = [
                    body.loggedUserId,
                    body.logDate,
                    body.tenantId
                ]
                let configData = await dbOperations.executeQuery(mysqlQueries.getConfigDetails, [body.tenantId], loggedUser, "getLoggedUserDetails", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (configData != null && configData != undefined && configData != 'Error') {
                    if (configData.length > 0) {
                        for (let data of configData) {
                            if (data.ATTRIBUTE_TYPE == 'MAX_HOURS') {
                                maxHoursPerDay = parseInt(data.ATTRIBUTE_VALUE);
                            }else if(data.ATTRIBUTE_TYPE == 'MIN_HOURS'){
                                setWarningAt = parseInt(data.ATTRIBUTE_VALUE);
                            }
                        }
                    } else {
                        maxHoursPerDay = 12
                        setWarningAt = 9
                    }
                }
                result = await dbOperations.executeQuery(query, param, loggedUser, "logWork", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (result != undefined && result != null && result != 'Error') {
                    let totalHoursOfDay = 0;
                    if (result.length > 0) {
                        totalHoursOfDay = result[0].TOTAL_HOURS;
                    }
                    if (totalHoursOfDay == maxHoursPerDay) {
                        appLogger.logMessage("debug", "Daily hours limit reached.", className, "logWork", body.loggedUser, body.tenant, moduleName);
                        out.status = "Failed";
                        out.message = "Daily hour limit has reached. Please update the hours if you want to continue.";
                        out.statusCode = 200;
                    } else if (totalHoursOfDay < maxHoursPerDay) {
                        let newSum = totalHoursOfDay + Number(body.hours);
                        if (newSum > maxHoursPerDay) {
                            appLogger.logMessage("debug", "Cannot log the work due to the daily hour limit exceeded.", className, "logWork", body.loggedUser, body.tenant, moduleName);
                            out.status = "Failed";
                            out.message = "Cannot log the work due to daily hour limit exceeded. The maximum hours you can log work is: " + maxHoursPerDay;
                            out.statusCode = 200;
                        } else {
                            let query = mysqlQueries.logWorkQuery;
                            let param = [
                                body.taskId,
                                body.tenantId,
                                body.logDate,
                                body.comments,
                                body.hours,
                                'ACTIVE',
                                body.billableFlag
                            ]
                            let addWork = await dbOperations.executeQuery(query, param, loggedUser, "logWork", true, [3, 9, 10], tenant, appLogger, meteringLogger, moduleName);
                            if (addWork) {
                                if (addWork.affectedRows > 0) {
                                    out.data = { workLogId: addWork.insertId };
                                    let updateResult = await supportHandler.updateActualEffort(body.taskId, body.tenantId, body.loggedUserId, body.loggedUser, body.tenant)
                                    if (updateResult) {
                                        if (newSum > setWarningAt) {
                                            out.status = "Success",
                                            out.message = "Successfully logged the work,but it seems you have exceeded the daily work hours.",
                                            appLogger.logMessage("debug", "Successfully logged the work,but it seems you have exceeded the daily work hours.", className, "logWork", loggedUser, tenant, moduleName);
                                        } else {
                                            out.status = "Success",
                                            out.message = "Successfully logged the work",
                                            appLogger.logMessage("debug", "Successfully logged the work.", className, "logWork", loggedUser, tenant, moduleName);
                                        }
                                        if(body.type=='SUB'){
                                            //update the main task effort
                                            let res=await supportHandler.updateMainTaskEffort(body,body.loggedUser,body.tenant)
                                            if(res.type!='Success'){
                                                appLogger.logMessage("info", "", className, "logWork", loggedUser, tenant, moduleName);
                                                out.status = "Warning";
                                                out.message = "Failed to update effort of the main task."
                        
                                            }
                                        }
                                        // if task added to watch list , notify watch list users on assigning 
                                        //body['addedToWatchList']=true
                                        if(body.addedToWatchList=='true'){
                                            let nofifyResult=await supportHandler.watchListNotification(body,'work_log',body.loggedUser,body.tenant)
                                            appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                                        }

                                    } else {
                                        appLogger.logMessage("info", "Failed to update actual effort of the task", className, "logWork", loggedUser, tenant, moduleName);
                                        out.status = "Warning"
                                        out.statusCode = 400

                                    }

                                } else {
                                    appLogger.logMessage("debug", "Failed to add work due to invalid response from the server", className, "logWork", loggedUser, tenant, moduleName);
                                    out.status = "Failed";
                                    out.message = "Failed to log work due to internal server error";
                                }
                            } else {
                                appLogger.logMessage("error", "Failed to add work due to invalid response from the server", className, "logWork", loggedUser, tenant, moduleName);
                                out.status = "Failed";
                                out.message = "Failed to log work due to internal server error";
                            }
                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to add work log due to the allowed limit has already reched", className, "logWork", loggedUser, tenant, moduleName);
                        out.status = "Failed";
                        out.message = "Log work failed due to the allowed hours limit has already reached."
                    }
                } else {
                    appLogger.logMessage("debug", "Failed to log work due to " + JSON.stringify(result), className, "logWork", body.loggedUser, body.tenant, moduleName);
                    out.status = "Warning"
                    out.message = " Failed to log work due to internal server error"
                    out.statusCode = 404
                }
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, className, "logWork", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, className, "logWork", body.loggedUser, body.tenant, moduleName);
            out.status = "Failure"
            out.message = " Internal server error" + e.message
            out.statusCode = 500
        }
        appLogger.logMessage("info", "logWork is finished and the result is returnd ", className, "logWork", body.loggedUser, body.tenant, moduleName);
        return out;
    },

    // update the working hours  of task in a day
   updateLogWork: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result,maxHoursPerDay = 12,setWarningAt = 9;;
        let body = req.body;
        let out = {
            "status": "Success",
            "message": "Worklog updated successfully"
        }
        try {
            appLogger.logMessage("debug", "updateLogWork function started with payload" + JSON.stringify(body), className, "updateLogWork", body.loggedUser, body.tenant, moduleName);
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.updateLogWork);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to  update  time due to missing parameters: " + JSON.stringify(missingParams), className, "updateLogWork", body.loggedUser, body.tenant, moduleName);
                out.status = "Warning";
                out.message = "Failed to update time due to missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 404;
            } else {
                let configData = await dbOperations.executeQuery(mysqlQueries.getConfigDetails, [body.tenantId], loggedUser, "getLoggedUserDetails", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (configData != null && configData != undefined && configData != 'Error') {
                    if (configData.length > 0) {
                        for (let data of configData) {
                            if (data.ATTRIBUTE_TYPE == 'MAX_HOURS') {
                                maxHoursPerDay = parseInt(data.ATTRIBUTE_VALUE);
                            }else if(data.ATTRIBUTE_TYPE == 'MIN_HOURS'){
                                setWarningAt = parseInt(data.ATTRIBUTE_VALUE);
                            }
                        }
                    } else {
                        maxHoursPerDay = 12
                        setWarningAt = 9
                    }
                }
                
                let query = mysqlQueries.getHourDetails;
                let param = [
                    body.workLogId,
                    body.logDate
                ]
                let result = await dbOperations.executeQuery(query, param, loggedUser, "updateWorkLog", true, [3], tenant, appLogger, meteringLogger, moduleName);
                if (result) {
                    if (result.length > 0) {
                        let totalHours = result[0].TOTAL_HOURS;
                        let currentHour = result[0].CURRENT_HOUR;
                        totalHours = totalHours - currentHour;
                        let total = totalHours + Number(body.hours);
                        if (total > maxHoursPerDay) {
                            appLogger.logMessage("debug", "Failed to update workLog due to the allowed hours limit exceeded", className, "updateWorkLog", loggedUser, tenant, moduleName);
                            out.status = "Warning";
                            out.message = "Failed to update work log due to the allowed hours limit per day exceeded."
                        } else {
                            query = mysqlQueries.updateLogWork;
                            param = [body.hours, body.comments, body.logDate, body.workLogId];
                            result = await dbOperations.executeQuery(query, param, loggedUser, "updateWorkLog", false, null, tenant, appLogger, meteringLogger, moduleName);
                            if (result) {
                                if (result.affectedRows > 0) {
                                    if(total>setWarningAt){
                                        out.status =  "Success",
                                        out.message = "Work log updated successfully,but it seems you have exceeded the daily work hours."
                                    }
                                    let updateResult = await supportHandler.updateActualEffort(body.taskId, body.tenantId, body.loggedUserId, body.loggedUser, body.tenant)
                                    if(!updateResult){
                                        appLogger.logMessage("info", "Failed to update work log", className, "updateWorklog", loggedUser, tenant, moduleName);
                                        out.status = "Failed";
                                        out.message = "Failed to update work log" ;
                                        out.statusCode=404
                                    
                                    }else{
                                        if(body.type=='SUB'){
                                            //update the main task effort
                                            let res=await supportHandler.updateMainTaskEffort(body,body.loggedUser,body.tenant)
                                            if(res.type!='Success'){
                                                appLogger.logMessage("info", "", className, "updatelogWork", loggedUser, tenant, moduleName);
                                                out.status = "Warning";
                                                out.message = "Failed to update effort of the main task."
                        
                                            }
                                        }
                                    }

                                    //if task added to watch list , notify watch list users on assigning 
                                    if(body.addedToWatchList=='true'){
                                        let nofifyResult=await supportHandler.watchListNotification(body,'work_log_edit',body.loggedUser,body.tenant)
                                        appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                                    }
                                    appLogger.logMessage("debug", "Successfully updated worklog", className, "updateWorklog", loggedUser, tenant, moduleName);
                                } else {
                                    appLogger.logMessage("debug", "Failed to update work log due to no work log found with the given id: " + body.workLogId, className, "updateWorkLog", loggedUser, tenant, moduleName);
                                    out.status = "Failed";
                                    out.message = "Failed to update work log due to invalid workLogId: " + body.workLogId;
                                }
                            } else {
                                appLogger.logMessage("debug", "Failed to update work log due to invalid server response", className, "updateWorkLog", loggedUser, tenant, moduleName);
                                out.status = "Failed";
                                out.message = "Failed to udpate work log due invalid response from the server";
                            }
                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to update work log due to no worklog found for the given day: " + body.logDate, className, "updateWorkLog", loggedUser, tenant, moduleName);
                        out.status = "Failed";
                        out.message = "Failed to update work log due to no worklog found for the given day: " + body.logDate;
                    }
                } else {
                    appLogger.logMessage("debug", "Failed to update work log due to invalid response from the server", className, "updateWorkLog", loggedUser, tenant, moduleName);
                    out.status = "Failed";
                    out.message = "Failed to update work log due to invalid response from the server";
                }

            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, className, "updateLogWork", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, className, "updateLogWork", body.loggedUser, body.tenant, moduleName);
            out.status = "Failure";
            out.message = " Internal server error" + e.message;
            out.statusCode = 500;
        }
        appLogger.logMessage("info", "updateLogWork is finished and the result is returnd ", className, "updateLogWork", body.loggedUser, body.tenant, moduleName);
        return out;
    },
    viewWorkLogs: async function (req, loggedUser, tenant) {
        let out = {
            status: "Success",
            message: "successfully fetched worklogs",
            data: []
        }
        try {
            startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            appLogger.logMessage("debug", "viewWorkLogs function started with the payload: " + JSON.stringify(req.body), className, "viewWorkLogs", loggedUser, tenant, moduleName);
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.viewWorkLogs);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to  start/hold task due to missing parameters: " + JSON.stringify(missingParams), className, "getRiskTasks", loggedUser, tenant, moduleName);
                out.status = "Warning";
                out.message = "Failed to start/hold task  due to missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 404;
            } else {
                let query = mysqlQueries.viewWorkLogsQuery;
                let result = await dbOperations.executeQuery(query, [req.body.taskId], loggedUser, "viewWorkLogs", true, [1], tenant, appLogger, meteringLogger, moduleName);
                if (result) {
                    if (result.length > 0) {
                        out.data = result;
                    } else {
                        appLogger.logMessage("debug", "No work logs found for the user", className, "viewWorkLogs", loggedUser, tenant, moduleName);
                        out.status = "Success";
                        out.message = "No worklogs found for the user: " + req.body.loggedUser;
                        out.data = result;
                    }
                } else {
                    appLogger.logMessage("debug", "Failed to view work logs due to invalid response from the server", className, "viewWorkLogs", loggedUser, tenant, moduleName);
                    out.status = "Failed";
                    out.message = "Failed to view work logs due to invalid response from the server";
                }
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, className, "viewWorkLogs", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch worklogs due to: " + JSON.stringify(error.message), className, "viewWorkLogs", loggedUser, tenant, moduleName);
            out.status = "Failed";
            out.message = "Failed to fetch worklogs due to internal server error"
            out.data = JSON.stringify(error.message);
        }
        return out;
    },
    startOrHoldTask: async function (req, loggedUser, tenant) {
        let out = {
            status: "Success",
            message: "Successfully updated the task status",
            data: [],
            statusCode: 200
        }
        try {
            let body = req.body
            let res = false
            let action;
            startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            appLogger.logMessage("debug", "startOrHoldTask function started with payload" + JSON.stringify(req.body), className, "getRiskTasks", req.body.loggedUser, req.body.tenant, moduleName);
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.startTask);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to  start/hold task due to missing parameters: " + JSON.stringify(missingParams), className, "getRiskTasks", body.loggedUser, body.tenant, moduleName);
                out.status = "Warning";
                out.message = "Failed to start/hold task  due to missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 404;

            } else {
                if (body.currentStatus == 'HOLD' && body.statusTypeCode == 'IP') {
                    //user resume task from on hold-all its subtask except completed and closed should be OPEN
                    action="task_resume"
                    res = await supportHandler.anySubTaskExits(body.taskId, body.statusTypeCode, body.tenantId, body.loggedUserId, body.loggedUser, body.tenant)
                    out.message = 'Task resumed successfully.'

                } else if (body.currentStatus == 'IP' && body.statusTypeCode == 'HOLD') {
                    //user hold a progressing task-substask also should be on hold
                    action="task_hold"
                    res = await supportHandler.anySubTaskExits(body.taskId, body.statusTypeCode, body.tenantId, body.loggedUserId, body.loggedUser, body.tenant)
                    out.message = 'Task is on hold.'
                } else if (body.currentStatus == 'OPEN' && body.statusTypeCode == 'IP') {
                    //user starts an open  task
                    action="task_start"
                    res = true
                    out.message = 'Task started successfully.'
                }

                if (res) {
                    let startDate
                    if (req.body.startDate) {
                        startDate = req.body.startDate
                    } else {
                        startDate = moment().format("YYYY-MM-DD");
                    }
                    let param = [req.body.statusTypeCode, startDate, req.body.taskId];
                    let query = mysqlQueries.startTask;
                    let result = await dbOperations.executeQuery(query, param, loggedUser, "startTask", true, [2], tenant, appLogger, meteringLogger, moduleName);
                    if (result) {
                        if (result.affectedRows > 0) {
                            let updateTaskObj = {
                                'actualCompletionDate': body.actualCompletionDate,
                                'estimatedStartDate': body.estimatedStartDate,
                                'estimatedCompletionDate': body.estimatedCompletionDate,
                                'taskStatusTypeCode': body.statusTypeCode, 'mainTaskStatus': body.mainTaskStatus,
                                'groupId': body.groupId, 'mainTaskId': body.mainTaskId, 'projectId': body.projectId,
                                'type': body.type, 'loggedUserId': body.loggedUserId, 'tenantId': body.tenantId, 'taskId': body.taskId
                            }

                            await supportHandler.taskStatusChange(updateTaskObj, loggedUser, tenant)
                            if (req.body.statusTypeCode == 'IP') {

                                // check the status of project , if it is not IP then start the project also
                                let param = [req.body.taskId, req.body.tenantId];
                                let query = mysqlQueries.checkStatusOfProject;
                                let result = await dbOperations.executeQuery(query, param, loggedUser, "startTask", false, null, tenant, appLogger, meteringLogger, moduleName);
                                if (result != undefined && result != null && result != 'Error') {
                                    if (result[0].PROJECT_STATUS_TYPE_CODE == 'NS') {
                                        let param = [req.body.statusTypeCode, req.body.startDate, req.body.tenantId, req.body.loggedUserId, req.body.taskId];
                                        let query = mysqlQueries.setProjectInProgress;
                                        let result = await dbOperations.executeQuery(query, param, loggedUser, "startProject", false, null, tenant, appLogger, meteringLogger, moduleName);
                                        if (result != undefined && result != null && result != 'Error') {

                                            appLogger.logMessage("debug", "Successfully started/hold the task", className, "startTask", loggedUser, tenant, moduleName);
                                            out.status = "Success";
                                            // out.message = "Task started successfully";
                                            out.statusCode = 200;
                                        } else {
                                            appLogger.logMessage("debug", "Failed to started/hold the task", className, "startTask", loggedUser, tenant, moduleName);
                                            out.status = "Warning";
                                            out.message = "Failed to started/hold the task";
                                            out.statusCode = 404;
                                        }
                                    } else {
                                        appLogger.logMessage("info", "Successfully started/hold the task", className, "startTask", loggedUser, tenant, moduleName);
                                        out.status = "Success";
                                        // out.message = "Task started successfully";
                                        out.statusCode = 200
                                    }
                                    let res = await supportHandler.taskDateChange(updateTaskObj, body.loggedUser, body.tenant)



                                } else {
                                    appLogger.logMessage("info", "Failed to start task", className, "startTask", loggedUser, tenant, moduleName);
                                    out.status = "Success";
                                    // out.message = "Task started successfully";
                                    out.statusCode = 200
                                }


                            } else {
                                appLogger.logMessage("info", "Successfully started/hold the task", className, "startTask", loggedUser, tenant, moduleName);
                                out.status = "Success";
                                // out.message = "Task hold successfully";
                                out.statusCode = 200;
                            }
                            let notifyResult = await supportHandler.notifyProjectManager(body.taskId, body.loggedUserId, body.statusTypeCode, loggedUser, tenant, body.tenantId);
                            // if task added to watch list , notify watch list users on assigning 
                            //body['addedToWatchList']=true
                            if(body.addedToWatchList=='true'){
                                let nofifyResult=await supportHandler.watchListNotification(body,action,body.loggedUser,body.tenant)
                                appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                            }
                        } else {
                            appLogger.logMessage("debug", "Failed to start/hold task because it is already started or the task id is invalid", className, "startTask", loggedUser, tenant, moduleName);
                            out.status = "Failure";
                            out.message = "Already started or invalid taskId";
                            out.statusCode = 404;
                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to start/hold task due to invalid response from server", className, "startTask", loggedUser, tenant, moduleName);
                        out.status = "Failure";
                        out.message = "Failed to start/hold the task"
                        out.statusCode = 500;
                    }
                } else {
                    out.status = "Warning";
                    out.message = "Failed to start/hold task ";
                    out.statusCode = 404;
                }

            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, className, "startTask", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to start/hold the task due to: " + JSON.stringify(error.message), className, "startTask", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failed";
            out.message = "Internal server error";
            out.statusCode = 500;
            out.data = JSON.stringify(error.message);
        }
        return out;
    },
    automateProject: async function (req, loggedUser, tenant) {
        let out = {
            status: "Success",
            message: "successfully initiated project automation",
            statusCode:200,
            data: []
        }
        try {
            startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            appLogger.logMessage("debug", "automateProject function started with the payload: " + JSON.stringify(req.body), className, "automateProject", loggedUser, tenant, moduleName);
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.automateProject);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to  automateProject due to missing parameters: " + JSON.stringify(missingParams), className, "automateProject", loggedUser, tenant, moduleName);
                output.status = "Warning";
                output.message = "Failed to automateProject due to missing parameters: " + JSON.stringify(missingParams);
                output.statusCode = 404;
            } else {
                let query = mysqlQueries.getAutomatedTasks;
                let param = [req.body.projectId];
                let result = await dbOperations.executeQuery(query, param, loggedUser, "automateProject", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (result) {
                    if (result.length > 0) {
                        let min = result[0].ORDER_OF_EXECUTION;
                        for (let row of result) {
                            if (min > row.ORDER_OF_EXECUTION) {
                                min = row.ORDER_OF_EXECUTION;
                            }
                        }
                        let updateProject = await dbOperations.executeQuery(mysqlQueries.startAutomatedProject, [req.body.statusTypeCode, req.body.projectId], loggedUser, "automateProject", false, null, tenant, appLogger, meteringLogger, moduleName);
                        if (updateProject) {
                            if (updateProject.affectedRows > 0) {
                                let taskIds = [];
                                let assignedTo = [];
                                for (let row of result) {
                                    if (row.ORDER_OF_EXECUTION == min) {
                                        taskIds.push(row.TASK_ID);
                                        assignedTo.push(row);
                                    }
                                }
                                let query = mysqlQueries.startAutomatedTask;
                                let param = [req.body.statusTypeCode, [taskIds]];
                                result = await dbOperations.executeQuery(query, param, loggedUser, "automateTask", false, null, tenant, appLogger, meteringLogger, moduleName);
                                if (result) {
                                    if (result.affectedRows > 0) {
                                        // appLogger.logMessage("debug", "Successfully triggered project automation");
                                        // await PMSSupport.sendWhatsappNotification(assignedTo, loggedUser, tenant);
                                    } else {
                                        appLogger.logMessage("debug", "Failed to automate tasks due to no rows affected", className, "automateProject", loggedUser, tenant, moduleName);
                                        out.status = "Failed";
                                        out.message = "No tasks foud with the given ids";
                                    }
                                } else {
                                    appLogger.logMessage("debug", "Failed to automate tasks due to invalid response from the server", className, "automateProject", loggedUser, tenant, moduleName);
                                    out.status = "Failed";
                                    out.message = "Failed to automate tasks due to invalid response from the server";
                                }
                            } else {
                                appLogger.logMessage("debug", "Failed to update project due to no project found with the given id", className, "automateProject", loggedUser, tenant, moduleName);
                                out.status = "Failed";
                                out.message = "Failed to automate project due to no such projects found";
                            }
                        } else {
                            appLogger.logMessage("debug", "Failed to update project status as per automation due to invalid response from the server", className, "automateProject", loggedUser, tenant, moduleName);
                            out.status = "Failed";
                            out.message = "Invalid response from the server";
                        }

                    } else {
                        appLogger.logMessage("debug", "No tasks found under the given project id", className, "automateProject", loggedUser, tenant, moduleName);
                        out.status = "Failed";
                        out.message = "No tasks found under the given project id";
                    }
                } else {
                    appLogger.logMessage("debug", "Failed to automate project due to invalid response from the server", className, "automateProject", loggedUser, tenant, moduleName);
                    out.status = "Failed";
                    out.message = "Failed to automate project due to invalid resposne from the server";
                }
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, className, "automateProject", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch automateProject due to: " + JSON.stringify(error.message), className, "automateProject", loggedUser, tenant, moduleName);
            out.status = "Failed";
            out.message = "Failed to automateProject due to internal server error"
            out.data = JSON.stringify(error.message);
        }
        return out;
    },
    //API TO FETCH FIRST THREE TASK IN ALL STATUS AND ITS COUNT IN MY TASK PAGE
    getAllTasksOfUser: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("debug", "getAllTasksOfUser called", className, "getAllTasksOfUser", loggedUser, tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully fetched tasks",
            data: {},
            statusCode: 200
        }
        let result
        try {
            let body = req.body;
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getAllTasksOfUser);

            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Missing parameters: " + JSON.stringify(missingParams), className, "getAllTasksOfUser", loggedUser, tenant, moduleName);
                out.status = "warning"
                out.message = "Missing parameters: " + JSON.stringify(missingParams)
                out.statusCode = 404
            } else {
                let query;
                let param = [];
                if (String(body.role).toLowerCase() == "employee") {
                    param = [body.tenantId, body.userId, [["COM", "IP", "OPEN", "HOLD", "NS"]]];
                    query = mysqlQueries.getAllTasksOfEmployee;
                } else {

                    appLogger.logMessage("debug", "Invalid role received: " + body.role + " Expected role is: Employee ", className, "getAllTasksOfUser", loggedUser, tenant, moduleName);
                    out.status = "Failed";
                    out.message = "Invalid role received: " + body.role + ". Expected role is employee";
                    return out;
                }
                result = await dbOperations.executeQuery(query, param, loggedUser, "getAllTasksOfUser", false, null, tenant, appLogger, meteringLogger, moduleName);
                appLogger.logMessage("debug", "Data recieved after fetching tasks by status: " + JSON.stringify(result), className, "getAllTasksOfUser", loggedUser, tenant, moduleName);
                if (result) {
                    let completedTasks = [];
                    let inProgressTasks = [];
                    let openTasks = [];
                    let holdTasks = [];
                    let notStartedTasks = [];
                    let watchListTask=[];
                    let awaitingApprovalTask=[];
                    let rejectedTask=[];
                    let countIP = 0
                    let countOpen = 0
                    let countNS = 0
                    let countHOLD = 0
                    let countCOM = 0
                    let countwatchList=0
                    let countAwaitingApproval=0
                    let countRejected=0
                    for (let row of result) {
                        let image = null;
                        let dueDate = moment(row.DUE_DATE).format("YYYY-MM-DD");
                        let currentDate = moment().format("YYYY-MM-DD");
                        let diff = moment(currentDate).diff(moment(dueDate), 'days');
                        row["DUE_IN"] = diff;
                        if (row.EMPLOYEE_NUMBER != null && row.EMPLOYEE_NUMBER != undefined) {
                            let key = String(req.body.tenant).toUpperCase() + "_" + row.EMPLOYEE_NUMBER;
                            image = await ImageHandler.fetchPhoto(req.body.tenantType, key, row.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                            row["IMAGE"] = image || null;
                        } else {
                            row["IMAGE"] = null;
                        }
                        if (row.TASK_STATUS_TYPE_CODE == "IP") {
                            inProgressTasks.push(row);
                        } else if(row.TASK_STATUS_TYPE_CODE == "COM" && String(row.APPROVAL_REQUIRED).toUpperCase()=='N'){
                            completedTasks.push(row);

                        }else if (row.TASK_STATUS_TYPE_CODE == "COM" && String(row.APPROVAL_REQUIRED).toUpperCase()=='Y') {
                            if(String(row.SUB_STATUS).toUpperCase()=='APPROVED'){
                                completedTasks.push(row)
                            }else if(String(row.SUB_STATUS).toUpperCase()=='REJECTED'){
                                rejectedTask.push(row)
                            }else if(String(row.SUB_STATUS).toUpperCase()=='AWAITING APPROVAL'){
                                awaitingApprovalTask.push(row)
                            }
                        } else if (row.TASK_STATUS_TYPE_CODE == "OPEN") {
                            openTasks.push(row);
                        } else if (row.TASK_STATUS_TYPE_CODE == "NS") {
                            notStartedTasks.push(row);
                        } else if (row.TASK_STATUS_TYPE_CODE == "HOLD") {
                            holdTasks.push(row);
                        }
                    }
                    query=mysqlQueries.getWatchListTasksOfEmployee
                    param = [body.tenantId,[[ "IP", "OPEN", "HOLD", "NS"]],body.userId];
                    watchListTask = await dbOperations.executeQuery(query,param, loggedUser, "getAllTasksOfUser", false, null, tenant, appLogger, meteringLogger, moduleName)
                    appLogger.logMessage("debug", "Result of fetching watch list "+JSON.stringify(result), "PMService", "getAllTasksOfUser", loggedUser, tenant, moduleName);
                    if(watchListTask!=undefined && watchListTask!=null && watchListTask!='Error'){
                        if(watchListTask.length>0){
                            for(let row of watchListTask){
                                let dueDate = moment(row.DUE_DATE).format("YYYY-MM-DD");
                                let currentDate = moment().format("YYYY-MM-DD");
                                let diff = moment(currentDate).diff(moment(dueDate), 'days');
                                row["DUE_IN"] = diff;
                                if (row.EMPLOYEE_NUMBER != null && row.EMPLOYEE_NUMBER != undefined) {
                                    let key = String(req.body.tenant).toUpperCase() + "_" + row.EMPLOYEE_NUMBER;
                                    image = await ImageHandler.fetchPhoto(req.body.tenantType, key, row.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                    row["IMAGE"] = image || null;
                                } else {
                                    row["IMAGE"] = null;
                                }
                            }
                            appLogger.logMessage("info", "Watch list fetched successfully ", "PMService", "getAllTasksOfUser", loggedUser, tenant, moduleName);
        
                        }else{
                            appLogger.logMessage("info", " No task in Watch list fetched", "PMService", "getAllTasksOfUser", loggedUser, tenant, moduleName);

                        }
                    }else{
                        appLogger.logMessage("info", " Failed to fetch task from watch list", "PMService", "getAllTasksOfUser", loggedUser, tenant, moduleName);

                    }

                    // if(String(body.approvalRequired).toUpperCase()=='Y'){
                    //     for(let row of result){
                    //         if(row)
                    //     }
                    // }
                    watchListTask.sort((a, b) => {
                        return b.DUE_DATE - a.DUE_DATE;
                    });
                    inProgressTasks.sort((a, b) => {
                        return b.DUE_DATE - a.DUE_DATE;
                    });
                    notStartedTasks.sort((a, b) => {
                        return b.DUE_DATE - a.DUE_DATE;
                    });
                    openTasks.sort((a, b) => {
                        return b.DUE_DATE - a.DUE_DATE;
                    });
                    holdTasks.sort((a, b) => {
                        return b.DUE_DATE - a.DUE_DATE;
                    });
                    completedTasks.sort((a, b) => {
                        return b.ACTUAL_COMPLETION_DATE - a.ACTUAL_COMPLETION_DATE;
                    });
                    awaitingApprovalTask.sort((a, b) => {
                        return b.ACTUAL_COMPLETION_DATE - a.ACTUAL_COMPLETION_DATE;
                    });
                    rejectedTask.sort((a, b) => {
                        return b.ACTUAL_COMPLETION_DATE - a.ACTUAL_COMPLETION_DATE;
                    });
                    countAwaitingApproval=awaitingApprovalTask.length
                    countRejected=rejectedTask.length

                    countIP = inProgressTasks.length
                    countOpen = openTasks.length
                    countNS = notStartedTasks.length
                    countHOLD = holdTasks.length
                    countCOM = completedTasks.length
                    countwatchList=watchListTask.length
                    if (watchListTask.length > 3) {
                        watchListTask = watchListTask.splice(0, 3)
                    }
                    if (inProgressTasks.length > 3) {
                        inProgressTasks = inProgressTasks.splice(0, 3)
                    }
                    if (notStartedTasks.length > 3) {
                        notStartedTasks = notStartedTasks.splice(0, 3)
                    }
                    if (openTasks.length > 3) {
                        openTasks = openTasks.splice(0, 3)
                    }
                    if (holdTasks.length > 3) {
                        holdTasks = holdTasks.splice(0, 3)
                    }
                    if (awaitingApprovalTask.length > 3) {
                        awaitingApprovalTask = awaitingApprovalTask.splice(0, 3)
                    }
                    if (rejectedTask.length > 3) {
                        rejectedTask = rejectedTask.splice(0, 3)
                    }
                    if (completedTasks.length > 3) {
                        completedTasks = completedTasks.splice(0, 3)
                    }
                    out.data["COM"] = completedTasks;
                    out.data["IP"] = inProgressTasks;
                    out.data["OPEN"] = openTasks;
                    out.data["HOLD"] = holdTasks;
                    out.data["NS"] = notStartedTasks;
                    out.data['WATCH_LIST']=watchListTask
                    out.data['AWAITING_APPROVAL']=awaitingApprovalTask
                    out.data['REJECTED']=rejectedTask

                    // count of task in  each status
                    out.data["AWAITING_APPROVAL_COUNT"] =countAwaitingApproval
                    out.data["REJECTED_COUNT"] =countRejected
                    out.data["COM_COUNT"] = countCOM;
                    out.data["IP_COUNT"] = countIP;
                    out.data["OPEN_COUNT"] = countOpen;
                    out.data["HOLD_COUNT"] = countHOLD;
                    out.data["NS_COUNT"] = countNS;
                    out.data['WATCH_LIST_COUNT']=countwatchList
                    let projectAssigned = await dbOperations.executeQuery(mysqlQueries.getProjectsAssigned, [req.body.loggedUserId, req.body.tenantId], loggedUser, "getProjectsAssigned", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (projectAssigned != null && projectAssigned != undefined && projectAssigned.length > 0) {
                        out.data['PROJECT_ASSIGNED'] = true;
                    } else {
                        out.data['PROJECT_ASSIGNED'] = false;
                    }
                } else {
                    appLogger.logMessage("debug", "Failed to fetch tasks due to internal server error", className, "getAllTasksOfUser", loggedUser, tenant, moduleName);
                    out.status = "Failed";
                    out.statusCode = 500;
                    out.message = "Invalid data received from the server";
                }

            }
        } catch (error) {
            out.status = "Failed";
            out.message = "Internal server error";
            out.statusCode = 500;
            out.data = JSON.stringify(error.message);
            appLogger.logMessage("error", "Failed to fetch tasks based on status code due to: " + JSON.stringify(error.message), className, "getAllTasksOfUser", loggedUser, tenant, moduleName);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(tenant, loggedUser, className, "getAllTasksOfUser", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },
    getRiskTasksOfEmp: async function (req, loggedUser, tenant) {
        return new Promise(async function (resolve, reject) {
            startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            let body = req.body;
            let output = {
                status: "Success",
                message: "Successfully fetched expired tasks",
                data: [],
                statusCode: 200
            }
            try {
                appLogger.logMessage("debug", "getRiskTasksOfEmp function started with payload" + JSON.stringify(body), className, "getRiskTasksOfEmp", body.loggedUser, body.tenant, moduleName);
                let requestParams = Object.keys(req.body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getRiskTasksOfEmp);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to  get getRiskTasksOfEmp due to missing parameters: " + JSON.stringify(missingParams), className, "getRiskTasksOfEmp", body.loggedUser, body.tenant, moduleName);
                    output.status = "Warning";
                    output.message = "Failed to get getRiskTasksOfEmp  due to missing parameters: " + JSON.stringify(missingParams);
                    output.statusCode = 404;
                } else {
                    if (String(req.body.role).toLowerCase() == "employee") {
                        let payload = {
                            loggedUser: req.body.loggedUser,
                            tenant: req.body.tenant,
                            tenantId: req.body.tenantId,
                            loggedUserId: req.body.userId,
                            role: req.body.role
                        }
                        let expiredTasks = await PMSSupport.getTasksDueExpiredEmp(payload);
                        if (String(expiredTasks.status).toLowerCase() == "success") {
                            for (let task of expiredTasks.data) {
                                let image = null;
                                let dueDate = moment(task.DUE_DATE).format("YYYY-MM-DD");
                                let currentDate = moment().format("YYYY-MM-DD");
                                let diff = moment(currentDate).diff(moment(dueDate), 'days');
                                task["DUE_IN"] = diff;
                                if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                                    let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                                    image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                    task["IMAGE"] = image || null;
                                } else {
                                    task["IMAGE"] = null;
                                }
                                task["LEVEL"] = 1;
                                output.data.push(task);
                            }

                        }
                        let todayExpiringTasks = await PMSSupport.getTasksDueTodayEmp(payload);
                        if (String(todayExpiringTasks.status).toLowerCase() == "success") {
                            for (let task of todayExpiringTasks.data) {
                                let image = null;
                                if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                                    let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                                    image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                    task["IMAGE"] = image || null;
                                } else {
                                    task["IMAGE"] = null;
                                }
                                task["LEVEL"] = 2;
                                if (!output.data.includes(task)) {
                                    output.data.push(task);
                                }
                            }
                            // output.data["expiringToday"] = todayExpiringTasks.data;
                        }

                        let expiringSoon = await PMSSupport.getTasksDueIsUpcomingEmp(payload);
                        if (String(expiringSoon.status).toLowerCase() == "success") {
                            for (let task of expiringSoon.data) {
                                let image = null;
                                let dueDate = moment(task.DUE_DATE).format("YYYY-MM-DD");
                                let currentDate = moment().format("YYYY-MM-DD");
                                let diff = moment(dueDate).diff(moment(currentDate), 'days');
                                task["DUE_IN"] = diff;
                                if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                                    let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                                    image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                    task["IMAGE"] = image || null;
                                } else {
                                    task["IMAGE"] = null;
                                }
                                task["LEVEL"] = 3;
                                if (!output.data.includes(task)) {
                                    output.data.push(task);
                                }
                            }
                            // output.data["expiringSoon"] = expiringSoon.data;
                        }


                        // let exeedingEfforts = await PMSSupport.getTasksExeedsEffortEmp(payload);
                        // if (String(exeedingEfforts.status).toLowerCase() == "success") {
                        //     for (let task of exeedingEfforts.data) {
                        //         let image = null;
                        //         if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                        //             let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                        //             image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant,appLogger,meteringLogger,moduleName);
                        //             task["IMAGE"] = image || null;
                        //         } else {
                        //             task["IMAGE"] = null;
                        //         }
                        //         task["LEVEL"] = 4;
                        //         if (!output.data.includes(task)) {
                        //             output.data.push(task);
                        //         }
                        //     }
                        //     // output.data["exeedingEfforts"] = exeedingEfforts.data;
                        // }


                        let taskNotStarted = await PMSSupport.getTasksNotStartedEmp(payload);
                        if (String(taskNotStarted.status).toLowerCase() == "success") {
                            for (let task of taskNotStarted.data) {
                                let image = null;
                                if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                                    let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                                    image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                    task["IMAGE"] = image || null;
                                } else {
                                    task["IMAGE"] = null;
                                }
                                task["LEVEL"] = 5;
                                if (!output.data.includes(task)) {
                                    output.data.push(task);
                                }
                            }
                            // output.data["exeedingEfforts"] = exeedingEfforts.data;
                        }

                        let taskOpen = await PMSSupport.getTasksOpenEmp(payload);
                        if (String(taskOpen.status).toLowerCase() == "success") {
                            for (let task of taskOpen.data) {
                                let image = null;
                                if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                                    let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                                    image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                    task["IMAGE"] = image || null;
                                } else {
                                    task["IMAGE"] = null;
                                }
                                task["LEVEL"] = 7;
                                if (!output.data.includes(task)) {
                                    output.data.push(task);
                                }
                            }
                            // output.data["exeedingEfforts"] = exeedingEfforts.data;
                        }


                        let taskOnHold = await PMSSupport.getTasksonHoldEmp(payload);
                        if (String(taskOnHold.status).toLowerCase() == "success") {
                            for (let task of taskOnHold.data) {
                                let image = null;
                                if (task.EMPLOYEE_NUMBER != null && task.EMPLOYEE_NUMBER != undefined) {
                                    let key = String(req.body.tenant).toUpperCase() + "_" + task.EMPLOYEE_NUMBER;
                                    image = await ImageHandler.fetchPhoto(req.body.tenantType, key, task.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                    task["IMAGE"] = image || null;
                                } else {
                                    task["IMAGE"] = null;
                                }
                                task["LEVEL"] = 6;
                                if (!output.data.includes(task)) {
                                    output.data.push(task);
                                }
                            }

                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to fetch all tasks of employee due to invalid role:" + req.body.role + ". Expected role was: employee", className, "getRiskTasksOfEmp", loggedUser, tenant, moduleName);
                        output.status = "Failed";
                        output.message = "Invalid role given: " + req.body.role + ". Expected role was employee";
                    }

                }
                endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
                diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
                meteringLogger.logMessage(tenant, loggedUser, className, "getRiskTasksOfEmp", startDateTime, endDateTime, diffInMS, moduleName);
            } catch (e) {
                appLogger.logMessage("error", e.message, className, "getRiskTasksOfEmp", body.loggedUser, body.tenant, moduleName);
                output.status = "Failure"
                output.message = " Internal server error" + e.message
                output.statusCode = 500
            }
            appLogger.logMessage("info", "getRiskTasksOfEmp is finished and the result is returnd ", className, "getRiskTasksOfEmp", body.loggedUser, body.tenant, moduleName);
            resolve(output);
        })
    },
    deleteWorkLog: async function (req, loggedUser, tenant) {
        return new Promise(async function (resolve, reject) {
            startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            let body = req.body;
            let output = {
                status: "Success",
                message: "Worklog has been deleted!",
                data: [],
                statusCode: 200
            }
            try {
                appLogger.logMessage("debug", "deleteWorkLog function started with payload" + JSON.stringify(body), className, "deleteWorkLog", body.loggedUser, body.tenant, moduleName);
                let requestParams = Object.keys(req.body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.deleteWorkLog);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to  get deleteWorkLog due to missing parameters: " + JSON.stringify(missingParams), className, "deleteWorkLog", body.loggedUser, body.tenant, moduleName);
                    output.status = "Warning";
                    output.message = "Failed to get deleteWorkLog  due to missing parameters: " + JSON.stringify(missingParams);
                    output.statusCode = 404;
                } else {
                    let query = mysqlQueries.deleteWorkLog;
                    let param = [req.body.worklogId];
                    let result = await dbOperations.executeQuery(query, param, loggedUser, "deleteWorkLog", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result) {
                        if (result.affectedRows > 0) {
                            let updateActualEffort = await supportHandler.updateActualEffort(body.taskId, body.tenantId, body.loggedUserId, body.loggedUser, body.tenant)
                            if (updateActualEffort) {
                                appLogger.logMessage("debug", "Successfully deleted worklog and updated actual effort of the task", className, "deleteWorkLog", loggedUser, tenant, moduleName);
                                let res
                                if(body.timesheet=='true'){
                                    query=mysqlQueries.getTasksData
                                    param=[body.taskId,body.tenantId]
                                    result = await dbOperations.executeQuery(query, param, loggedUser, "deleteWorkLog", false, null, tenant, appLogger, meteringLogger, moduleName);
                                    if(result!=undefined && result!=null && result !='Error'){
                                        if(result.length>0){
                                            if(result[0].TYPE=='SUB' && result[0].MAIN_TASK_ID!=null && result[0].MAIN_TASK_ID!=undefined){
                                                let taskObj={'taskId':body.taskId,'mainTaskId':result[0].MAIN_TASK_ID,'type':result[0].TYPE,'loggedUserId':body.loggedUserId,'tenantId':body.tenantId}
                                                res=await supportHandler.updateMainTaskEffort(taskObj,body.loggedUser,body.tenant) 
                                                if(res.type!='Success'){
                                                    appLogger.logMessage("info", "Updated main task effort", className, "deleteWorkLog", loggedUser, tenant, moduleName);
                                                    out.status = "Warning";
                                                    out.message = "Failed to update effort of the main task."
                                                }else{
                                                    // if task added to watch list , notify watch list users on assigning 
                                                    // if(body.addedToWatchList=='true'){
                                                    //     let nofifyResult=await supportHandler.watchListNotification(body,'task_reassign',body.loggedUser,body.tenant)
                                                    //     appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                                                    // }
                                                }
                                            }
                                        }else{
                                            appLogger.logMessage("info", "Failed to fetch  task details ", className, "deleteWorkLog", loggedUser, tenant, moduleName);
                                            out.status = "Warning";
                                            out.message = "Failed to update effort of the main task."
                                                    
                                        }
                                    }else{
                                        appLogger.logMessage("info", "Failed to fetch  task details ", className, "deleteWorkLog", loggedUser, tenant, moduleName);
                                        out.status = "Warning";
                                        out.message = "Failed to update effort of the main task."
                                                    
                                    }

                                }else{
                                    if(body.type=='SUB'){
                                    //update the main task effort
                                    res=await supportHandler.updateMainTaskEffort(body,body.loggedUser,body.tenant)
                                    if(res.type!='Success'){
                                        appLogger.logMessage("info", "", className, "logWork", loggedUser, tenant, moduleName);
                                        out.status = "Warning";
                                        out.message = "Failed to update effort of the main task."
                                        }
                                    }else{
                                        // if task added to watch list , notify watch list users on assigning 
                                        // body['addedToWatchList']=true
                                        // if(body.addedToWatchList==true){
                                        //     let nofifyResult=await supportHandler.watchListNotification(body,'task_reassign',body.loggedUser,body.tenant)
                                        //     appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                                        // }
                                    }
                                }
                                
                                
                            } else {
                                appLogger.logMessage("debug", "Successfully deleted worklog", className, "deleteWorkLog", loggedUser, tenant, moduleName);

                            }
                            // appLogger.logMessage("debug", "Successfully deleted worklog", className, "deleteWorkLog", loggedUser, tenant, moduleName);
                        } else {
                            appLogger.logMessage("debug", "Failed to delete worklog due to the given worklog id is not found", className, "deleteWorkLog", loggedUser, tenant, moduleName);
                            output.status = "Warning";
                            output.message = "Worklog not found!";
                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to delete work log due to invalid response from the server", className, "deleteWorkLog", loggedUser, tenant, moduleName);
                        output.status = "Warning";
                        output.message = "Internal server error";
                    }
                }
                endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
                diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
                meteringLogger.logMessage(tenant, loggedUser, className, "deleteWorkLog", startDateTime, endDateTime, diffInMS, moduleName);
            } catch (e) {
                appLogger.logMessage("error", e.message, className, "deleteWorkLog", body.loggedUser, body.tenant, moduleName);
                output.status = "Failure"
                output.message = " Internal server error" + e.message
                output.statusCode = 500
            }
            appLogger.logMessage("info", "deleteWorkLog is finished and the result is returnd ", className, "getRiskTasksOfEmp", body.loggedUser, body.tenant, moduleName);
            resolve(output);
        })
    },
    getUserProjectDetails: async function (payload, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMSServices", "getUserProjectDetails", loggedUser, tenant, moduleName);
        formattedResult = [];
        let result;
        let users = [];
        try {
            if (payload.tenantType != null && payload.tenantType != undefined && payload.projectId != null && payload.projectId != undefined) {
                let projectUserDetails = await dbOperations.executeQuery(mysqlQueries.getUserProjectDetails, [payload.tenantId, payload.projectId], loggedUser, "projectUserDetails", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (projectUserDetails != null && projectUserDetails != undefined && projectUserDetails.length > 0) {
                    for (let user of projectUserDetails) {
                        let key = String(tenant).toUpperCase() + "_" + user.EMPLOYEE_NUMBER;
                        image = await ImageHandler.fetchPhoto(payload.tenantType, key, user.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                        users.push({
                            'User_Id': user.ID,
                            'UserMail': user.EMAIL,
                            'Name': user.FULL_NAME,
                            'Image': image,
                            'Designation': user.DESIGNATION,
                            'ActiveProjects': user.ACTIVE_PROJECTS
                        })
                    }
                    result = await responseHandler.sendResponse('Success', "Data fethed successfully.", 200, users, false, "getUserProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                } else {
                    result = await responseHandler.sendResponse('Warning', "No Users found.", 200, [], false, "getUserProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                }
            } else {
                result = await responseHandler.sendResponse('Warning', "Invalid parameters.", 400, [], false, "getUserProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger)
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMSServices", "getUserProjectDetails", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMSServices", "getUserProjectDetails", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMSServices", "getUserProjectDetails", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getUserProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    assignToTeam: async function (payload, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMSServices", "assignToTeam", loggedUser, tenant, moduleName);
        formattedResult = [];
        let result;
        try {
            if (payload.userId != null && payload.userId != undefined && payload.projectId != null && payload.projectId != undefined && payload.roleCode != null && payload.roleCode != undefined) {
                let params = [];
                let roleId;
                if (payload.isNewRole == 'true' && payload.role != undefined && payload.role != null) {
                    if(payload.role.trim() != '') {
                        let assignRole = await this.addfunctionalroles(payload, loggedUser, tenant)
                        if (assignRole.statusCode == 200) {
                            roleId = assignRole.data;
                        } else {
                            roleId = (assignRole.data.length > 0) ? assignRole.data[0].ID:null;
                        }
                    } else {
                        appLogger.logMessage("debug", "Invalid entry for Role.", className, "changeExistsFuncRole", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse('Warning', "Please enter valid functional role.", 400, null, false, "changeExistsFuncRole", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                        return result;
                    }
                } else if (payload.isNewRole == 'false' && payload.role != undefined && payload.role != null && payload.role != '') {
                    roleId = payload.role
                } else {
                    roleId = null
                }
                params.push(payload.tenantId, payload.userId, payload.projectId, moment().format("YYYY-MM-DD"), payload.roleCode, roleId, payload.loggedUserId, payload.loggedUserId)
                let assignResult = await dbOperations.executeQuery(mysqlQueries.addProjectTeam, [[params]], loggedUser, "assignTeam", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (assignResult != null && assignResult != undefined && assignResult.affectedRows > 0) {
                    if (payload.projectName != null && payload.projectName != undefined
                        && payload.assignedByName != null && payload.assignedByName != undefined
                        && payload.projectDescription != null && payload.projectDescription != undefined
                        && payload.estimatedStartDate != null && payload.estimatedStartDate != undefined
                        && payload.estimatedCompletionDate != null && payload.estimatedCompletionDate != undefined
                        && payload.userMail != null && payload.userMail != undefined) {
                        let sub = mailConfig.project.addToTeam.sub
                        let mes = mailConfig.project.addToTeam.message
                        let message;
                        sub = sub.replace('{projectName}', payload.projectName)
                        sub = sub.replace('{assignedByName}', payload.assignedByName)
                        mes = mes.replace('{projectId}', payload.projectId)
                        mes = mes.replace('{projectName}', payload.projectName)
                        mes = mes.replace('{assignedByName}', payload.assignedByName)
                        mes = mes.replace('{projectDescription}', payload.projectDescription)
                        mes = mes.replace('{estimatedStartDate}', moment(payload.estimatedStartDate).format("DD MMM YYYY"))
                        mes = mes.replace('{estimatedCompletionDate}', moment(payload.estimatedCompletionDate).format("DD MMM YYYY"))
                        message = mes
                        let userData = [{ 'Id': payload.userId, 'Email': payload.userMail }]
                        sendMails(userData, null, null, sub, message, payload.loggedUser, payload.tenant, null, false, payload.tenantId, appLogger, meteringLogger, moduleName)
                        if(payload.role !=null && payload.role !='' ){
                            let sender=await dbOperations.executeQuery(mysqlQueries.sendersData, [payload.loggedUserId,payload.tenantId,payload.projectId], loggedUser, "recipientdata", false, null, tenant, appLogger, meteringLogger, moduleName);
                        let recipient=await dbOperations.executeQuery(mysqlQueries.recipientData, [payload.userId,payload.tenantId,payload.role], loggedUser, "recipientdata", false, null, tenant, appLogger, meteringLogger, moduleName);
                        if (recipient[0].ROLE_NAME==="Project Manager"||recipient[0].ROLE_NAME==="Delegated Project Manager"){
                            let message=sender[0].FULL_NAME+" made an update to your role in the project  "+sender[0].PROJECT_NAME+", and you are now the "+recipient[0].ROLE_NAME;
                            let payload1 = {
                                "message":message,
                                "loggedUser":sender[0].FULL_NAME,
                                "whatsappNumber":recipient[0].WHATSAPP_NUMBER,
                                "tenant":payload.tenant,
                                "tenantId": payload.tenantId,
                                "whatsappId":recipient[0].WHATSAPP_ID
                            }
                            endPoint = config.whatsAppServerUrl + config.whatsAppEndpoints.notifyUser;
                            let notifyResult = await PMSSupport.sendNotificationInWhatsapp(endPoint,payload1,payload.loggedUser,payload.tenant);
                        }
                        }
                        
                    } else {
                        appLogger.logMessage("info", "Invalid parameters for email ", className, "assignToTeam", loggedUser, tenant, moduleName);
                    }
                    // let updateMailResult=await supportHandler.updateMailStatus(saveMailResult.insertId,payload.tenantId,payload.loggedUser,payload.tenant)
                    let notifyUser = await supportHandler.onBoardAndAssignTask(null, payload.projectId, payload.userId, loggedUser, tenant, true, payload.tenantId);
                    let msg = "You have been onboarded to new project" + " "+payload.projectName
                    await dbOperations.executeQuery(mysqlQueries.addNotification, [payload.tenantId, payload.userId, msg, payload.projectId, 'PROJECT'], payload.loggedUser, "assignUserToTask", true, [2, 7, 8], tenant, appLogger, meteringLogger, moduleName);
                    appLogger.logMessage("debug", "Response after notifying user about onboarding to a project: " + JSON.stringify(notifyUser), className, "assignToTeam", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse('Success', "User added to the team.", 200, [], false, "assignToTeam", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                } else {
                    result = await responseHandler.sendResponse('Warning', "Invalid parameters.", 400, [], false, "assignToTeam", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                }
            } else {
                result = await responseHandler.sendResponse('Warning', "Invalid parameters.", 400, [], false, "assignToTeam", tenant, loggedUser, moduleName, appLogger, meteringLogger)
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMSServices", "assignToTeam", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMSServices", "assignToTeam", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMSServices", "assignToTeam", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "assignToTeam", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // fetch team members 
    getTeamDetailsByProject: async function (payload, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMSServices", "getTeamDetailsByProject", loggedUser, tenant, moduleName);
        formattedResult = [];
        let result;
        try {
            if (payload.projectId != null && payload.projectId != undefined && payload.tenantType != null && payload.tenantType != undefined) {
                let projectData = await dbOperations.executeQuery(mysqlQueries.getProjectTeamDetails, [payload.projectId, payload.projectId, payload.projectId, payload.projectId, payload.projectId], loggedUser, "getTeamDetailsByProject", false, null, tenant, appLogger, meteringLogger, moduleName);
                appLogger.logMessage("debug", "getProjectTeamDetails : " + JSON.stringify(projectData), "PMSServices", "getTeamDetailsByProject", loggedUser, tenant, moduleName, moduleName);
                if (projectData != null && projectData != undefined && projectData.length > 0) {
                    for (let data of projectData) {
                        let key = String(tenant).toUpperCase() + "_" + data.EMPLOYEE_NUMBER;
                        data['IMAGE'] = await ImageHandler.fetchPhoto(payload.tenantType, key, data.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                    }
                    result = await responseHandler.sendResponse('Success', "Data fetched successfully.", 200, projectData, false, "getTeamDetailsByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                } else {
                    result = await responseHandler.sendResponse('Warning', "No data found.", 400, [], false, "getTeamDetailsByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                }
            } else {
                result = await responseHandler.sendResponse('Warning', "Invalid parameters.", 400, [], false, "getTeamDetailsByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger)
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMSServices", "getTeamDetailsByProject", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMSServices", "getTeamDetailsByProject", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMSServices", "getTeamDetailsByProject", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getTeamDetailsByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    holdOrResume: async function (req) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully Hold Or Resume the project",
            statusCode:200,
            data: []
        }
        try {
            let body = req.body;
            let loggedUser = body.loggedUser
            let tenant = body.tenant
            let message, sub, mes;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.holdOrResume);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to hold or resume due to missing parameters: " + JSON.stringify(missingParams), className, "holdOrResume", body.loggedUser, body.tenant);
                    out.status = "Failed";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    let query = mysqlQueries.changeProjectStatus;
                    let param = [req.body.projectStatusType, req.body.projectId, req.body.tenantId];
                    let result = await dbOperations.executeQuery(query, param, loggedUser, "holdOrResume", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != 'Error') {
                        if (result.affectedRows > 0) {
                            let query
                            if (req.body.projectStatusType == 'HOLD') {
                                //hold project and task which which are  in IP and NS								
                                sub = mailConfig.project.hold.sub
                                mes = mailConfig.project.hold.message
                                sub = sub.replace('{projectName}', body.projectName)
                                sub = sub.replace('{holdByName}', body.resumedByName)
                                query = mysqlQueries.changeTaskStatusHold;
                            } else if (req.body.projectStatusType == 'IP') {
                                //resume (IP) project and task which which are in HOLD
                                sub = mailConfig.project.resume.sub
                                sub = sub.replace('{projectName}', body.projectName)
                                sub = sub.replace('{resumedByName}', body.resumedByName)
                                mes = mailConfig.project.resume.message
                                query = mysqlQueries.changeTaskStatusIP;
                            }
                            let param = [req.body.projectStatusType, req.body.projectId, req.body.tenantId];
                            let result = await dbOperations.executeQuery(query, param, loggedUser, "holdOrResume", false, null, tenant, appLogger, meteringLogger, moduleName);
                            if (result != null && result != undefined && result != 'Error') {
                                if (result) {
                                    let userData = await supportHandler.getTeamMailData(body.projectId, body.tenantId, body.loggedUser, body.tenant)

                                    let message;
                                    mes = mes.replace('{projectName}', body.projectName)
                                    mes = mes.replace('{projectDescription}', body.projectDescription)
                                    mes = mes.replace('{actualStartDate}', moment(body.actualStartDate).format('DD-MM-YYYY'))
                                    mes = mes.replace('{estimatedCompletionDate}', moment(body.estimatedCompletionDate).format('DD-MM-YYYY'))
                                    message = mes
                                    sendMails(userData, null, null, sub, message, body.loggedUser, body.tenant, null, false, body.tenantId, appLogger, meteringLogger, moduleName)
                                    appLogger.logMessage("info", "Status updated successfully", className, "holdOrResume", "SELF", "SELF_TENANT");
                                    out.status = "Success";
                                    out.message = " Project status updated successfully";
                                    out.data = []
                                    out.statusCode = 200
                                } else {
                                    appLogger.logMessage("info", "No change to the project status", className, "holdOrResume", "SELF", "SELF_TENANT");
                                    out.status = "Warning";
                                    out.message = " No change to the project status";
                                    out.data = []
                                    out.statusCode = 404
                                }
                            } else {
                                appLogger.logMessage("info", "Failed to update  project status", className, "holdOrResume", "SELF", "SELF_TENANT");
                                out.status = "Success";
                                out.message = "Failed to update project status";
                                out.data = []
                                out.statusCode = 404
                            }
                        }
                    } else {
                        appLogger.logMessage("info", "Failed to update  project status", className, "holdOrResume", "SELF", "SELF_TENANT");
                        out.status = "Success";
                        out.message = "Failed to update project status";
                        out.data = []
                        out.statusCode = 404
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to hold or resume  project due to invalid request body", className, "holdOrResume", "SELF", "SELF_TENANT");
                out.status = "Failed";
                out.message = "Invalid request body";
                out.statusCode = 404
                out.data = []
            }

        } catch (error) {
            appLogger.logMessage("error", "Failed to close project due to: " + JSON.stringify(error.message), className, "holdOrResume", req.body.loggedUser, req.body.tenant);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "holdOrResume", startDateTime, endDateTime, diffInMS);
        return out;
    },

    //GET MAIN TASKS FROM GPM_TASKS
    getMainTasks: async function (req) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully fetch task",
            data: []
        }
        let response = []
        try {
            let body = req.body;
            let loggedUser = body.loggedUser
            let tenant = body.tenant
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getMainTasks);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to fetch task due to missing parameters: " + JSON.stringify(missingParams), className, "holdOrResume", body.loggedUser, body.tenant);
                    out.status = "Failed";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    let isMilstoneMapped, isReccursive, currencyCode, maxAmt, minAmt;
                    let query = mysqlQueries.getMainTasks;
                    let param = [req.body.projectId, req.body.tenantId];
                    let result = await dbOperations.executeQuery(query, param, loggedUser, "getMainTasks", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != 'Error') {
                        if (result.length > 0) {
                            for (let data of result) {
                                let assignee = [], milestone = []
                                assignee.push({ 'ID': data.ASSIGNED_TO, 'FULL_NAME': data.ASSIGNED_TO_NAME, 'ROLE_NAME': data.ROLE_NAME || 'EMPLOYEE' })
                                data['ASSIGNEE'] = assignee
                                data['SUB_TASK'] = []
                                milestone.push({ 'MILESTONE_NAME_ARRAY': data.MILESONE_NAME, 'MILESTONE_ID_ARRAY': data.MILESTONE_ID })
                                data['MILESTONE'] = milestone
                                let dueDate = moment(data.ESTIMATED_COMPLETION_DATE).format("YYYY-MM-DD");
                                let currentDate = moment().format("YYYY-MM-DD");
                                let diff = moment(currentDate).diff(moment(dueDate), 'days');
                                data["DUE_IN"] = diff;
                                
                            let dependencyTasks = await supportHandler.getDependencyTask(data.ID, body.tenantId, body.loggedUser, body.tenant)
                            data['PREDECESSOR_TASK'] = dependencyTasks.PREDECESSOR
                            data['SUCCESSOR_TASK'] = dependencyTasks.SUCCESSOR
                            data['CAN_START']=true
                            data['CAN_COMPLETE']=true
                            if(dependencyTasks.pIdArray.length>0){
                                // if task has some predecessor, 
                                
                                for(let task of dependencyTasks.PREDECESSOR){
                                    if(task.CANNOT_START=='Y' ){
                                        // if the dependency rule is CS , check whether that task is complete
                                        // then only  we can start the selected task
                                        // if the dependency  rule with task is CC , check whether the task is completed
                                        // then only we can complete complete task
                                        if(task.TASK_STATUS!='COM'){
                                            data['CAN_START']=false
                                        }

                                    }else if(task.CANNOT_COMPLETE=='Y'){
                                        if(task.TASK_STATUS!='COM'){
                                            data['CAN_COMPLETE']=false
                                        }
                                    }
                                }
                            }else if(dependencyTasks.sIdArray.length>0){
                                data['CAN_START']=true
                                data['CAN_COMPLETE']=true
                            }
                            let lookupAction = [{
                                "LOOKUP_CODE": data.TASK_STATUS_TYPE_CODE,
                                "DISPLAY_VALUE": data.DISPLAY_VALUE
                            }]
                            let lookup = await dbOperations.executeQuery(mysqlQueries.getLookupStatus, ['PROJECT_STATUS', body.tenantId], loggedUser, "getLookupStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                            if (lookup != undefined && lookup != null && lookup.length > 0) {
                                let index = lookup.findIndex(x => x.LOOKUP_CODE === "CLOSED")
                                lookup[index].DISPLAY_VALUE = "Close";
                                index = lookup.findIndex(x => x.LOOKUP_CODE === "COM")
                                lookup[index].DISPLAY_VALUE = "Complete";
                                let lookupArr;
                                if (data.TASK_STATUS_TYPE_CODE == "OPEN" && (data.CREATED_BY == body.loggedUserId || data.ASSIGNED_TO == body.loggedUserId || data.ASSIGNED_BY == body.loggedUserId || data.PROJECT_OWNERS.includes(body.loggedUserId))) {
                                    let index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                    lookup[index].DISPLAY_VALUE = "In Progress";
                                     lookupArr = ['IP', 'COM', "CLOSED"]
                                  
                                    lookupAction = lookupAction.concat(lookup.filter(x => lookupArr.includes(x.LOOKUP_CODE)))
                                } else if (data.TASK_STATUS_TYPE_CODE == "IP" && (data.CREATED_BY == body.loggedUserId || data.ASSIGNED_TO == body.loggedUserId || data.ASSIGNED_BY == body.loggedUserId || data.PROJECT_OWNERS.includes(body.loggedUserId))) {
                                    
                                    lookupAction = lookupAction.concat(lookup.filter(x => ['HOLD', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                                } else if (data.TASK_STATUS_TYPE_CODE == "HOLD" && (data.CREATED_BY == body.loggedUserId || data.ASSIGNED_TO == body.loggedUserId || data.ASSIGNED_BY == body.loggedUserId || data.PROJECT_OWNERS.includes(body.loggedUserId))) {
                                    let index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                    lookup[index].DISPLAY_VALUE = "In Progress";
                                    lookupAction = lookupAction.concat(lookup.filter(x => ['IP', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                                }
                            }
                            if(data['CAN_START']==false){
                                let index = lookupAction.findIndex(x => x.LOOKUP_CODE == "IP")
                                if(index!=null && index !=undefined && index>=0){
                                    lookupAction.splice(index, 1)
                                }
                                index = lookupAction.findIndex(x => x.LOOKUP_CODE == "COM")
                                if(index!=null && index !=undefined && index>=0){
                                    lookupAction.splice(index, 1)
                                }
                                index = lookupAction.findIndex(x => x.LOOKUP_CODE == "CLOSED")
                                if(index!=null && index !=undefined && index>=0){
                                    lookupAction.splice(index, 1)
                                }

                            }
                            if(data['CAN_COMPLETE']==false){
                                let index = lookupAction.findIndex(x => x.LOOKUP_CODE === "COM")
                                if(index!=null && index !=undefined && index>=0){
                                    lookupAction.splice(index, 1)
                                }
                                index = lookupAction.findIndex(x => x.LOOKUP_CODE === "CLOSED")
                                if(index!=null && index !=undefined && index>=0){
                                    lookupAction.splice(index, 1)
                                }
                            }
                            //lookupAction=lookupAction.filter(x => ['IP', 'COM', "CLOSED"].includes(x.LOOKUP_CODE))
                            data["LOOKUP_ACTION"] = lookupAction
                            }
                            
                            let res = result.reduce((hash, obj) => ({ ...hash, [obj["GROUP_ID"]]: (hash[obj["GROUP_ID"]] || []).concat(obj) }), {})
                            for (let item in res) {
                                let value = result.find(data => data.GROUP_ID == item)
                                let groupName
                                if (value == null) {
                                    groupName = 'General'
                                } else {
                                    groupName = value.GROUP_NAME
                                }
                                currencyCode = value.CURRENCY_CODE
                                maxAmt = value.GROUP_MAX_AMT
                                minAmt = value.GROUP_MIN_AMT
                                isMilstoneMapped = (res[item].filter(data => data.ADDED_TO_MILESTONE == 'true').length > 0) ? true : false;
                                isReccursive = (res[item].filter(data => data.IS_RECURRING == 'true').length > 0) ? true : false;
                                let obj = {
                                    'GROUP_ID': item,'GROUP_ORDER':value.GROUP_ORDER, 'GROUP_NAME': groupName, 'GROUP_STATUS': value.GROUP_STATUS,
                                    'GROUP_START_DATE': value.START_DATE, 'GROUP_END_DATE': value.END_DATE,
                                    IS_MILESTONE_MAPPED: isMilstoneMapped, IS_RECURSIVE: isReccursive,
                                    CURRENCY_CODE: currencyCode, MAX_AMT: maxAmt, MIN_AMT: minAmt, 'TASK': res[item]
                                }
                                response.push(obj)
                            }

                            appLogger.logMessage("info", "Task fetched   successfully", className, "getMainTasks", "SELF", "SELF_TENANT");
                            out.status = "Success";
                            out.message = "Task fetched successfully";
                            out.data = response
                            out.statusCode = 200
                        } else {
                            appLogger.logMessage("info", "Failed to fetch tasks", className, "holdOrResume", "SELF", "SELF_TENANT");
                            out.status = "Warning";
                            out.message = "No task available";
                            out.data = []
                            out.statusCode = 404
                        }
                    } else {
                        appLogger.logMessage("info", "Failed to get main task", className, "getMainTasks", "SELF", "SELF_TENANT");
                        out.status = "Warning";
                        out.message = "Failed to fetch tasks";
                        out.data = []
                        out.statusCode = 404
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to get main task due to invalid request body", className, "holdOrResume", "SELF", "SELF_TENANT");
                out.status = "Failed";
                out.message = "Invalid request body";
                out.statusCode = 404
                out.data = []
            }

        } catch (error) {
            appLogger.logMessage("error", "Failed to get MainTasks due to: " + JSON.stringify(error.message), className, "getMainTasks", req.body.loggedUser, req.body.tenant);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "getMainTasks", startDateTime, endDateTime, diffInMS);
        return out;
    },
    getSubTasks: async function (req) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully fetch sub task",
            data: [],
            statusCode:200
        }
        try {
            let body = req.body;
            let loggedUser = body.loggedUser
            let tenant = body.tenant
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getSubTasks);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to fetch sub task due to missing parameters: " + JSON.stringify(missingParams), className, "getSubTasks", body.loggedUser, body.tenant);
                    out.status = "Failed";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    let query = mysqlQueries.getSubTasks;
                    let param = [req.body.taskId, req.body.tenantId];
                    let result = await dbOperations.executeQuery(query, param, loggedUser, "getSubTasks", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != 'Error') {
                    let lookup = await dbOperations.executeQuery(mysqlQueries.getLookupStatus, ['PROJECT_STATUS', body.tenantId], loggedUser, "getLookupStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                        if (result.length > 0) {
                             for (let data of result) {
                                let assignee = []
                                assignee.push({ 'ID': data.ASSIGNED_TO, 'FULL_NAME': data.ASSIGNED_TO_NAME, 'ROLE_NAME': data.ROLE_NAME || 'EMPLOYEE' })
                                data['ASSIGNEE'] = assignee
                                let dueDate = moment(data.ESTIMATED_COMPLETION_DATE).format("YYYY-MM-DD");
                                let currentDate = moment().format("YYYY-MM-DD");
                                let diff = moment(currentDate).diff(moment(dueDate), 'days');
                                data["DUE_IN"] = diff;

                                let lookupAction = [{
                                    "LOOKUP_CODE": data.TASK_STATUS_TYPE_CODE,
                                    "DISPLAY_VALUE": data.DISPLAY_VALUE
                                }]
                                if (lookup != undefined && lookup != null && lookup.length > 0) {
                                    let index = lookup.findIndex(x => x.LOOKUP_CODE === "CLOSED")
                                    lookup[index].DISPLAY_VALUE = "Close";
                                    index = lookup.findIndex(x => x.LOOKUP_CODE === "COM")
                                    lookup[index].DISPLAY_VALUE = "Complete";
                                    if (data.TASK_STATUS_TYPE_CODE == "OPEN") {
                                        let index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                        lookup[index].DISPLAY_VALUE = "In Progress";
                                        lookupAction = lookupAction.concat(lookup.filter(x => ['IP', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                                    } else if (data.TASK_STATUS_TYPE_CODE == "IP") {
                                        lookupAction = lookupAction.concat(lookup.filter(x => ['HOLD', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                                    } else if (data.TASK_STATUS_TYPE_CODE == "HOLD") {
                                        let index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                        lookup[index].DISPLAY_VALUE = "In Progress";
                                        lookupAction = lookupAction.concat(lookup.filter(x => ['IP', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                                    }
                                }
                                data["LOOKUP_ACTION"] = lookupAction 
                            }
                            appLogger.logMessage("info", " Subtask fetched   successfully", className, "getSubTasks", body.loggedUser, body.tenant);
                            out.status = "Success";
                            out.message = "Subtask fetched successfully";
                            out.data = result
                            out.statusCode = 200
                        } else {
                            appLogger.logMessage("info", "Failed to fetch sub tasks", className, "getSubTasks", body.loggedUser, body.tenant);
                            out.status = "Warning";
                            out.message = "No sub task available";
                            out.data = []
                            out.statusCode = 404
                        }
                    } else {
                        appLogger.logMessage("info", "Failed to fetch  sub tasks", className, "getSubTasks", body.loggedUser, body.tenant);
                        out.status = "Warning";
                        out.message = "Failed to fetch sub tasks";
                        out.data = []
                        out.statusCode = 404
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to fetch subtask due to invalid request body", className, "holdOrResume", body.loggedUser, body.tenant);
                out.status = "Failed";
                out.message = "Invalid request body";
                out.statusCode = 404
                out.data = []
            }

        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch subtask: " + JSON.stringify(error.message), className, "holdOrResume", req.body.loggedUser, req.body.tenant);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "holdOrResume", startDateTime, endDateTime, diffInMS);
        return out;
    },
    createSubTask: async function (req) {
        appLogger.logMessage("debug", "createSubTask function called with the payload: " + JSON.stringify(req.body), className, "createSubTask", req.body.loggedUser, req.body.tenant);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            type: "Success",
            message: "Successfully created new Sub Task",
            data: {}
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.createSubTask);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to create new project due to missing parameters: " + JSON.stringify(missingParams), className, "createSubTask", body.loggedUser, body.tenant);
                    out.type = "Failed";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    let formatedProjectName = await validationHandler.validateString(body.subTaskName, body.loggedUser, body.tenant, appLogger, meteringLogger, moduleName);
                    body.subTaskName = formatedProjectName;
                    let isExists = await supportHandler.isSubTaskNameExists(body.subTaskName, body.taskId, body.loggedUser, body.tenant);
                    if (isExists != null) {
                        if (isExists == 0) {
                            let query = mysqlQueries.createSubTask;
                            let param = [
                                body.tenantId,
                                body.taskId,
                                body.subTaskName,
                                body.subTaskDescription,
                                body.taskStatusTypeCode,
                                body.priorityTypeCode,
                                body.canContinue,
                                body.orderOfExecution,
                                body.isAutomated,
                                body.estimatedStartDate,
                                body.estimatedCompletionDate,
                                body.estimatedEffort
                            ];
                            let result = await dbOperations.executeQuery(query, param, body.loggedUser, "createSubTask", true, [5, 14, 15], body.tenant, appLogger, meteringLogger, moduleName);
                            if (result) {
                                if (result.affectedRows == 0) {
                                    appLogger.logMessage("debug", "Failed to insert into sub task table. result received after executing the query: " + JSON.stringify(result), className, "createSubTask", body.loggedUser, body.tenant);
                                    out.type = "Failed";
                                    out.message = "Failed to create new sub task due to internal error";
                                }
                            }
                        } else {
                            out.type = "Warning";
                            out.message = "Sub Task name already exists";
                        }

                    } else {
                        out.type = "Failure";
                        out.message = "Failed to create sub task";
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to create new project due to invalid request body", className, "createSubTask", "USER", req.body.tenant);
                out.status = "Failure";
                out.message = "Failed to create new sub task due to invalid request body";
            }
        } catch (error) {
            appLogger.logMessage("error", "Failed to create new project due to: " + JSON.stringify(error.message), className, "createSubTask", req.body.loggedUser, req.body.tenant);
            out.type = "Failure";
            out.message = "Internal Server Error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "createSubTask", startDateTime, endDateTime, diffInMS);
        return out;
    },
    getProjectsAssigned: async function (payload, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMSServices", "getProjectsAssigned", loggedUser, tenant, moduleName);
        formattedResult = [];
        let result;
        try {
            let projectData = await dbOperations.executeQuery(mysqlQueries.getProjectsAssigned, [payload.loggedUserId, payload.tenantId], loggedUser, "getProjectsAssigned", false, null, tenant, appLogger, meteringLogger, moduleName);
            if (projectData != null && projectData != undefined && projectData.length > 0) {
                result = await responseHandler.sendResponse('Success', "Data fetched successfully.", 200, projectData, false, "getProjectsAssigned", tenant, loggedUser, moduleName, appLogger, meteringLogger)
            } else {
                result = await responseHandler.sendResponse('Warning', "No data found.", 400, [], false, "getProjectsAssigned", tenant, loggedUser, moduleName, appLogger, meteringLogger)
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMSServices", "getProjectsAssigned", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMSServices", "getProjectsAssigned", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMSServices", "getProjectsAssigned", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getProjectsAssigned", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getEmployeeProjectTasks: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("debug", "getEmployeeProjectTasks called", className, "getEmployeeProjectTasks", loggedUser, tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully fetched tasks",
            data: {},
            statusCode: 200
        }
        try {
            let body = req.body;
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getEmployeeProjectTasks);

            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Missing parameters: " + JSON.stringify(missingParams), className, "getEmployeeProjectTasks", loggedUser, tenant, moduleName);
                out.status = "warning"
                out.message = "Missing parameters: " + JSON.stringify(missingParams)
                out.statusCode = 404
            } else {
                let query;
                let param = [];
                if (String(body.role).toLowerCase() == "employee") {
                    param = [body.projectId, body.tenantId, body.userId, [["COM", "IP", "OPEN", "HOLD", "NS"]]];
                    query = mysqlQueries.getEmployeeProjectTasks;
                } else {
                    appLogger.logMessage("debug", "Invalid role received: " + body.role + " Expected role is: Employee ", className, "getEmployeeProjectTasks", loggedUser, tenant, moduleName);
                    out.status = "Failed";
                    out.message = "Invalid role received: " + body.role + ". Expected role is employee";
                    return out;
                }
                let result = await dbOperations.executeQuery(query, param, loggedUser, "getEmployeeProjectTasks", false, null, tenant, appLogger, meteringLogger, moduleName);
                appLogger.logMessage("debug", "Data recieved after fetching tasks by status: " + JSON.stringify(result), className, "getEmployeeProjectTasks", loggedUser, tenant, moduleName);
                if (result) {
                    let completedTasks = [];
                    let inProgressTasks = [];
                    let openTasks = [];
                    let holdTasks = [];
                    let notStartedTasks = [];
                    for (let row of result) {
                        let image = null;
                        let dueDate = moment(row.DUE_DATE).format("YYYY-MM-DD");
                        let currentDate = moment().format("YYYY-MM-DD");
                        let diff = moment(currentDate).diff(moment(dueDate), 'days');
                        row["DUE_IN"] = diff;
                        if (row.EMPLOYEE_NUMBER != null && row.EMPLOYEE_NUMBER != undefined) {
                            let key = String(req.body.tenant).toUpperCase() + "_" + row.EMPLOYEE_NUMBER;
                            image = await ImageHandler.fetchPhoto(req.body.tenantType, key, row.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                            row["IMAGE"] = image || null;
                        } else {
                            row["IMAGE"] = null;
                        }
                        if (row.TASK_STATUS_TYPE_CODE == "IP") {
                            inProgressTasks.push(row);
                        } else if (row.TASK_STATUS_TYPE_CODE == "COM") {
                            completedTasks.push(row);
                        } else if (row.TASK_STATUS_TYPE_CODE == "OPEN") {
                            openTasks.push(row);
                        } else if (row.TASK_STATUS_TYPE_CODE == "NS") {
                            notStartedTasks.push(row);
                        } else if (row.TASK_STATUS_TYPE_CODE == "HOLD") {
                            holdTasks.push(row);
                        }
                    }
                    inProgressTasks.sort((a, b) => {
                        return b.DUE_IN - a.DUE_IN;
                    });
                    notStartedTasks.sort((a, b) => {
                        return b.DUE_IN - a.DUE_IN;
                    });
                    openTasks.sort((a, b) => {
                        return b.DUE_IN - a.DUE_IN;
                    });
                    holdTasks.sort((a, b) => {
                        return b.DUE_IN - a.DUE_IN;
                    });
                    out.data["COM"] = completedTasks;
                    out.data["IP"] = inProgressTasks;
                    out.data["OPEN"] = openTasks;
                    out.data["HOLD"] = holdTasks;
                    out.data["NS"] = notStartedTasks;
                } else {
                    appLogger.logMessage("debug", "Failed to fetch tasks due to internal server error", className, "getEmployeeProjectTasks", loggedUser, tenant, moduleName);
                    out.status = "Failed";
                    out.statusCode = 500;
                    out.message = "Invalid data received from the server";
                }

            }
        } catch (error) {
            out.status = "Failed";
            out.message = "Internal server error";
            out.statusCode = 500;
            out.data = JSON.stringify(error.message);
            appLogger.logMessage("error", "Failed to fetch tasks based on status code due to: " + JSON.stringify(error.message), className, "getEmployeeProjectTasks", loggedUser, tenant, moduleName);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(tenant, loggedUser, className, "getEmployeeProjectTasks", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },
    getTodoList: async function (req) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getTodoList function invoked", className, "getTodoList", req.body.userEmail, req.body.tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully fetched todoLists",
            data: []
        }
        try {
            let body = req.body;
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getTodoList);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("error", "Failed to fetch task due to missing parameters: " + JSON.stringify(missingParams), className, "getTodoList", body.userEmail, body.tenant, moduleName);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
            } else {
                let email = body.userEmail;
                let loadAllProjectTasks = body.loadAllProjectTasks;
                let projectId;
                if (!loadAllProjectTasks) {
                    projectId = body.projectId;
                }
                let statuses = body.statuses;
                if (Array.isArray(statuses)) {
                    if (statuses.length > 0) {
                        let searchConditions = body.searchConditions;
                        if (searchConditions == undefined) {
                            searchConditions = [];
                        }
                        if (Array.isArray(searchConditions)) {
                            if (searchConditions.length > 0) {
                                out = await PMSSupport.getTasks(body.userEmail, body.tenant, projectId, statuses, searchConditions);
                            } else {
                                //fetch todo list based on just statuses
                                out = await PMSSupport.getTasks(body.userEmail, body.tenant, projectId, statuses);
                            }
                        } else {
                            appLogger.logMessage("debug", "Failed to fetch todolist due to invalid criteria", className, "getTodoList", email, body.tenant, moduleName);
                            out.status = "Failed";
                            out.message = "Failed to fetch todoList due to invalid criteria received";
                        }
                    } else {
                        out.status = "Failed";
                        out.message = "Minimum one status field is required";
                        appLogger.logMessage("debug", "Failed to fetch todo list due to no status input recieved", className, "getTodoList", email, body.tenant, moduleName);
                    }
                } else {
                    out.status = "Failed";
                    out.message = "Invalid parameter statuses";
                    appLogger.logMessage("debug", "Invalid parameter(statuses) received", className, "getTodoList", email, body.tenant, moduleName);
                }
            }
        } catch (error) {
            out.status = "Failed";
            out.message = "Failed to fetch todoList due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", "Failed to fetch todo list due to: " + JSON.stringify(error.message), className, "getTodoList", req.body.userEmail, req.body.tenant, moduleName);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "getTodoList", startDateTime, endDateTime, diffInMS);
        return out;
    },
    updateStatus: async function (req) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully updated task status"
        }
        try {
            let body = req.body;
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.updateStatus);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("error", "Failed to fetch task due to missing parameters: " + JSON.stringify(missingParams), className, "updateStatus", body.userEmail, body.tenant, moduleName);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
            } else {
                let res;
                if (String(req.body.taskStatus).toLowerCase() == "com") {
                    res = await dbOperations.executeQuery(mysqlQueries.completeTask, [100,moment().format('YYYY-MM-D'), req.body.loggedUserId,req.body.subStatus, req.body.tenantId, req.body.projectId, req.body.taskId], req.body.loggedUser, "completeTask", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                } else if (String(req.body.taskStatus).toLowerCase() == "ip") {
                    res = await dbOperations.executeQuery(mysqlQueries.startTask, [req.body.taskStatus, req.body.loggedUserId, moment().format('YYYY-MM-DD'), req.body.taskId], req.body.loggedUser, "updateTaskStatus", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                } else if (String(req.body.taskStatus).toLowerCase() == "hold" || String(req.body.taskStatus).toLowerCase() == "resume") {
                    res = await dbOperations.executeQuery(mysqlQueries.holdTask, [req.body.taskStatus, req.body.taskId], req.body.loggedUser, "holdTask", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                }
                if (res) {
                    if (res.affectedRows > 0) {
                        if (req.body.isFromWhatsApp) {
                            appLogger.logMessage("debug", "Successfully updated task status with type code: " + req.body.taskStatus, className, "updateStatus", req.body.loggedUser, req.body.tenant, moduleName);
                        } else {
                            let groupResult = await supportHandler.setStartDateEndDateOfGroup(groupId, body.projectId, body.tenantId, body.loggedUserId, body.loggedUser, body.tenant)
                            if (groupResult) {
                                appLogger.logMessage("info", "Group start date and end date are updated ", className, "createTask", loggedUser, tenant, moduleName);
                            } else {
                                appLogger.logMessage("info", "Failed to update start date and end date of group ", className, "createTask", loggedUser, tenant, moduleName);
                            }
                            appLogger.logMessage("debug", "Successfully updated task status with type code: " + req.body.taskStatus, className, "updateStatus", req.body.loggedUser, req.body.tenant, moduleName);

                        }
                    } else {
                        out.status = "Failed";
                        out.message = "Task status is already updated!"
                        appLogger.logMessage("debug", "failed to update task status due to the status is already updated", className, "updateStatus", req.body.loggedUser, req.body.tenant, moduleName);
                    }
                } else {
                    out.status = "Failed";
                    out.message = "Failed to update task status due to internal error";
                    appLogger.logMessage("debug", "Failed to update task status due to invalid response from the server", className, "updateStatus", req.body.loggedUser, req.body.tenant, moduleName);
                }



            }
        } catch (error) {
            out.status = "Failed";
            out.message = "Failed to update task status from whatsapp due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", "Failed to update whatsapp status due to: " + JSON.stringify(error.message), className, "updateStatus", req.body.userEmail, req.body.tenant, moduleName);
        }

        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "updateStatus", startDateTime, endDateTime, diffInMS);
        return out;
    },

    //GET WORK LOG  BASED ON TASK
    getTaskWorkLog: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        let body = req.body;
        let out = {
            "status": "Success",
            "message": "Successfully  fetch work log"
        }
        try {
            appLogger.logMessage("debug", "getTaskWorkLog function started with payload" + JSON.stringify(body), className, "getTaskWorkLog", body.loggedUser, body.tenant, moduleName);
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getTaskWorkLog);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to  get work log due to missing parameters: " + JSON.stringify(missingParams), className, "getTaskWorkLog", body.loggedUser, body.tenant, moduleName);
                out.status = "Warning";
                out.message = "Failed to  get work log due to missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 404;
            } else {
                let query = mysqlQueries.getTaskWorkLog;
                let param = [
                    body.taskId,
                    body.tenantId,
                ]
                result = await dbOperations.executeQuery(query, param, loggedUser, "getTaskWorkLog", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        let sumHour = 0, actionId = "", idArray = []
                        for (let member of result) {
                            let key = String(tenant).toUpperCase() + "_" + member.EMPLOYEE_NUMBER;
                            image = await ImageHandler.fetchPhoto(body.tenantType, key, member.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                            member["IMAGE"] = image || null;
                            image = null;
                            sumHour = sumHour + member.HOURS
                            //idArray.push(member.ID)

                        }

                        actionId = body.taskId.toString()
                        let payload = { 'actionId': actionId }
                        let attachmentResult = await this.getAttachmentsByActionId(payload, body.loggedUser, body.tenant)
                        for (let data of result) {
                            let id = data.ID
                            let attachmentArray = []

                            for (let x of attachmentResult.data) {
                                if (x.ACTION_ID == id) {
                                    attachmentArray.push(x)
                                }
                            }
                            data['ATTACHMENTS'] = attachmentArray

                        }
                        appLogger.logMessage("debug", "Work log fetched successfully", className, "getTaskWorkLog", body.loggedUser, body.tenant, moduleName);
                        out.status = "Success";
                        out.message = "Work log fetched successfully";
                        out.statusCode = 200;
                        out.data = [{ 'data': result, 'hours': sumHour }]
                    } else {
                        appLogger.logMessage("debug", "Failed to fetch work log due to " + JSON.stringify(result), className, "getTaskWorkLog", body.loggedUser, body.tenant, moduleName);
                        out.status = "Warning";
                        out.message = "Failed to fetch work log due  to " + JSON.stringify(result);
                        out.statusCode = 404;
                    }
                } else {
                    appLogger.logMessage("debug", "Failed fetch work log due  to " + JSON.stringify(result), className, "getTaskWorkLog", body.loggedUser, body.tenant, moduleName);
                    out.status = "Warning";
                    out.message = " Failed to fetch work log due to invalid response from the server";
                    out.statusCode = 404;
                }
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, className, "getTaskWorkLog", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, className, "getTaskWorkLog", body.loggedUser, body.tenant, moduleName);
            out.status = "Failure";
            out.message = " Internal server error" + e.message;
            out.statusCode = 500;
        }
        appLogger.logMessage("info", "getTaskWorkLog is finished and the result is returnd ", className, "getTaskWorkLog", body.loggedUser, body.tenant, moduleName);
        return out;
    },


    // REMOVE TEAM MEMBERS FROM THE  PROJECT TEAM
    removeTeamMembers: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        let body = req.body;
        let out = {
            "status": "Success",
            "message": "Successfully  removed team members"
        }
        try {
            appLogger.logMessage("debug", "removeTeamMembers function started with payload" + JSON.stringify(body), className, "removeTeamMembers", body.loggedUser, body.tenant, moduleName);
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.removeTeamMembers);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to  remove team members due to missing parameters: " + JSON.stringify(missingParams), className, "removeTeamMembers", body.loggedUser, body.tenant, moduleName);
                out.status = "Warning";
                out.message = "Failed to remove team members due to missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 404;
            } else {

                // check whether the team member is assigned to any task . If so,  give warning 
                // else end dated the project_team table row
                let query = mysqlQueries.isTaskAssignedToMember;
                let param = [
                    body.projectId,
                    body.userId,
                    body.tenantId,
                ]
                result = await dbOperations.executeQuery(query, param, loggedUser, "removeTeamMembers", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("debug", "Cannot remove member from this project as tasks are assigned to/completed by them", className, "removeTeamMembers", body.loggedUser, body.tenant, moduleName);
                        out.status = "Warning";
                        out.message = "Task assigned to the employee. Cannot remove employee  from project team";
                        out.statusCode = 404;
                        out.data = []

                    } else {
                        let query = mysqlQueries.removeFromProjectTeam;
                        let param = [
                            body.projectId,
                            body.userId,

                            body.tenantId,
                        ]
                        result = await dbOperations.executeQuery(query, param, loggedUser, "removeTeamMembers", false, null, tenant, appLogger, meteringLogger, moduleName);
                        if (result != undefined && result != null && result != 'Error') {
                            if (result.affectedRows > 0) {
                                appLogger.logMessage("debug", "Successfully removed  member from the team", className, "removeTeamMembers", body.loggedUser, body.tenant, moduleName);
                                out.status = "Success";
                                out.message = "Successfully removed  member from the team";
                                out.statusCode = 200;
                                out.data = []
                            } else {
                                appLogger.logMessage("debug", "Failed to remove member from team " + JSON.stringify(result), className, "getTaskWorkLog", body.loggedUser, body.tenant, moduleName);
                                out.status = "Warning";
                                out.message = "Failed to remove member from team " + JSON.stringify(result);
                                out.statusCode = 404;
                            }
                        } else {
                            appLogger.logMessage("debug", "Failed to remove member from team " + JSON.stringify(result), className, "getTaskWorkLog", body.loggedUser, body.tenant, moduleName);
                            out.status = "Warning";
                            out.message = "Failed to remove member from team " + JSON.stringify(result);
                            out.statusCode = 404;
                        }
                    }
                } else {
                    appLogger.logMessage("debug", "Failed  check  task assigned dto the member due  to " + JSON.stringify(result), className, "removeTeamMembers", body.loggedUser, body.tenant, moduleName);
                    out.status = "Warning";
                    out.message = " Failed  check  task assigned dto the member due to invalid response from the server";
                    out.statusCode = 404;
                }
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, className, "removeTeamMembers", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, className, "removeTeamMembers", body.loggedUser, body.tenant, moduleName);
            out.status = "Failure";
            out.message = " Internal server error" + e.message;
            out.statusCode = 500;
        }
        appLogger.logMessage("info", "removeTeamMembers is finished and the result is returnd ", className, "removeTeamMembers", body.loggedUser, body.tenant, moduleName);
        return out;
    },
    getTeamProjects: async function (payload, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMSServices", "getTeamProjects", loggedUser, tenant, moduleName);
        let formattedResult = [];
        let result;
        let addedUser = [];
        try {
            let teamProjects = await dbOperations.executeQuery(mysqlQueries.getTeamProjects, [payload.tenantId], loggedUser, "getTeamProjects", false, null, tenant, appLogger, meteringLogger, moduleName);
            if (teamProjects != null && teamProjects != undefined && teamProjects.length > 0) {
                for (let data of teamProjects) {
                    if (!addedUser.includes(data.USER_ID)) {
                        addedUser.push(data.USER_ID)
                    }
                }
                for (let user of addedUser) {
                    let fullname, firstname, userId, empNumber, image, email, role, designation
                    let projects = []
                    for (let data of teamProjects) {

                        if (data.USER_ID == user) {
                            fullname = data.FULL_NAME;
                            firstname = data.FIRST_NAME;
                            userId = data.USER_ID;
                            empNumber = data.EMPLOYEE_NUMBER;
                            email = data.EMAIL
                            role = data.ROLE
                            designation = data.DESIGNATION

                            projects.push({
                                "PROJECT_ID": data.PROJECT_ID,
                                "PROJECT_NAME": data.PROJECT_NAME,
                                "PROJECT_DESCRIPTION": data.PROJECT_DESCRIPTION,
                                "ACTUAL_START_DATE": data.ACTUAL_START_DATE,
                                "ACTUAL_COMPLETION_DATE": data.ACTUAL_COMPLETION_DATE,
                                "AVAILABLE_IN": Math.abs(data.AVAILABLE_IN),
                                'ROLE': data.ROLE,
                                'TOTAL_DAYS': Math.ceil(data.HOURS ? data.HOURS / 8 : 0),
                                'ESTIMATED_START_DATE': data.ESTIMATED_START_DATE,
                                'ESTIMATED_COMPLETION_DATE': data.ESTIMATED_COMPLETION_DATE,
                                'PROJECT_TYPE_CODE': data.PROJECT_TYPE_CODE,
                                'PROJECT_STATUS_TYPE_CODE': data.PROJECT_STATUS_TYPE_CODE,
                                'CREATION_DATE': data.CREATION_DATE,
                                'LAST_UPDATED_DATE': data.LAST_UPDATED_DATE,
                                'ROLE_CODE': data.ROLE_CODE,
                                'DISPLAY_VALUE': 'In Progress',
                                'PROJECT_OWNERS': data.ROLE_CODE,
                                'ACTIVE_TASK': data.ACTIVE_TASK,
                                'TASK_COMPLETED': data.TASK_COMPLETED,
                                'COMPLETION_PERCENTAGE': (data.ACTIVE_TASK == 0) ? 0 : ((data.TASK_COMPLETED / data.ACTIVE_TASK) * 100).toFixed(2)
                            })


                        }
                    }
                    let key = String(payload.tenant).toUpperCase() + "_" + empNumber;
                    image = await ImageHandler.fetchPhoto(payload.tenantType, key, email, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                    formattedResult.push({
                        'FULL_NAME': fullname,
                        'FIRSTNAME': firstname,
                        'ID': userId,
                        'EMPLOYEE_NUMBER': empNumber,
                        'EMAIL': email,
                        'DESIGNATION': designation,
                        'IMAGE': image,
                        "PROJECTS": projects,

                    })
                }
                result = await responseHandler.sendResponse('Success', "Data fetched successfully.", 200, formattedResult, false, "getTeamProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger)
            } else {
                result = await responseHandler.sendResponse('Warning', "No data found.", 400, [], false, "getTeamProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger)
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMSServices", "getTeamProjects", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMSServices", "getTeamProjects", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMSServices", "getTeamProjects", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getTeamProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getAttachmentsByActionId: async function (payload, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMSServices", "getAttachmentsByActionId", loggedUser, tenant, moduleName);
        let result;
        try {
            if (payload.actionId != null && payload.actionId != undefined) {
                let actionId = [];
                actionId = payload.actionId.split(",")
                let attachmentsData = await dbOperations.executeQuery(mysqlQueries.getAttachments, [actionId, actionId], loggedUser, "getAttachmentsByActionId", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (attachmentsData != null && attachmentsData != undefined && attachmentsData.length > 0) {
                    for (let data of attachmentsData) {
                        for (let action of configData.attachmentTypes) {
                            if (action.hasOwnProperty(data.ACTION_CODE)) {
                                data['ACTION'] = action[data.ACTION_CODE]
                                data['FILE_TYPE'] = data.FILE_NAME.split('.').pop();
                            }
                        }
                    }
                    result = await responseHandler.sendResponse('Success', "Attachment found acuucesfully.", 200, attachmentsData, false, "getAttachmentsByActionId", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                } else {
                    result = await responseHandler.sendResponse('Warning', "No data found.", 400, [], false, "getAttachmentsByActionId", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getAttachmentsByActionId", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMSServices", "getAttachmentsByActionId", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMSServices", "getAttachmentsByActionId", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMSServices", "getAttachmentsByActionId", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getAttachmentsByActionId", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getTaskAttachments: async function (payload, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMSServices", "getTaskAttachments", loggedUser, tenant, moduleName);
        let result;
        try {
            if (payload.actionId != null && payload.actionId != undefined) {
                let actionId = [];
                actionId = payload.actionId.split(",")
                let attachmentsData = await dbOperations.executeQuery(mysqlQueries.getTaskAttachments, [actionId, payload.actionCode], loggedUser, "getTaskAttachments", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (attachmentsData != null && attachmentsData != undefined && attachmentsData.length > 0) {
                    for (let data of attachmentsData) {
                        for (let action of configData.attachmentTypes) {
                            if (action.hasOwnProperty(data.ACTION_CODE)) {
                                data['ACTION'] = action[data.ACTION_CODE]
                                data['FILE_TYPE'] = data.FILE_NAME.split('.').pop();


                            }
                        }

                    }


                    result = await responseHandler.sendResponse('Success', "Attachment found acuucesfully.", 200, attachmentsData, false, "getTaskAttachments", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                } else {
                    result = await responseHandler.sendResponse('Warning', "No data found.", 400, [], false, "getTaskAttachments", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getTaskAttachments", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMSServices", "getTaskAttachments", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMSServices", "getTaskAttachments", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMSServices", "getTaskAttachments", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getTaskAttachments", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //API TO FETCH TASK TO SHOW IN CRATING DEPENDANCY TASK
    getTaskForDependancy: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", " getTaskForDependancy Service initiated.", "PMSServices", "getTaskForDependancy", loggedUser, tenant, moduleName);
        let result;
        let finalArray = []
        let body = req.body
        try {

            let query = mysqlQueries.getTaskForDependancy;
            let param = [
                body.projectId,
                body.tenantId,
                body.taskId
            ]

            let resultData = await dbOperations.executeQuery(query, param, loggedUser, "getTaskForDependancy", false, null, tenant, appLogger, meteringLogger, moduleName);
            if (resultData != undefined && resultData != null && resultData != 'Error') {
                if (resultData.length > 0) {
                    appLogger.logMessage("info", "Task fetched successfully", "PMSServices", "getTaskForDependancy", loggedUser, tenant, moduleName, moduleName);

                    let query = mysqlQueries.isDependencyExist;
                    let param = [
                        body.taskId,
                        body.tenantId
                    ]
                    let result1 = await dbOperations.executeQuery(query, param, loggedUser, "getTaskForDependancy", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result1 != undefined && result1 != null && result1 != 'Error') {
                        let i = 0
                        for (let x of resultData) {

                            for (let y of result1) {
                                if (x.TASK_ID == y.PREDECESSOR_TASK_ID || x.TASK_ID == y.SUCCESSOR_TASK_ID) {
                                    x['existFlag'] = true
                                    break
                                }
                            }

                        }

                        for (let data of resultData) {
                            if (data.existFlag != true) {
                                finalArray.push(data)
                            }
                        }
                        if (finalArray.length > 0) {
                            result = await responseHandler.sendResponse("Success", "Task fetched successfully", 200, finalArray, true, "getTaskForDependancy", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                        } else {
                            result = await responseHandler.sendResponse("Warning", "No task available", 400, finalArray, true, "getTaskForDependancy", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                        }
                    }


                } else {
                    appLogger.logMessage("info", "No task available", "PMSServices", "getTaskForDependancy", loggedUser, tenant, moduleName, moduleName);
                    result = await responseHandler.sendResponse("Warning", "No task available", 400, null, false, "getTaskForDependancy", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                }
            } else {
                appLogger.logMessage("info", "Failed to fetch task.", "PMSServices", "getTaskForDependancy", loggedUser, tenant, moduleName, moduleName);
                result = await responseHandler.sendResponse("Warning", "Failed to fetch task", 400, null, false, "getTaskForDependancy", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMSServices", "getTaskForDependancy", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", " getTaskForDependancy Service completed.", "PMSServices", "getTaskForDependancy", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMSServices", "getTaskForDependancy", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getTaskForDependancy", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //CREATE DEPENDENCY TASK
    createDependencyTask: async function (req, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", " createDependencyTask Service initiated.", "PMSServices", "createDependencyTask", loggedUser, tenant, moduleName);
        let result;
        let body = req.body
        try {
            let query;
            let param = [];
            if(body.dependencySchedule.toUpperCase()=='CS'){
                query=mysqlQueries.createCannotStartDependency
                
                
            }else if(body.dependencySchedule.toUpperCase()=='CC'){
                query=mysqlQueries.createCannotCompleteDependency
            }
            taskIdToUpdate=[]
            let dependencyTaskarray = JSON.parse(body.dependencyTaskarray)
            
            if (body.isPredecessor == 'true') {
               //  t1 is the predecessor of t3 and dependency rule is cannot_start 
                // both reletion is inserted into the table   and set CANNOT_START='Y'
                // if t2 is the predecessor of t3 and depedency rule is cannot_complete
                //add both relation into the dependency table and set CANNOT_COMPLETE='Y'
                 // default value of cannot_start and cannot_complete is 'N'
                taskIdToUpdate.push(body.taskId)
                for (let data of dependencyTaskarray) {
                    let record = []
                    record.push(body.tenantId)
                    record.push(body.taskId)
                    record.push(data)
                    record.push(null)
                    record.push('Y')
                    record.push(body.effectiveStartDate)
                    record.push(body.effectiveEndDate)
                    record.push(body.loggedUserId)
                    record.push(body.loggedUserId)
                    param.push(record)
                    record = []
                }
                // this loop is to add revese dependency
                for (let data of dependencyTaskarray) {
                    let record = []
                    record.push(body.tenantId)
                    record.push(data)
                    record.push(null)
                    record.push(body.taskId)
                    record.push('Y')
                    record.push(body.effectiveStartDate)
                    record.push(body.effectiveEndDate)
                    record.push(body.loggedUserId)
                    record.push(body.loggedUserId)
                    param.push(record)
                    record = []
                }

            } else {
                // if t1 is the successor of t2 update the cannot_start and cannot_complete column of t2
                for (let data of dependencyTaskarray) {
                    taskIdToUpdate=dependencyTaskarray
                    let record = []
                    record.push(body.tenantId)
                    record.push(body.taskId)
                    record.push(null)
                    record.push(data)
                    record.push('Y')
                    record.push(body.effectiveStartDate)
                    record.push(body.effectiveEndDate)
                    record.push(body.loggedUserId)
                    record.push(body.loggedUserId)
                    param.push(record)
                    record = []
                }
                // this loop is to add revese dependency
                for (let data of dependencyTaskarray) {
                    let record = []
                    record.push(body.tenantId)
                    record.push(data)
                    record.push(body.taskId)
                    record.push(null)
                    record.push('Y')
                    record.push(body.effectiveStartDate)
                    record.push(body.effectiveEndDate)
                    record.push(body.loggedUserId)
                    record.push(body.loggedUserId)
                    param.push(record)
                    record = []
                }
            }
            result = await dbOperations.executeQuery(query, [param], loggedUser, "createDependencyTask", false, null, tenant, appLogger, meteringLogger, moduleName);
            if (result != undefined && result != null && result != 'Error') {
                if (result.affectedRows > 0) {
                    result = await responseHandler.sendResponse("Success", "Dependency  created successfully.", 200, result, true, "createDependencyTask", tenant, loggedUser, moduleName, appLogger, meteringLogger) 
                    if(body.addedToWatchList=='true'){
                        let nofifyResult=await supportHandler.watchListNotification(body,'task_dependency',body.loggedUser,body.tenant)
                        appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                    }
                    appLogger.logMessage("info", "Dependency task created successfully", "PMSServices", "createDependencyTask", loggedUser, tenant, moduleName, moduleName);
                    result = await responseHandler.sendResponse("Success", "Dependency task created successfully", 200, result, true, "createDependencyTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    appLogger.logMessage("info", "Failed to create dependency task", "PMSServices", "getTaskForDependancy", loggedUser, tenant, moduleName, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to create dependency task", 400, null, false, "createDependencyTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                }
            } else {
                appLogger.logMessage("info", "Failed to fetch task.", "PMSServices", "getTaskForDependancy", loggedUser, tenant, moduleName, moduleName);
                result = await responseHandler.sendResponse("Warning", "Failed to create dependency task", 400, null, false, "createDependencyTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            }


            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMSServices", "createDependencyTask", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", " createDependencyTask Service completed.", "PMSServices", "createDependencyTask", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMSServices", "createDependencyTask", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "createDependencyTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    removeProjectOwner: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "removeProjectOwner", loggedUser, tenant, moduleName);
        let result;
        try {

            if (data.userId != undefined && data.userId != null && data.projectId != undefined && data.projectId != null && data.mapTenantId != undefined && data.mapTenantId != null) {
                result = await dbOperations.executeQuery(mysqlQueries.updateProjectRole, ["ENG", null, data.userId, data.projectId], loggedUser, "updateProjectRole", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.affectedRows > 0) {
                    result = await responseHandler.sendResponse("Success", "Project owner removed successfully.", 200, null, false, "removeProjectOwner", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to remove project owner.", 400, null, false, "removeProjectOwner", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "removeProjectOwner", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "removeProjectOwner", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "removeProjectOwner", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "removeProjectOwner", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "removeProjectOwner", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    addIssue: async function (req, data, loggedUser, tenant, jtoken) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "addIssue", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.issueName != undefined && data.issueName != null && data.projectId != undefined && data.projectId != null) {
                Object.keys(data).forEach(k => data[k] = (data[k] === '' || data[k] === 'null' || data[k] === undefined) ? null : data[k])
                result = await dbOperations.executeQuery(mysqlQueries.checkIssueExists, [data.issueName.toUpperCase().trim()], loggedUser, "addIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.length == 0) {
                    if (data.isNewModule == "true") {
                        if (data.moduleName != undefined && data.moduleName != null) {
                            data.name = data.description = data.moduleName.trim();
                            data.moduleId = null;
                            result = await this.addModule(data, loggedUser, tenant);
                            if (result.type.toLowerCase() == "error") {
                                return result;
                            } else {
                                result = await dbOperations.executeQuery(mysqlQueries.getModuleIdByName, [data.name, data.projectId], loggedUser, "addIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                                if (result != undefined && result != null && result.length > 0) {
                                    data.moduleId = result[0].ID
                                }
                            }
                        } else {
                            data.moduleId = null;
                        }
                    }
                    let param = [data.tenantId, data.projectId, data.issueName, data.issueDescription, data.priority, data.severity, data.assignedTo, data.status, data.assigneeComment,
                        data.moduleId,data.tag||null]
                    result = await dbOperations.executeQuery(mysqlQueries.addIssue, param, loggedUser, "addIssue", true, [8, 11, 12], tenant, appLogger, meteringLogger, moduleName)
                    if (result != undefined && result != null && result.affectedRows > 0) {
                        let issueId = result.insertId
                        let body = {
                            token: data.token, jtoken: jtoken, loggedUser: data.loggedUser, tenant: data.tenant, tenantId: data.tenantId, loggedUserId: data.loggedUserId,
                            files: req.files, module: data.module, actionId: issueId, action: data.action, attachmentLength: data.attachmentLength, overwriteFile: data.overwriteFile, description: (data.fileDescription != null) ? data.fileDescription : ''
                        }
                        let res = await axios.post(configData.uploadFile.serviceUrl + configData.uploadFile.serviceApi, body);
                        if (data.assignedTo != null && data.assignedTo != undefined && data.assignedTo != 'null' && data.assignedTo != '') {                           
                            data['issueId'] = issueId;
                            data['assignedByName'] = data.createdByName;
                            data['moduleName'] = data.moduleName;
                            let assignissue = await this.assignIssue(data, loggedUser, tenant)
                            if (assignissue.type != 200) {
                                appLogger.logMessage("info", "Failed to assign issue to user", "PMService", "addIssue", loggedUser, tenant, moduleName, moduleName);
                            }
                        }
                        result = await responseHandler.sendResponse("Success", "Issue added successfully.", 200, result, true, "addIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        let notify = await supportHandler.notifyManagerForIssueCreation(null, req.body.loggedUserId, req.body.loggedUser, tenant, req.body.tenantId, 'ISSUE', data.issueName, req.body.projectName, req.body.severity, req.body.createdByName, null,data.projectId)
                        let userData = await supportHandler.getTeamMailData(data.projectId, data.tenantId, data.loggedUser, data.tenant)

                        if (userData.length > 0) {
                            if (data.projectName != null && data.projectName != undefined
                                && data.createdByName != null && data.createdByName != undefined
                                && data.issueName != null && data.issueName != undefined
                                && data.issueDescription != null && data.issueDescription != undefined
                                && data.severity != null && data.severity != undefined
                                && data.priority != null && data.priority != undefined) {

                                let sub = mailConfig.issue.create.sub
                                sub = sub.replace('{createdByName}', data.createdByName)
                                sub = sub.replace('{projectName}', data.projectName)
                                sub = sub.replace('{issueId}', issueId)

                                let mes;
                                if(data.assignedToName != null && data.assignedToName != undefined){
                                    mes = mailConfig.issue.create.message
                                }
                                else{
                                     mes= mailConfig.issue.create.message1
                                }
                                
                                let moduleName;
                                if (data.moduleName == null) {
                                    moduleName='General'
                                } else {
                                    moduleName=await supportHandler.toTitleCase(data.moduleName,body.loggedUser,body.tenant)
                                }
                                let severity =await supportHandler.toTitleCase(data.severity,body.loggedUser,body.tenant)
                                let priority = await supportHandler.toTitleCase(data.priority,body.loggedUser,body.tenant)
                                const payLoad = {
                                    moduleName1:moduleName,
                                    issueId1: issueId,
                                    projectName:data.projectName,
                                    issueName:data.issueName,
                                    issueDescription:data.issueDescription,
                                    assignedto:data.assignedToName,
                                    severity1:severity,
                                    priority1:priority,
                                    createdByName:data.createdByName

                                  };
                                  const imageFilePath = path.join(__dirname,'..', '..', 'utils', 'pictures', '2.png');
                                                const imageData = fs.readFileSync(imageFilePath);
                                                // Encode the binary data to base64
                                                const base64Image = imageData.toString('base64');
                                                const attachments = [
                                                    {
                                                        "@odata.type": "#microsoft.graph.fileAttachment",
                                                        "name": "2.png",
                                                        "contentBytes": base64Image,
                                                        "isInline": true,
                                                        "contentId": "attached-image"
                                                    }
                                                   
                                                ];
                                                ejs.renderFile(mes,payLoad,(err, message) => {
                                                    if (err) {
                                                      console.error('Error rendering email template:', err);
                                                      res.status(500).json({ error: 'Internal server error' });
                                                      return;
                                                    }
                                sendMails(userData, null, null, sub, message, data.loggedUser, data.tenant, attachments, true, data.tenantId, appLogger, meteringLogger, moduleName)
                            });

                            } else {
                                appLogger.logMessage("info", "Invalid parameters for email", "PMService", "addIssue", loggedUser, tenant, moduleName, moduleName);
                            }

                        } else {
                            appLogger.logMessage("info", "Failed to get  team  members email", "PMService", "addIssue", loggedUser, tenant, moduleName, moduleName);

                        }

                    } else {
                        result = await responseHandler.sendResponse("Warning", "Failed to add issue.", 400, null, false, "addIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Issue name already exists.", 400, null, false, "addIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "addIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addIssue", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "addIssue", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addIssue", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    editIssue: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "editIssue", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.issueId != undefined && data.issueId != null) {
                Object.keys(data).forEach(k => data[k] = (data[k] === '' || data[k] === 'null' || data[k] === undefined) ? null : data[k])
                let query = mysqlQueries.checkIssueExists + " AND ID != ?";
                result = await dbOperations.executeQuery(query, [data.issueName.toUpperCase().trim(), data.issueId], loggedUser, "addIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.length == 0) {
                    if (data.isNewModule == "true") {
                        data.name = data.description = data.moduleId.trim();
                        data.moduleId = null;
                        result = await this.addModule(data, loggedUser, tenant);
                        if (result.type.toLowerCase() == "error") {
                            return result;
                        } else {
                            result = await dbOperations.executeQuery(mysqlQueries.getModuleIdByName, [data.name, data.projectId], loggedUser, "addIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                            if (result != undefined && result != null && result.length > 0) {
                                data.moduleId = result[0].ID
                            }
                        }
                    }
                    let param = [data.issueName, data.issueDescription, data.priority, data.severity, data.assignedTo, data.status, data.assigneeComment, data.assignedByComment, data.moduleId, data.issueId]
                    result = await dbOperations.executeQuery(mysqlQueries.editIssue, param, loggedUser, "editIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                    if (result != undefined && result != null && result.affectedRows > 0) {
                        result = await responseHandler.sendResponse("Success", "Issue updated successfully.", 200, null, false, "editIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        result = await responseHandler.sendResponse("Warning", "Failed to update issue.", 400, null, false, "editIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Issue name already exists.", 400, null, false, "addIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "editIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "editIssue", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "editIssue", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "editIssue", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "editIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    deleteIssue: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "deleteIssue", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.issueId != undefined && data.issueId != null) {
                result = await dbOperations.executeQuery(mysqlQueries.updateIssue, [data.issueId], loggedUser, "deleteIssue", true, [1], tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.affectedRows > 0) {
                    result = await responseHandler.sendResponse("Success", "Issue removed successfully.", 200, null, false, "deleteIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to remove issue.", 400, null, false, "deleteIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "deleteIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "deleteIssue", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "deleteIssue", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "deleteIssue", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "deleteIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getAllIssue: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "getAllIssue", loggedUser, tenant, moduleName);
        let result;
        try {
            result = await dbOperations.executeQuery(mysqlQueries.getAllIssue, [], loggedUser, "getAllIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
            if (result != undefined && result != null) {
                if (result.length > 0) {
                    result = await responseHandler.sendResponse("Success", "Successfully fetched All Issues.", 200, result, true, "getAllIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Success", "No issues found.", 200, null, false, "getAllIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Failed to fetch issues.", 400, null, false, "getAllIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getAllIssue", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "getAllIssue", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getAllIssue", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getAllIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getAllOpenIssue: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "getAllOpenIssue", loggedUser, tenant, moduleName);
        let result;
        try {
            result = await dbOperations.executeQuery(mysqlQueries.getAllOpenIssue, [data.loggedUserId], loggedUser, "getAllOpenIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
            if (result != undefined && result != null) {
                if (result.length > 0) {
                    result = await responseHandler.sendResponse("Success", "Successfully fetched All Open Issues.", 200, result, true, "getAllOpenIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Success", "No issues found.", 200, null, false, "getAllOpenIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Failed to fetch issues.", 400, null, false, "getAllOpenIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getAllOpenIssue", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "getAllOpenIssue", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getAllOpenIssue", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getAllOpenIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getIssueByProject: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "getIssueByProject", loggedUser, tenant, moduleName);
        let result, count, lookUpAction = [];
        try {
            if (data.projectId != undefined && data.projectId != null) {
                result = await dbOperations.executeQuery(mysqlQueries.getIssueByProject, [data.projectId], loggedUser, "getIssueByProject", false, null, tenant, appLogger, meteringLogger, moduleName)

                if (result != undefined && result != null) {
                    if (result.length > 0) {
                        let lookUpResult = await dbOperations.executeQuery(mysqlQueries.getLookupStatus, ["ISSUE_STATUS", data.tenantId], loggedUser, "getIssueByProject", false, null, tenant, appLogger, meteringLogger, moduleName)

                        for (let value of result) {
                            count = moment().diff(moment(value.CREATION_DATE), 'days')
                            value["COUNT"] = count;
                            //let severities = ['Major', 'Minor', 'Critical', 'Enhancement']
                            //let priorities = ['High', 'Low', 'Medium']
                            let priorityArray = ['HIGH','LOW','MEDIUM']
                            let severityArray = ['CRITICAL','MAJOR','MINOR','ENHANCEMENT']
                            // value.SEVERITY=await supportHandler.toTitleCase(value.SEVERITY,data.loggedUser,data.tenant)
                            // severityArray.push(value.SEVERITY)
                            // value.PRIORITY=await supportHandler.toTitleCase(value.PRIORITY,data.loggedUser,data.tenant)
                            // priorityArray.push(value.PRIORITY)
                            // for (let data of severities) {
                            //     if (data != value.SEVERITY) {
                            //         severityArray.push(data)
                            //     }
                            // }
                            // for (let data of priorities) {
                            //     if (data != value.PRIORITY) {
                            //         priorityArray.push(data)
                            //     }
                            // }

                            value['SEVERITY_ARRAY'] = severityArray
                            value['PRIORITY_ARRAY'] = priorityArray
                            if (value.STATUS_CODE == 'OPEN' || value.STATUS_CODE == 'REOPEN') {
                                lookUpAction.push({ 'LOOKUP_CODE': value.STATUS_CODE, 'DISPLAY_VALUE': value.STATUS })

                                for (let data of lookUpResult) {
                                    if (data.LOOKUP_CODE == 'IP' || data.LOOKUP_CODE == 'NR' || data.LOOKUP_CODE == 'RESOLVED' || data.LOOKUP_CODE == 'DUPLICATE' || data.LOOKUP_CODE == 'NI' || data.LOOKUP_CODE == 'AD') {
                                        lookUpAction.push({ 'LOOKUP_CODE': data.LOOKUP_CODE, 'DISPLAY_VALUE': data.DISPLAY_VALUE })
                                    }
                                }


                            } else if (value.STATUS_CODE == 'IP') {
                                lookUpAction.push({ 'LOOKUP_CODE': value.STATUS_CODE, 'DISPLAY_VALUE': value.STATUS })
                                for (let data of lookUpResult) {
                                    if (data.LOOKUP_CODE == 'RESOLVED' || data.LOOKUP_CODE == 'NR' || data.LOOKUP_CODE == 'DUPLICATE' || data.LOOKUP_CODE == 'NI' || data.LOOKUP_CODE == 'AD') {
                                        lookUpAction.push({ 'LOOKUP_CODE': data.LOOKUP_CODE, 'DISPLAY_VALUE': data.DISPLAY_VALUE })
                                    }
                                }

                            } else if (value.STATUS_CODE == 'RESOLVED' && value.OWNER_ID.includes(data.loggedUserId)) {
                                lookUpAction.push({ 'LOOKUP_CODE': value.STATUS_CODE, 'DISPLAY_VALUE': value.STATUS })
                                for (let data of lookUpResult) {
                                    if (data.LOOKUP_CODE == 'RFT') {
                                        lookUpAction.push({ 'LOOKUP_CODE': data.LOOKUP_CODE, 'DISPLAY_VALUE': data.DISPLAY_VALUE })
                                    }
                                }
                            } else if (value.STATUS_CODE == 'RFT' && value.CREATED_BY_EMAIL == data.loggedUser) {
                                lookUpAction.push({ 'LOOKUP_CODE': value.STATUS_CODE, 'DISPLAY_VALUE': value.STATUS })
                                for (let data of lookUpResult) {
                                    if (data.LOOKUP_CODE == 'VC' || data.LOOKUP_CODE == 'REOPEN') {
                                        lookUpAction.push({ 'LOOKUP_CODE': data.LOOKUP_CODE, 'DISPLAY_VALUE': data.DISPLAY_VALUE })
                                    }
                                }
                            } else if (value.STATUS_CODE == 'VC') {
                                lookUpAction.push({ 'LOOKUP_CODE': value.STATUS_CODE, 'DISPLAY_VALUE': value.STATUS })

                            } else if (value.STATUS_CODE == 'NS') {
                                lookUpAction.push({ 'LOOKUP_CODE': value.STATUS_CODE, 'DISPLAY_VALUE': value.STATUS })
                            }
                            value['LOOK_UP'] = lookUpAction
                            value['ASSIGNEE'] = [{
                                ID: value.ASSIGNED_TO,
                                FULL_NAME: value.ASSIGNED_TO_NAME,
                                ASSIGNEE_EMAIL: value.ASSIGNED_TO_EMAIL,
                                ROLE_NAME: value.ROLE_NAME
                            }]
                            lookUpAction = []
                        }
                        result = await responseHandler.sendResponse("Success", "Successfully fetched issues by project id.", 200, result, true, "getIssueByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        result = await responseHandler.sendResponse("Success", "No issues found.", 200, null, false, "getIssueByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to fetched issues by project id.", 400, null, false, "getIssueByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getIssueByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getIssueByProject", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "getIssueByProject", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getIssueByProject", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getIssueByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getIssueByUser: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "getIssueByUser", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.assignedTo != undefined && data.assignedTo != null) {
                result = await dbOperations.executeQuery(mysqlQueries.getIssueByUser, [data.assignedTo], loggedUser, "getIssueByUser", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null) {
                    if (result.length > 0) {
                        result = await responseHandler.sendResponse("Success", "Successfully fetched issues by user id.", 200, result, true, "getIssueByUser", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        result = await responseHandler.sendResponse("Success", "No issues found.", 200, null, false, "getIssueByUser", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to fetched issues by user id.", 400, null, false, "getIssueByUser", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getIssueByUser", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getIssueByUser", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "getIssueByUser", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getIssueByUser", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getIssueByUser", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getIssueDetails: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getIssueDetails Service initiated.", "PMService", "getIssueDetails", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.id != undefined && data.id != null) {
                result = await dbOperations.executeQuery(mysqlQueries.getIssueDetails, [data.id, data.tenantId], loggedUser, "getIssueDetails", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null) {
                    if (result.length > 0) {
                        result[0]["LOOKUP_ACTION"] = [{
                            "LOOKUP_CODE": result[0].STATUS_CODE,
                            "DISPLAY_VALUE": result[0].STATUS
                        }]
                        let lookup = await dbOperations.executeQuery(mysqlQueries.getLookupStatus, ['ISSUE_STATUS', data.tenantId], loggedUser, "getLookupStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                        if (lookup != undefined && lookup != null && lookup.length > 0) {
                            if (result[0].STATUS_CODE == "OPEN") {
                                result[0]["LOOKUP_ACTION"] = result[0]["LOOKUP_ACTION"].concat(lookup.filter(x => ['IP', 'NR', 'RESOLVED', 'DUPLICATE', 'NI', 'AD'].includes(x.LOOKUP_CODE)))
                            } else if (result[0].STATUS_CODE == "REOPEN") {
                                result[0]["LOOKUP_ACTION"] = result[0]["LOOKUP_ACTION"].concat(lookup.filter(x => ['IP', 'NR', 'RESOLVED', 'DUPLICATE', 'NI', 'AD'].includes(x.LOOKUP_CODE)))
                            } else if (result[0].STATUS_CODE == "IP") {
                                result[0]["LOOKUP_ACTION"] = result[0]["LOOKUP_ACTION"].concat(lookup.filter(x => ['NR', 'RESOLVED', 'DUPLICATE', 'NI', 'AD'].includes(x.LOOKUP_CODE)))
                            } else if (result[0].STATUS_CODE == "NR") {
                                result[0]["LOOKUP_ACTION"] = result[0]["LOOKUP_ACTION"].concat(lookup.filter(x => ['REOPEN'].includes(x.LOOKUP_CODE)))
                            } else if (result[0].STATUS_CODE == "RESOLVED" && result[0].OWNER_ID.includes(data.loggedUserId)) {
                                result[0]["LOOKUP_ACTION"] = result[0]["LOOKUP_ACTION"].concat(lookup.filter(x => ['RFT'].includes(x.LOOKUP_CODE)))
                            } else if (result[0].STATUS_CODE == "RFT" && result[0].CREATED_BY == data.loggedUserId) {
                                result[0]["LOOKUP_ACTION"] = result[0]["LOOKUP_ACTION"].concat(lookup.filter(x => ['REOPEN', 'VC'].includes(x.LOOKUP_CODE)))
                            }
                        }
                        appLogger.logMessage("info", "Issue details fetched successfully", "PMService", "getIssueDetails", loggedUser, tenant, moduleName, moduleName);
                        result = await responseHandler.sendResponse("Success", "Successfully fetched issue details by issue id.", 200, result, true, "getIssueDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "No issue details are available", "PMService", "getIssueDetails", loggedUser, tenant, moduleName, moduleName);

                        result = await responseHandler.sendResponse("Success", "No issues details found.", 200, null, false, "getIssueDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch issue details", "PMService", "getIssueDetails", loggedUser, tenant, moduleName, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch issues details by issue id.", 400, null, false, "getIssueDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getIssueDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getIssueDetails", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getIssueDetails Service completed.", "PMService", "getIssueDetails", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getIssueDetails", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getIssueDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    assignIssue: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "assignIssue Service initiated.", "PMService", "assignIssue", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.issueId != undefined && data.issueId != null && data.assignedTo != undefined && data.assignedTo != null) {
                result = await dbOperations.executeQuery(mysqlQueries.assignTasks, [data.assignedTo, data.loggedUserId, data.issueId], loggedUser, "assignIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.affectedRows > 0) {
                    if (data.assignedTo != data.loggedUserId) {
                        if (data.projectName != null && data.projectName != undefined
                            && data.assignedByName != null && data.assignedByName != undefined
                            && data.issueName != null && data.issueName != undefined
                            && data.issueDescription != null && data.issueDescription != undefined
                            && data.severity != null && data.severity != undefined
                            && data.priority != null && data.priority != undefined
                        ) {
                            let notify = await supportHandler.notifyEmpAssignIssue(data.assignedTo,data.loggedUser,data.tenant,data.issueName,data.projectName,data.priority,data.assignedByName)
                            let sub = mailConfig.issue.assign.sub
                            sub = sub.replace('{projectName}', data.projectName)
                            sub = sub.replace('{issueId}', data.issueId)
                            sub = sub.replace('{assignedByName}', data.assignedByName)
                            let mes = mailConfig.issue.assign.message
                            let message;
                            if (data.moduleId == undefined || data.moduleId == null) {
                                mes = mes.replace('{moduleName}', "General")
                            } else {
                                mes = mes.replace('{moduleName}', data.moduleName)
                            }
                            mes = mes.replace('{issueId}', data.issueId)
                            mes = mes.replace('{projectName}', data.projectName)
                            mes = mes.replace('{issueName}', data.issueName)
                            mes = mes.replace('{issueDescription}', data.issueDescription)
                            mes = mes.replace('{severity}', data.severity)
                            mes = mes.replace('{priority}', data.priority)
                            mes = mes.replace('{assignedByName}', data.assignedByName)
                            message = mes
                            if (data.assignedTo != undefined && data.assignedTo != null && data.userEmail != undefined && data.userEmail != null) {
                                let userData = [{ 'Id': data.assignedTo, 'Email': data.userMail }]
                                sendMails(userData, null, null, sub, message, data.loggedUser, data.tenant, null, false, data.tenantId, appLogger, meteringLogger, moduleName)
                            }
                        } else {
                            appLogger.logMessage("info", "Invalid parameters.", "PMService", "assignIssue", loggedUser, tenant, moduleName, moduleName);
                        }
                    }
                    result = await responseHandler.sendResponse("Success", "Issue assigned successfully.", 200, null, false, "assignIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to assign issue.", 400, null, false, "assignIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "assignIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "assignIssue", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "assignIssue Service completed.", "PMService", "assignIssue", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "assignIssue", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "assignIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    addMilestone: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "addMilestone Service initiated.", "PMService", "addMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.projectId != undefined && data.projectId != null && data.name != undefined && data.name != null && data.description != undefined && data.description != null && data.startDate != undefined && data.startDate != null && data.endDate != undefined && data.endDate != null) {
                let isMilestoneExist = await supportHandler.isMilestoneExists(data.name, data.projectId, data.tenantId, loggedUser, tenant, false)
                if (isMilestoneExist != null) {
                    if (isMilestoneExist == 0) {
                        let dbparams = [data.tenantId, data.projectId, data.name, data.description, data.startDate, data.endDate]
                        let dbResult = await dbOperations.executeQuery(mysqlQueries.createMilestone, dbparams, loggedUser, "addMilestone", true, [7, 8], tenant, appLogger, meteringLogger, moduleName);
                        if (dbResult != null && dbResult != undefined && dbResult.affectedRows > 0) {
                            result = await responseHandler.sendResponse("Success", "Milestones added successfully.", 200, null, false, "addMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            result = await responseHandler.sendResponse("Warning", "Failed to add milestones.", 400, null, false, "addMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }

                    } else {
                        result = await responseHandler.sendResponse("Warning", "Milestone with name already exist.", 400, null, false, "addMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to add milestones.", 400, null, false, "addMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "addMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getTaskForMilestones Service completed.", "PMService", "addMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    editMilestone: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "editMilestone Service initiated.", "PMService", "editMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.milestoneId != undefined && data.milestoneId != null && data.name != undefined && data.name != null && data.description != undefined && data.description != null && data.startDate != undefined && data.startDate != null && data.endDate != undefined && data.endDate != null) {
                let isMilestoneExist = await supportHandler.isMilestoneExists(data.name, data.projectId, data.tenantId, loggedUser, tenant, true, data.milestoneId)
                if (isMilestoneExist != null && isMilestoneExist != undefined) {
                    if (isMilestoneExist == 0) {
                        let dbResult = await dbOperations.executeQuery(mysqlQueries.editMilestone, [data.name, data.description, data.startDate, data.endDate, data.milestoneId], loggedUser, "editMilestone", false, null, tenant, appLogger, meteringLogger, moduleName);
                        if (dbResult != null && dbResult != undefined && dbResult.affectedRows > 0) {
                            result = await responseHandler.sendResponse("Success", "Milestone updated successfully.", 200, null, false, "editMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            result = await responseHandler.sendResponse("Warning", "Failed to update milestones.", 400, null, false, "editMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    } else {
                        result = await responseHandler.sendResponse("Warning", "Milestone with name already exist.", 400, null, false, "editMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to update milestones.", 400, null, false, "editMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "editMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "editMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getTaskForMilestones Service completed.", "PMService", "editMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "editMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "editMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getMilestone: async function (projectId, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getMilestone Service initiated.", "PMService", "getMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (projectId != undefined && projectId != null) {
                let dbResult = await dbOperations.executeQuery(mysqlQueries.getMilestones, [projectId], loggedUser, "getMilestone", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (dbResult != null && dbResult != undefined && dbResult.length > 0) {
                    let date = new Date()
                    for (let data of dbResult) {
                        let comPercentage = (data.TASK_COUNT == 0) ? 0 : ((data.COMPLETED_COUNT / data.TASK_COUNT) * 100).toFixed(2)
                        data['COMPLETED_PERCENTAGE'] = comPercentage
                        if(comPercentage == 100){
                            data['STATUS'] = 'COMPLETED'
                        }else if((comPercentage == '0.00'  && data.TASK_COUNT >0)){
                            let count = await dbOperations.executeQuery(mysqlQueries.getInProgressMilestoneTaskCount, [data.ID], loggedUser, "getMilestone", false, null, tenant, appLogger, meteringLogger, moduleName);
                            if(count != null && count != undefined && count.length > 0){
                                if(count[0].COUNT != 0){
                                    data['STATUS'] = 'IN PROGRESS'
                                }else{
                                    data['STATUS'] = 'NOT STARTED'
                                }
                            }
                        }else if(comPercentage == 0){
                            data['STATUS'] = 'NOT STARTED'
                        }else if(comPercentage != 0 && comPercentage != '0.00'){
                            data['STATUS'] = 'IN PROGRESS'
                        }
                    }
                    result = await responseHandler.sendResponse("Success", "Data fetched successfully.", 200, dbResult, false, "getMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "No milestones found for project.", 400, null, false, "getMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getTaskForMilestones Service completed.", "PMService", "getMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getTaskForMilestones: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getTaskForMilestones Service initiated.", "PMService", "getTaskForMilestones", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.milestoneId != undefined && data.milestoneId != null && data.projectId != undefined && data.projectId != null) {
                let dbResult = await dbOperations.executeQuery(mysqlQueries.getTaskNotInMilestones, [data.projectId, data.tenantId], loggedUser, "getTaskForMilestones", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (dbResult != null && dbResult != undefined && dbResult.length > 0) {
                    result = await responseHandler.sendResponse("Success", "Data fetched successfully.", 200, dbResult, false, "getTaskForMilestones", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "No milestones found for project.", 400, null, false, "getTaskForMilestones", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getTaskForMilestones", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getTaskForMilestones", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getTaskForMilestones Service completed.", "PMService", "getTaskForMilestones", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getTaskForMilestones", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getTaskForMilestones", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    //CHANGE ISSUE STATUS
    changeIssueStatus: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "changeIssueStatus Service initiated.", "PMService", "changeIssueStatus", loggedUser, tenant, moduleName);
        let result;
        let query, param = []
        try {
            if (body.issueId != undefined && body.issueId != null && body.status != undefined && body.status != null) {
                if (body.status == 'IP') {
                    query = mysqlQueries.changeIssueStatusIP
                    param = [body.loggedUserId, body.startDate, body.issueId, body.projectId, body.tenantId]

                } else if (body.status == 'VC') {
                    query = mysqlQueries.changeIssueStatusVC
                    param = [body.loggedUserId, body.endDate, body.issueId, body.projectId, body.tenantId]

                } else {

                    query = mysqlQueries.changeIssueStatus
                    param = [
                        body.status,
                        body.loggedUserId,
                        body.issueId,
                        body.tenantId,
                    ]
                    let userData = []
                    let sub, mes, message
                    if (body.status == 'NR') {
                        sub = mailConfig.issue.statusNR.sub
                        mes = mailConfig.issue.statusNR.message
                        if (body.createdBy != body.assignedBy && body.assignedBy != body.loggedUserId && body.createdBy != body.loggedUserId) {
                            userData = [{ 'Id': body.assignedBy, 'Email': body.assignedByEmail },
                            { 'Id': body.createdBy, 'Email': body.createdByEmail }]
                        } else if (body.createdBy == body.loggedUserId && body.assignedBy != body.loggedUserId) {
                            userData = [{ 'Id': body.assignedBy, 'Email': body.assignedByEmail }]
                        } else if (body.createdBy != body.loggedUserId && body.assignedBy == body.loggedUserId) {
                            userData = [{ 'Id': body.createdBy, 'Email': body.createdByEmail }]
                        }
                    } else if (body.status == 'REOPEN') {
                        sub = mailConfig.issue.statusREOPEN.sub
                        mes = mailConfig.issue.statusREOPEN.message
                        if (body.assignedBy != body.loggedUserId) {
                            userData = [{ 'Id': body.assignedBy, 'Email': body.assignedByEmail }]

                        }
                    } else if (body.status == 'RFT') {
                        sub = mailConfig.issue.statusRFT.sub
                        mes = mailConfig.issue.statusRFT.message
                        if (body.createdBy != body.loggedUserId) {
                            userData = [{ 'Id': body.createdBy, 'Email': body.createdByEmail }
                            ]
                        }
                    }
                    if (sub != undefined && sub != null && message != undefined && message != null) {
                        sub = sub.replace('{projectName}', body.projectName)
                        sub = sub.replace('{loggedUserName}', body.loggedUserName)
                        sub = sub.replace('{issueId}', body.issueId)
                        mes = mes.replace('{issueId}', body.issueId)
                        mes = mes.replace('{projectName}', body.projectName)
                        mes = mes.replace('{issueName}', body.issueName)
                        mes = mes.replace('{moduleName}', body.moduleName)
                        mes = mes.replace('{issueDescription}', body.issueDescription)
                        mes = mes.replace('{severity}', body.severity)
                        mes = mes.replace('{priority}', body.priority)
                        message = mes
                        if (userData.length > 0) {
                            sendMails(userData, null, null, sub, message, body.loggedUser, body.tenant, null, false, body.tenantId, appLogger, meteringLogger, moduleName)
                        }
                    }

                }
                result = await dbOperations.executeQuery(query, param, loggedUser, "changeIssueStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.affectedRows > 0) {
                        result = await responseHandler.sendResponse("Success", " Issue status changed successfully.", 200, null, false, "changeIssueStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        appLogger.logMessage("info", "Issue status changed successfully", "PMService", "changeIssueStatus", loggedUser, tenant, moduleName);

                    } else {
                        result = await responseHandler.sendResponse("Warning", " Failed to change issue status.", 200, null, false, "changeIssueStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        appLogger.logMessage("Warning", "Failed to change issue status", "PMService", "changeIssueStatus", loggedUser, tenant, moduleName);

                    }
                } else {
                    appLogger.logMessage("Warning", "Failed to change issue status", "PMService", "changeIssueStatus", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to assign issue.", 400, null, false, "changeIssueStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("Warning", "Invalid Parameters.", "PMService", "changeIssueStatus", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "changeIssueStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "changeIssueStatus", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "changeIssueStatus Service completed.", "PMService", "changeIssueStatus", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "changeIssueStatus", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "changeIssueStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // ADD FAVOURITE PROJECT
    addFavouriteProject: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "addFavouriteProject Service initiated.", "PMService", "addFavouriteProject", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.projectId != undefined && body.projectId != null && body.loggedUserId != undefined && body.loggedUserId != null) {
                let query = mysqlQueries.isAddedToFavourites
                let param = [
                    body.loggedUserId,
                    body.projectId,
                    body.tenantId,

                ]
                result = await dbOperations.executeQuery(query, param, loggedUser, "addFavouriteProject", true, [5, 6], tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        result = await responseHandler.sendResponse("Waring", "Project is already added to the favourite list.", 200, null, false, "addFavouriteProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        appLogger.logMessage("info", "Project is already added to the favourite list.", "PMService", "addFavouriteProject", loggedUser, tenant, moduleName);

                    } else {
                        let query = mysqlQueries.addFavouriteProject
                        let param = [
                            body.tenantId,
                            body.loggedUserId,
                            body.projectId,
                            moment().format('YYYY-MM-DD HH:mm:ss.SSS')
                        ]
                        result = await dbOperations.executeQuery(query, param, loggedUser, "addFavouriteProject", true, [5, 6], tenant, appLogger, meteringLogger, moduleName)
                        if (result != undefined && result != null && result != 'Error') {
                            if (result.affectedRows > 0) {
                                result = await responseHandler.sendResponse("Success", "Project added to the favourites.", 200, null, false, "addFavouriteProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Project added to the favourites ", "PMService", "addFavouriteProject", loggedUser, tenant, moduleName);

                            } else {
                                appLogger.logMessage("info", "Failed to add project to the favourite list.", "PMService", "addFavouriteProject", loggedUser, tenant, moduleName);
                                result = await responseHandler.sendResponse("Warning", "Failed to add project to the favourite list.", 400, null, false, "addFavouriteProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                            }
                        } else {
                            appLogger.logMessage("info", "Failed to add project to the favourite list.", "PMService", "addFavouriteProject", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "Failed to add project to the favourite list.", 400, null, false, "addFavouriteProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    }
                }


            } else {
                appLogger.logMessage("info", "Invalid Parameters. ", "PMService", "addFavouriteProject", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "addFavouriteProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addFavouriteProject", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "addFavouriteProject Service completed.", "PMService", "addFavouriteProject", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addFavouriteProject", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addFavouriteProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    //REMOVE FAVOURITE PROJECT
    removeFavouriteProject: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "removeFavouriteProject Service initiated.", "PMService", "removeFavouriteProject", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.projectId != undefined && body.projectId != null && body.loggedUserId != undefined && body.loggedUserId != null) {
                let query = mysqlQueries.removeFavouriteProject
                let param = [
                    body.loggedUserId,
                    body.projectId,
                    body.loggedUserId,
                    body.tenantId
                ]
                result = await dbOperations.executeQuery(query, param, loggedUser, "removeFavouriteProject", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.affectedRows > 0) {
                        appLogger.logMessage("info", "Successfully removed the project from favourite list.", "PMService", "removeFavouriteProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Successfully removed the project from favourite list. ", 200, null, false, "removeFavouriteProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("info", "Failed to remove the project from favourite list.", "PMService", "removeFavouriteProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Failed to remove the project from favourite list.", 400, null, false, "removeFavouriteProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to remove the project from favourite list.", "PMService", "removeFavouriteProject", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to assign issue.", 400, null, false, "removeFavouriteProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "removeFavouriteProject", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "removeFavouriteProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "removeFavouriteProject", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "removeFavouriteProject Service completed.", "PMService", "removeFavouriteProject", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "removeFavouriteProject", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "removeFavouriteProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    addModule: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "addModule Service initiated.", "PMService", "addModule", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.projectId != undefined && data.projectId != null && data.name != undefined && data.name != null && data.description != undefined && data.description != null) {
                let isExist = await supportHandler.isModuleExists(data.name.toLowerCase(), data.projectId, data.tenantId, loggedUser, tenant)
                if (isExist != null) {
                    if (isExist == 0) {
                        let dbparams = [data.tenantId, data.projectId, data.name, data.description]
                        let dbResult = await dbOperations.executeQuery(mysqlQueries.createModule, dbparams, loggedUser, "addModule", true, [5, 6], tenant, appLogger, meteringLogger, moduleName);
                        if (dbResult != null && dbResult != undefined && dbResult.affectedRows > 0) {
                            result = await responseHandler.sendResponse("Success", "Module added successfully.", 200, null, false, "addModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            result = await responseHandler.sendResponse("Warning", "Failed to add module.", 400, null, false, "addModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    } else {
                        result = await responseHandler.sendResponse("Warning", "Milestone with name already exist.", 400, null, false, "addModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to add module.", 400, null, false, "addModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "addModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addModule", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "addModule Service completed.", "PMService", "addModule", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addModule", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    editModule: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "editModule Service initiated.", "PMService", "editModule", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.moduleId != undefined && data.moduleId != null && data.name != undefined && data.name != null && data.description != undefined && data.description != null) {
                let dbResult = await dbOperations.executeQuery(mysqlQueries.editModule, [data.name, data.description, data.moduleId], loggedUser, "editModule", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (dbResult != null && dbResult != undefined && dbResult.affectedRows > 0) {
                    result = await responseHandler.sendResponse("Success", "Module edited successfully.", 200, null, false, "editModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to edit milestones.", 400, null, false, "editModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "editModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "editModule", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "editModule Service completed.", "PMService", "editModule", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "editModule", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "editModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getModule: async function (projectId, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getModule Service initiated.", "PMService", "editModule", loggedUser, tenant, moduleName);
        let result;
        try {
            if (projectId != undefined && projectId != null) {
                let dbResult = await dbOperations.executeQuery(mysqlQueries.getModules, [projectId], loggedUser, "getModule", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (dbResult != null && dbResult != undefined && dbResult.length > 0) {
                    result = await responseHandler.sendResponse("Success", "Data fetched successfully.", 200, dbResult, false, "getModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "No modules found for project.", 400, null, false, "getModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getModule", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getModules Service completed.", "PMService", "getModule", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getModule", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    deleteModule: async function (moduleId, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "deleteModule Service initiated.", "PMService", "deleteModule", loggedUser, tenant, moduleName);
        let result;
        try {
            if (moduleId != undefined && moduleId != null) {
                let dbResult = await dbOperations.executeQuery(mysqlQueries.deleteModule, [moduleId], loggedUser, "deleteModule", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (dbResult != null && dbResult != undefined && dbResult.affectedRows > 0) {
                    result = await responseHandler.sendResponse("Success", "Module deleted successfully.", 200, dbResult, false, "deleteModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "No modules found for project.", 400, null, false, "deleteModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "deleteModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "deleteModule", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "deleteModule Service completed.", "PMService", "deleteModule", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "deleteModule", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "deleteModule", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //FETCH ALL TASK OF VARIOUS STATUS FOR EMPLOYEE
    //  THIS API IS CALLED WHEN CLICKING ON THE EXPAND BUTTON ON MY TASK PAGE
    fetchAllTaskForEmployee: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "fetchAllTaskForEmployee Service initiated.", "PMService", "fetchAllTaskForEmployee", loggedUser, tenant, moduleName);
        let result;
        let task = []
        let data = {}
        try {
            let query,param=[]
            if (body.status != undefined && body.status != null) {
                if(String(body.status).toLowerCase()=='watch'){
                    query=mysqlQueries.fetchAllTaskForEmployee
                    query = query.replace("WHERE GT.TENANT_ID =? AND GT.ASSIGNED_TO=? AND GT.TASK_STATUS_TYPE_CODE in (?) ORDER BY CREATION_DATE DESC;", "");
                    query += ",gnieprojectmanagement.GPM_WATCH_LIST GW WHERE  GW.TYPE='TASK' AND GW.ENTITY_ID=GT.ID  AND GW.STATUS='ACTIVE' "
                    query += " AND GT.TENANT_ID =? AND GT.TASK_STATUS_TYPE_CODE in (?) ORDER BY CREATION_DATE DESC;";
                    param = [
                        body.tenantId,
                        ['OPEN','IP','HOLD','NS']
                    ]

                }else if(String(body.status).toLowerCase()=='pending'){
                    query=mysqlQueries.fetchAllTaskForEmployee
                    query = query.replace("ORDER BY CREATION_DATE DESC;", "");
                    query+="AND GT.SUB_STATUS='Awaiting Approval' "
                    query += " ORDER BY CREATION_DATE DESC";


                }else if(String(body.status).toLowerCase()=='rejected'){
                    query=mysqlQueries.fetchAllTaskForEmployee
                    query = query.replace("ORDER BY CREATION_DATE DESC;", "");
                    query+="AND GT.SUB_STATUS='Rejected' "
                    query += " ORDER BY CREATION_DATE DESC";
                }else{
                    query = mysqlQueries.fetchAllTaskForEmployee
                    param = [
                        body.tenantId,
                        body.loggedUserId,
                        [body.status]
                    ]
                    query = query.replace("ORDER BY CREATION_DATE DESC;", "");
                    if (body.projectId != undefined && body.projectId != null && body.projectId != "") {
                        query += "AND GT.PROJECT_ID in ('" + body.projectId.split(",").join("','") + "') "
                    }
                    if (body.assignedBy != undefined && body.assignedBy != null && body.assignedBy != "") {
                        query += "AND GT.ASSIGNED_BY in ('" + body.assignedBy.split(",").join("','") + "') "
                    }
                    if (body.startDate != undefined && body.startDate != null && body.startDate != "") {
                        query += "AND GT.ACTUAL_START_DATE in ('" + body.startDate.split(",").join("','") + "') "
                    }
                    if (body.endDate != undefined && body.endDate != null && body.endDate != "") {
                        query += "AND GT.ACTUAL_COMPLETION_DATE in ('" + body.endDate.split(",").join("','") + "') "
                    }
                    query += "ORDER BY CREATION_DATE DESC";
                }
               
                result = await dbOperations.executeQuery(query, param, loggedUser, "fetchAllTaskForEmployee", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result) {
                        appLogger.logMessage("info", "Task fetched successfully.", "PMService", "fetchAllTaskForEmployee", loggedUser, tenant, moduleName);

                        for (let row of result) {
                            let image = null;
                            let dueDate = moment(row.DUE_DATE).format("YYYY-MM-DD");
                            let currentDate = moment().format("YYYY-MM-DD");
                            let diff = moment(currentDate).diff(moment(dueDate), 'days');
                            row["DUE_IN"] = diff;
                            if (row.EMPLOYEE_NUMBER != null && row.EMPLOYEE_NUMBER != undefined) {
                                let key = String(body.tenant).toUpperCase() + "_" + row.EMPLOYEE_NUMBER;
                                image = await ImageHandler.fetchPhoto(body.tenantType, key, row.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                row["IMAGE"] = image || null;
                            } else {
                                row["IMAGE"] = null;
                            } 

                            if(row.APPROVAL_REQUIRED=='Y' && row.TASK_STATUS_TYPE_CODE=='COM'){
                                if(row.SUB_STATUS=='Approved'){
                                    task.push(row)

                                }

                            }else{
                                task.push(row)

                            }

                        }
                        if (body.status == "COM") {
                            task.sort((a, b) => {
                                return b.ACTUAL_COMPLETION_DATE - a.ACTUAL_COMPLETION_DATE;
                            });
                        } else {
                            task.sort((a, b) => {
                                return b.DUE_DATE - a.DUE_DATE;
                            });
                        }
                        data['TASK'] = task
                        let projectAssigned = await dbOperations.executeQuery(mysqlQueries.getProjectsAssigned, [body.loggedUserId, body.tenantId], loggedUser, "getProjectsAssigned", false, null, tenant, appLogger, meteringLogger, moduleName);
                        if (projectAssigned != null && projectAssigned != undefined && projectAssigned.length > 0) {
                            data['PROJECT_ASSIGNED'] = true;
                        } else {
                            data['PROJECT_ASSIGNED'] = false;
                        }
                        let filterValues = {
                            projects: [...new Map(result.map(item => [item["PROJECT_ID"], { "PROJECT_ID": item.PROJECT_ID, "PROJECT_NAME": item.PROJECT_NAME }])).values()].sort((a, b) => a.PROJECT_NAME.localeCompare(b.PROJECT_NAME)),
                            assignedBy: [...new Map(result.map(item => [item["ASSIGNED_BY"], { "USER_ID": item.ASSIGNED_BY, "FULL_NAME": item.ASSIGNED_BY_NAME }])).values()].sort((a, b) => a.FULL_NAME.localeCompare(b.FULL_NAME)),
                            startDates: [...new Set(result.map(r => r.ACTUAL_START_DATE.getTime()))].map((r) => (moment(new Date(r)).format('YYYY-MM-DD'))),
                            endDates: [...new Set(result.map(r => r.ACTUAL_COMPLETION_DATE.getTime()))].map((r) => (moment(new Date(r)).format('YYYY-MM-DD')))
                        }
                        data["FILTER_DATA"] = filterValues

                        result = await responseHandler.sendResponse("Success", "Task fetched successfully.", 200, data, true, "fetchAllTaskForEmployee", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("debug", "Failed to fetch tasks due to internal server error", className, "getAllTasksOfUser", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Failure", "Invalid data received from the server.", 400, null, false, "fetchAllTaskForEmployee", tenant, loggedUser, moduleName, appLogger, meteringLogger);


                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch task", "PMService", "fetchAllTaskForEmployee", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch task", 400, null, false, "fetchAllTaskForEmployee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "fetchAllTaskForEmployee", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "fetchAllTaskForEmployee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "fetchAllTaskForEmployee", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "fetchAllTaskForEmployee Service completed.", "PMService", "fetchAllTaskForEmployee", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "fetchAllTaskForEmployee", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "fetchAllTaskForEmployee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //FETCH ALL TASK FOR MANAGER UNDER PROJECT
    // API CALLED  WHEN CLICKING ON THE EXPAND BUTTON IN TASKS PAGE
    fetchAllTaskForManager: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "fetchAllTaskForManager Service initiated.", "PMService", "fetchAllTaskForManager", loggedUser, tenant, moduleName);
        let result;
        let task = [], data = {};
        let query;
        let param=[]
        try {
            if (body.projectId != undefined && body.projectId != null && body.status != undefined && body.status != null) {
                if(String(body.status).toLowerCase()=='watch'){
                    query=mysqlQueries.fetchAllTaskForManager
                    query = query.replace("WHERE GT.TENANT_ID = ? AND PROJECT_ID=? AND TASK_STATUS_TYPE_CODE in (?) ORDER BY LAST_UPDATED_DATE DESC;", "");
                    query += ",gnieprojectmanagement.GPM_WATCH_LIST GW WHERE  GW.TYPE='TASK' AND GW.ENTITY_ID=GT.ID "
                    query += " GT.TENANT_ID = ? AND PROJECT_ID=? AND TASK_STATUS_TYPE_CODE in (?) ORDER BY LAST_UPDATED_DATE DESC";

                    param = [
                        body.tenantId,
                        body.projectId,
                        ['OPEN','IP','HOLD','NS']
                    ]

                }else if(String(body.status).toLowerCase()=='pending'){
                    query=mysqlQueries.fetchAllTaskForManager
                    query = query.replace("ORDER BY CREATION_DATE DESC;", "");
                    query+="AND GT.SUB_STATUS='Approved' "
                    query += " ORDER BY CREATION_DATE DESC";


                }else if(String(body.status).toLowerCase()=='rejected'){
                    query=mysqlQueries.fetchAllTaskForManager
                    query = query.replace("ORDER BY CREATION_DATE DESC;", "");
                    query+="AND GT.SUB_STATUS='Rejected' "
                    query += " ORDER BY CREATION_DATE DESC";
                }else{
                     query = mysqlQueries.fetchAllTaskForManager
                     param = [
                        body.tenantId,
                        body.projectId,
                        [body.status]
                    ]
                    query = query.replace("ORDER BY LAST_UPDATED_DATE DESC ;", "");
                    if (body.assignedTo != undefined && body.assignedTo != null && body.assignedTo != "") {
                        let param = body.assignedTo.split(",").map(k => (k === '' || k === 'null' || k === undefined) ? null : k)
                        query += "AND ("
                        if (param.includes('N/A')) {
                            query += "GT.ASSIGNED_TO is null OR "
                            param = param.filter(x => x != 'N/A')
                        }
                        query += "GT.ASSIGNED_TO in ('" + param.join("','") + "')"
                        query += ") "
                    }
                    if (body.startDate != undefined && body.startDate != null && body.startDate != "") {
                        query += "AND GT.ACTUAL_START_DATE in ('" + body.startDate.split(",").join("','") + "') "
                    }
                    if (body.endDate != undefined && body.endDate != null && body.endDate != "") {
                        query += "AND GT.ACTUAL_COMPLETION_DATE in ('" + body.endDate.split(",").join("','") + "') "
                    }
                    query += "ORDER BY LAST_UPDATED_DATE DESC";
                }
                
                result = await dbOperations.executeQuery(query, param, loggedUser, "fetchAllTaskForManager", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result) {

                        for (let row of result) {
                            let image = null;
                            let dueDate = moment(row.DUE_DATE).format("YYYY-MM-DD");
                            let currentDate = moment().format("YYYY-MM-DD");
                            let diff = moment(currentDate).diff(moment(dueDate), 'days');
                            row["DUE_IN"] = diff;
                            if (row.EMPLOYEE_NUMBER != null && row.EMPLOYEE_NUMBER != undefined) {
                                let key = String(body.tenant).toUpperCase() + "_" + row.EMPLOYEE_NUMBER;
                                image = await ImageHandler.fetchPhoto(body.tenantType, key, row.EMAIL, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                                row["IMAGE"] = image || null;
                            } else {
                                row["IMAGE"] = null;
                            }
                            if(row.APPROVAL_REQUIRED=='Y' && row.TASK_STATUS_TYPE_CODE=='COM'){
                                if(row.SUB_STATUS=='Approved'){
                                    task.push(row)

                                }

                            }else{
                                task.push(row)

                            }
                        }
                        if (body.status == "COM") {
                            task.sort((a, b) => {
                                return b.ACTUAL_COMPLETION_DATE - a.ACTUAL_COMPLETION_DATE;
                            });
                        } else {
                            task.sort((a, b) => {
                                return b.DUE_DATE - a.DUE_DATE;
                            });
                        }
                        let filterValues = {
                            assignedTo: [...new Map(result.map(item => [item["ASSIGNED_TO"], { "USER_ID": (item.ASSIGNED_TO != null && item.ASSIGNED_TO != undefined) ? item.ASSIGNED_TO : "N/A", "FULL_NAME": (item.FULL_NAME != null && item.FULL_NAME != undefined) ? item.FULL_NAME : "Not Assigned" }])).values()].sort((a, b) => a.FULL_NAME.localeCompare(b.FULL_NAME)),
                            startDates: [...new Set(result.map(r => r.ACTUAL_START_DATE.getTime()))].map((r) => (moment(new Date(r)).format('YYYY-MM-DD'))),
                            endDates: [...new Set(result.map(r => r.ACTUAL_COMPLETION_DATE.getTime()))].map((r) => (moment(new Date(r)).format('YYYY-MM-DD')))
                        }
                        data["TASK"] = task;
                        data["FILTER_DATA"] = filterValues
                        result = await responseHandler.sendResponse("Success", "Task fetched successfully.", 200, data, true, "fetchAllTaskForManager", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("debug", "Failed to fetch tasks due to internal server error", className, "getTasksList", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Failed to fetch task", 400, null, false, "fetchAllTaskForManager", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to remove the project from favourite list.", "PMService", "fetchAllTaskForManager", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to assign issue.", 400, null, false, "fetchAllTaskForManager", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "fetchAllTaskForManager", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "fetchAllTaskForManager", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "fetchAllTaskForManager", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "fetchAllTaskForManager Service completed.", "PMService", "fetchAllTaskForEmployee", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "fetchAllTaskForManager", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "fetchAllTaskForManager", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    // COUNT OF TASK DELAYED
    delayedTaskCount: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "delayedTaskCount Service initiated.", "PMService", "delayedTaskCount", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.roles != undefined && body.roles != null && body.loggedUserId != undefined && body.loggedUserId != null) {
                let query;
                let param;

                if (body.roles.includes('PROJECT_MANAGER')) {
                    query = mysqlQueries.delayedTaskCountForManager
                    param = [body.loggedUserId]
                } else if (body.roles.includes('EMPLOYEE')) {
                    query = mysqlQueries.delayedTaskCountForEmployee
                    param = [body.loggedUserId]
                }
                result = await dbOperations.executeQuery(query, param, loggedUser, "delayedTaskCount", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result) {
                        appLogger.logMessage("info", "Successfully fetched delayed task count", "PMService", "delayedTaskCount", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Successfully fetched  delayed task count", 200, result, true, "delayedTaskCount", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "Failed to fetch delayed task count", "PMService", "delayedTaskCount", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Failed to fetch delayed task count.", 400, null, false, "delayedTaskCount", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch delayed task count.", "PMService", "delayedTaskCount", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch delayed task count.", 400, null, false, "delayedTaskCount", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "delayedTaskCount", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "delayedTaskCount", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "delayedTaskCount", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "delayedTaskCount Service completed.", "PMService", "delayedTaskCount", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "delayedTaskCount", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "delayedTaskCount", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    // COUNT OF ISSUES COUNT

    getIssuesCount: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getIssuesCount Service initiated.", "PMService", "getIssuesCount", loggedUser, tenant, moduleName);
        let result;
        try {
            let majorDueDate = moment().subtract(configData.majorIssueDue, "days").format("YYYY-MM-DD");
            let otherDueDate = moment().subtract(configData.otherIssueDue, "days").format("YYYY-MM-DD");
            if (body.roles != undefined && body.roles != null && body.loggedUserId != undefined && body.loggedUserId != null) {
                if (body.roles.includes('PROJECT_MANAGER')) {
                    query = mysqlQueries.getIssuesCountByManager
                    param = [majorDueDate, otherDueDate, body.loggedUserId]
                } else if (body.roles.includes('EMPLOYEE')) {
                    query = mysqlQueries.getIssuesCountByEmp
                    param = [majorDueDate, otherDueDate, body.loggedUserId]
                }
                result = await dbOperations.executeQuery(query, param, loggedUser, "getIssuesCount", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result) {
                        let res = [];
                        res = res.concat(result.filter(x => x.SEVERITY == "CRITICAL"))
                        res = res.concat(result.filter(x => x.SEVERITY == "MAJOR"))
                        res = res.concat(result.filter(x => x.SEVERITY == "MINOR"))
                        appLogger.logMessage("info", "Successfully fetched issues count.", "PMService", "getIssuesCount", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Successfully fetched issues count.", 200, res, true, "getIssuesCount", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "Failed to  fetch issues count.", "PMService", "getIssuesCount", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Failed to  fetch issues count.", 400, null, false, "getIssuesCount", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch issues count.", "PMService", "getIssuesCount", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch issue count.", 400, null, false, "getIssuesCount", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "getIssuesCount", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getIssuesCount", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getIssuesCount", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getIssuesCount Service completed.", "PMService", "getIssuesCount", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getIssuesCount", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getIssuesCount", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },


    //GET SUBTASK DETAILS
    getSubTaskDetails: async function (body) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully fetched sub task details",
            data: []
        }
        try {

            let loggedUser = body.loggedUser
            let tenant = body.tenant
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getSubTaskDetails);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to fetch sub task due to missing parameters: " + JSON.stringify(missingParams), className, "getSubTaskDetails", body.loggedUser, body.tenant);
                    out.status = "Failed";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    let query = mysqlQueries.getSubTaskDetails;
                    let param = [body.tenantId, body.projectId, body.taskId];
                    let result = await dbOperations.executeQuery(query, param, loggedUser, "getSubTaskDetails", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != 'Error') {
                        if (result.length > 0) {

                            appLogger.logMessage("info", " Subtask details fetched   successfully", className, "getSubTaskDetails", body.loggedUser, body.tenant);
                            out.status = "Success";
                            out.message = "Subtask details fetched successfully";
                            out.data = result
                            out.statusCode = 200
                        } else {
                            appLogger.logMessage("info", "Failed to fetch sub tasks details", className, "getSubTaskDetails", body.loggedUser, body.tenant);
                            out.status = "Warning";
                            out.message = "No sub task  details available";
                            out.data = []
                            out.statusCode = 404
                        }
                    } else {
                        appLogger.logMessage("info", "Failed to fetch  sub tasks details ", className, "getSubTaskDetails", body.loggedUser, body.tenant);
                        out.status = "Warning";
                        out.message = "Failed to fetch sub tasks details ";
                        out.data = []
                        out.statusCode = 404
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to fetch subtask details", className, "getSubTaskDetails", body.loggedUser, body.tenant);
                out.status = "Failed";
                out.message = "Invalid request body";
                out.statusCode = 404
                out.data = []
            }

        } catch (error) {
            appLogger.logMessage("error", "Failed to get sub task details: " + JSON.stringify(error.message), className, "holdOrResume", req.body.loggedUser, req.body.tenant);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(body.tenant, body.loggedUser, className, "getSubTaskDetails", startDateTime, endDateTime, diffInMS);
        return out;
    },
    //ADD TASK TO MILESTONE
    addTaskToMilestone: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "addTaskToMilestone Service initiated.", "PMService", "addTaskToMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.milestoneId != undefined && body.milestoneId != null && body.tasks != undefined && body.tasks != null) {
                let tasks = JSON.parse(body.tasks)
                let query = mysqlQueries.fetchSubTaskForMilestone
                let param = [tasks, body.tenantId]
                result = await dbOperations.executeQuery(query, param, loggedUser, "addTaskToMilestone", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        for (let item of result) {
                            tasks.push(item.ID)
                        }
                    } else {
                        appLogger.logMessage("info", "No subtasks under maintask", "PMService", "addTaskToMilestone", loggedUser, tenant, moduleName);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch subtasks under maintask", "PMService", "addTaskToMilestone", loggedUser, tenant, moduleName);

                }

                query = mysqlQueries.addTaskToMilestone
                param = []
                for (let t of tasks) {
                    let record = []
                    record.push(body.tenantId)
                    record.push(body.milestoneId)
                    record.push(t)
                    record.push(moment().format('YYYY-MM-DD'))
                    record.push(body.loggedUserId)
                    record.push(body.loggedUserId)
                    param.push(record)
                    record = []
                }


                result = await dbOperations.executeQuery(query, [param], loggedUser, "addTaskToMilestone", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.affectedRows > 0) {
                        // if task added to watch list , notify watch list users on assigning 
                        //body['addedToWatchList']=true
                        if(body.addedToWatchList=='true'){
                            let nofifyResult=await supportHandler.watchListNotification(body,'add_task_milestone',body.loggedUser,body.tenant)
                            appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                        }
                        appLogger.logMessage("info", "Task added to the milestone successfully.", "PMService", "addTaskToMilestone", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Task added to the milestone successfully.", 200, result, true, "addTaskToMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("info", "Failed to  add task to milestone.", "PMService", "removeFavouriteProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Failed to  add task to milestone", 400, null, false, "addTaskToMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to add task to milestone.", "PMService", "addTaskToMilestone", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to add task to miletsone", 400, null, false, "addTaskToMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "addTaskToMilestone", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "addTaskToMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addTaskToMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "addTaskToMilestone Service completed.", "PMService", "addTaskToMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addTaskToMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addTaskToMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //delete MILESTONE
    deleteMilestone: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "deleteMilestone Service initiated.", "PMService", "deleteMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.milestoneId != undefined && body.milestoneId != null && body.projectId != undefined && body.projectId != null) {
                //let tasks=JSON.parse(body.tasks)
                result = await this.getTaskUnderMilestone(body, loggedUser, tenant);
                let result1 = await this.getIssuesUnderMilestone(body, loggedUser, tenant);
                if (result != undefined && result != null && result.data.length == 0 && result1.data.length == 0) {
                    let query = mysqlQueries.deleteMilestone
                    let param = [
                        body.milestoneId,
                        body.projectId,
                        body.tenantId]


                    result = await dbOperations.executeQuery(query, param, loggedUser, "deleteMilestone", true, [1], tenant, appLogger, meteringLogger, moduleName)
                    if (result != undefined && result != null && result != 'Error') {
                        if (result.affectedRows > 0) {
                            query = mysqlQueries.deleteTaskInMilestone
                            param = [moment().format('YYYY-MM-DD'), body.milestoneId, body.tenantId]
                            result = await dbOperations.executeQuery(query, param, loggedUser, "deleteMilestone", true, [2], tenant, appLogger, meteringLogger, moduleName)
                            if (result != undefined && result != null && result != 'Error') {
                                appLogger.logMessage("info", "Successfully removed milestone.", "PMService", "deleteMilestone", loggedUser, tenant, moduleName);
                                result = await responseHandler.sendResponse("Success", "Successfully removed milestone.", 200, result, true, "deleteMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                            } else {
                                appLogger.logMessage("info", "Failed to  remove milestone", "PMService", "deleteMilestone", loggedUser, tenant, moduleName);
                                result = await responseHandler.sendResponse("Warning", "Failed to remove milestone.", 400, null, false, "deleteMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                            }

                        } else {
                            appLogger.logMessage("info", "Failed to  remove milestone", "PMService", "deleteMilestone", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "Failed to remove milestone.", 400, null, false, "deleteMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                        }
                    } else {
                        appLogger.logMessage("info", "Failed to remove milestone.", "PMService", "deleteMilestone", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Failed to remove milestone", 400, null, false, "deleteMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to remove milestone due to tasks/issues are mapped.", "PMService", "deleteMilestone", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to remove milestone as tasks/issues are mapped.", 400, null, false, "deleteMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "deleteMilestone", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "deleteMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "deleteMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "deleteMilestone Service completed.", "PMService", "deleteMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "deleteMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "deleteMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //GET ALL TASK UNDER MILETSONE
    getTaskUnderMilestone: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getTaskUnderMilestone Service initiated.", "PMService", "getTaskUnderMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.milestoneId != undefined && body.milestoneId != null) {
                //let tasks=JSON.parse(body.tasks)

                let query = mysqlQueries.getTaskUnderMilestone
                let param = [
                    body.milestoneId,
                    body.tenantId]
                result = await dbOperations.executeQuery(query, param, loggedUser, "getTaskUnderMilestone", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        for (let data of result) {
                            let assignee=[]
                            assignee.push({ 'ID': data.ASSIGNED_TO, 'FULL_NAME': data.ASSIGNED_TO_NAME })
                            data['ASSIGNEE'] = assignee
                            let dueDate = moment(data.ESTIMATED_COMPLETION_DATE).format("YYYY-MM-DD");
                            let currentDate = moment().format("YYYY-MM-DD");
                            let diff = moment(currentDate).diff(moment(dueDate), 'days');
                            data["DUE_IN"] = diff;
                        }
                        appLogger.logMessage("info", "Successfully fetched task under milestone.", "PMService", "getTaskUnderMilestone", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Successfully fetched task under milestone.", 200, result, true, "getTaskUnderMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("info", "No task available.", "PMService", "getTaskUnderMilestone", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No task available.", 400, null, false, "getTaskUnderMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to remove milestone.", "PMService", "getTaskUnderMilestone", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch task under  milestone", 400, null, false, "getTaskUnderMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "getTaskUnderMilestone", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getTaskUnderMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getTaskUnderMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getTaskUnderMilestone Service completed.", "PMService", "getTaskUnderMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getTaskUnderMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getTaskUnderMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //REMOVE DEPENDENCY 
    removeDependancy: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "removeDependancy Service initiated.", "PMService", "removeDependancy", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.taskId != undefined && body.taskId != null) {


                let query = mysqlQueries.removeDependancy
                let param = [
                    body.loggedUserId, body.taskId,
                    body.tenantId]
                result = await dbOperations.executeQuery(query, param, loggedUser, "removeDependancy", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.affectedRows > 0) {
                        appLogger.logMessage("info", "Dependency removed successfully.", "PMService", "removeDependancy", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Dependency removed successfully.", 200, null, false, "removeDependancy", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("info", "Failed to remove dependency.", "PMService", "removeDependancy", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Failed to rremove dependency", 400, null, false, "removeDependancy", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to remove dependency.", "PMService", "removeDependancy", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to remove dependency.", 400, null, false, "removeDependancy", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "removeDependancy", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "removeDependancy", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "removeDependancy", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "removeDependancy Service completed.", "PMService", "removeDependancy", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "removeDependancy", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "removeDependancy", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getRiskIssueCountByProject: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getRiskIssueCountByProject Service initiated.", "PMService", "getRiskIssueCountByProject", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.roles != undefined && body.roles != null && body.loggedUserId != undefined && body.loggedUserId != null) {
                result = await this.getIssuesCount(body, loggedUser, tenant);
                if (result.type.toLowerCase() == "success") {
                    result = result.data
                    let groupRes = result.reduce((hash, obj) => ({ ...hash, [obj["projectName"]]: (hash[obj["projectName"]] || []).concat(obj) }), {})
                    Object.keys(groupRes).forEach(key => {
                        groupRes[key] = groupRes[key].length
                    })
                    let groupResBySeverity = result.reduce((hash, obj) => ({ ...hash, [obj["SEVERITY"]]: (hash[obj["SEVERITY"]] || []).concat(obj) }), {})
                    Object.keys(groupResBySeverity).forEach(key => {
                        groupResBySeverity[key] = groupResBySeverity[key].length
                    })
                    let groupResByStatus = result.reduce((hash, obj) => ({ ...hash, [obj["STATUS"]]: (hash[obj["STATUS"]] || []).concat(obj) }), {})
                    Object.keys(groupResByStatus).forEach(key => {
                        groupResByStatus[key] = groupResByStatus[key].length
                    })
                    obj = {
                        "TotalCount": result.length,
                        "CountByProject": groupRes,
                        "CountBySeverity": groupResBySeverity,
                        "CountByStatus": groupResByStatus
                    }
                    appLogger.logMessage("info", "Successfully fetched risk issues count", "PMService", "getRiskIssueCountByProject", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Success", "Successfully fetched  risk issues count", 200, obj, true, "getRiskIssueCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    appLogger.logMessage("info", "Failed to fetch risk issues count.", "PMService", "getRiskIssueCountByProject", loggedUser, tenant, moduleName);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "getRiskIssueCountByProject", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getRiskIssueCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getRiskIssueCountByProject", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getRiskIssueCountByProject Service completed.", "PMService", "getRiskIssueCountByProject", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getRiskIssueCountByProject", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getRiskIssueCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getRiskTasksCountByProject: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getRiskTasksCountByProject Service initiated.", "PMService", "getRiskTasksCountByProject", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.roles != undefined && body.roles != null && body.loggedUserId != undefined && body.loggedUserId != null) {
                result = await this.delayedTaskCount(body, loggedUser, tenant)
                if (result.type.toLowerCase() == "success") {
                    result = result.data
                    let groupRes = result.reduce((hash, obj) => ({ ...hash, [obj["project_name"]]: (hash[obj["project_name"]] || []).concat(obj) }), {})
                    Object.keys(groupRes).forEach(key => {
                        groupRes[key] = groupRes[key].length
                    })
                    let groupResByStatus = result.reduce((hash, obj) => ({ ...hash, [obj["DISPLAY_VALUE"]]: (hash[obj["DISPLAY_VALUE"]] || []).concat(obj) }), {})
                    Object.keys(groupResByStatus).forEach(key => {
                        groupResByStatus[key] = groupResByStatus[key].length
                    })
                    let groupResBySeverity = {
                        "Risk Tasks": result.filter(x => moment(x.ACTUAL_COMPLETION_DATE).format("YYYY-MM-DD") == moment().format("YYYY-MM-DD")),
                        "Overdue Tasks": result.filter(x => moment(x.ACTUAL_COMPLETION_DATE).format("YYYY-MM-DD") < moment().format("YYYY-MM-DD"))
                    }
                    Object.keys(groupResBySeverity).forEach(key => {
                        groupResBySeverity[key] = groupResBySeverity[key].length
                    })
                    obj = {
                        "TotalCount": result.length,
                        "CountByProject": groupRes,
                        "CountBySeverity": groupResBySeverity,
                        "CountByStatus": groupResByStatus
                    }
                    appLogger.logMessage("info", "Successfully fetched risk tasks count", "PMService", "getRiskTasksCountByProject", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Success", "Successfully fetched risk tasks count", 200, obj, true, "getRiskTasksCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    appLogger.logMessage("info", "Failed to fetch risk tasks count.", "PMService", "getRiskTasksCountByProject", loggedUser, tenant, moduleName);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "getRiskTasksCountByProject", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getRiskTasksCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getRiskTasksCountByProject", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getRiskTasksCountByProject Service completed.", "PMService", "getRiskTasksCountByProject", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getRiskTasksCountByProject", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getRiskTasksCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    //GET TASK AND WORKLOG IMAGES
    getTaskImages: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getTaskImages Service initiated.", "PMService", "getTaskImages", loggedUser, tenant, moduleName);
        let result;
        let res = {}
        try {
            if (body.actionId != undefined && body.actionId != null && body.actionCode != undefined && body.actionCode != null) {
                let actionId = [];
                let imgArray = []
                actionId = body.actionId
                let query;
                let param = []
                if (body.actionCode == 'A1001' || body.actionCode == 'A1003' || body.actionCode == 'A1003') {
                    query = mysqlQueries.getTaskImages
                    param = [actionId, body.tenantId, actionId, body.tenantId]
                } else if (body.actionCode == 'A1005') {
                    query = mysqlQueries.getIssueImages
                    param = [actionId, body.tenantId]
                }else if (body.actionCode == 'A1006') {
                    query = mysqlQueries.getExpenseImages
                    param = [actionId, body.tenantId]
                }
                let attachmentsData = await dbOperations.executeQuery(query, param, loggedUser, "getTaskImages", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (attachmentsData != null && attachmentsData != undefined && attachmentsData.length > 0) {
                    for (let data of attachmentsData) {
                      let typeArray = data.FILE_NAME.split('.')
                      let type = typeArray[typeArray.length-1]                
                        if (type.toLowerCase() == 'png' || type.toLowerCase() == 'jpeg' || type.toLowerCase() == 'jpg') {
                            let path = data.FILE_URL.split('=').pop()
                            //path='C:'+path

                            const imageData = fs.readFileSync(path, { encoding: 'base64' });
                            let image = `data:image/${type};base64,${imageData}`
                            imgArray.push({
                                'IMAGE_FILE': image, 'FILE_TYPE': type,
                                'FILE_NAME': data['FILE_NAME'], 'DESCRIPTION': data['DESCRIPTION'], 'FILE_URL': data['FILE_URL'],
                                'ACTION_CODE': data['ACTION_CODE']
                            })
                        }

                    }
                    res['IMAGE_FILE'] = imgArray
                    res['ATTACHMENT'] = attachmentsData

                    result = await responseHandler.sendResponse('Success', "Attachment found acuucesfully.", 200, res, false, "getTaskAttachments", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                } else {
                    result = await responseHandler.sendResponse('Warning', "No data found.", 400, [], false, "getTaskImages", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "getTaskImages", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getTaskImages", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getTaskImages", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getTaskImages Service completed.", "PMService", "getTaskImages", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getTaskImages", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getTaskImages", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //SEND ATTACHMENTS OF TASK
    sendAttachment: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "sendAttachment Service initiated.", "PMService", "sendAttachment", loggedUser, tenant, moduleName);
        let result;
        let res = {}

        try {
            if (body.actionId != undefined && body.actionId != null) {
                let actionId = [];
                let imgArray = [], filearray = []
                actionId = body.actionId
                let attachmentsData = await dbOperations.executeQuery(mysqlQueries.getTaskImages, [actionId, body.tenantId, actionId, body.tenantId], loggedUser, "getTaskAttachments", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (attachmentsData != null && attachmentsData != undefined && attachmentsData.length > 0) {
                    for (let data of attachmentsData) {
                        let type = data.FILE_NAME.split('.')[1]
                        let path = data.FILE_URL.split('=').pop()
                        if (type.toLowerCase() == 'png' || type.toLowerCase() == 'jpeg' || type.toLowerCase() == 'jpg') {
                            //let path=data.FILE_URL.split('=').pop()
                            path = 'C:' + path

                            const imageData = fs.readFileSync(path, { encoding: 'base64' });
                            let image = `data:image/${type};base64,${imageData}`

                            filearray.push({ 'ATTACHMENT': image, 'NAME': data.FILE_NAME })

                        }
                        else {
                            const buffer = Buffer.from(fs.createReadStream(path).toString('base64'));
                            filearray.push({ 'ATTACHMENT': buffer, 'NAME': data.FILE_NAME })

                        }
                    }
                    await this.saveAttachment(filearray, body.loggedUser, body.tenant)

                    res['ATTACHMENTS'] = filearray

                    result = await responseHandler.sendResponse('Success', "Attachment found acuucesfully.", 200, res, false, "getTaskAttachments", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                } else {
                    result = await responseHandler.sendResponse('Warning', "No data found.", 400, [], false, "getTaskAttachments", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "getTaskImages", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getTaskImages", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "sendAttachment", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "sendAttachment Service completed.", "PMService", "sendAttachment", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "sendAttachment", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "sendAttachment", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //SAVE ATTACHMENTS TO FOLDER
    saveAttachment: async function (attachment, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "sendAttachment Service initiated.", "PMService", "sendAttachment", loggedUser, tenant, moduleName);
        let result;
        try {
            const currentFolder = process.cwd();
            for (let data of attachment) {
                // Generate a file path for the attachment in the current folder
                const filePath = path.join(currentFolder, data.NAME);
                fs.writeFileSync(filePath, data.ATTACHMENT)

            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "sendAttachment", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "sendAttachment Service completed.", "PMService", "sendAttachment", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "sendAttachment", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "sendAttachment", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        //return result;
    },

    //API TO ARCHIVE PROJECTS
    archiveProject: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "archiveProject Service initiated.", "PMService", "archiveProject", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.projectId != undefined && body.projectId != null) {


                let query = mysqlQueries.isClosedOrCompleted
                let param = [
                    body.projectId,
                    body.tenantId]
                result = await dbOperations.executeQuery(query, param, loggedUser, "archiveProject", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result[0].PROJECT_STATUS_TYPE_CODE == 'COM' || result[0].PROJECT_STATUS_TYPE_CODE == 'CLOSED') {
                        appLogger.logMessage("info", "Project is completed or closed ", "PMService", "archiveProject", loggedUser, tenant, moduleName);
                        let query = mysqlQueries.archiveProject
                        let param = [
                            body.loggedUserId,
                            body.projectId,
                            body.tenantId]

                        result = await dbOperations.executeQuery(query, param, loggedUser, "archiveProject", false, null, tenant, appLogger, meteringLogger, moduleName)
                        if (result != undefined && result != null && result != 'Error') {
                            if (result.affectedRows > 0) {
                                result = await responseHandler.sendResponse("Success", "Project archived successfully.", 200, null, false, "archiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Project archived successfully. ", "PMService", "archiveProject", loggedUser, tenant, moduleName);

                            } else {
                                result = await responseHandler.sendResponse("Warning", " Failed to  archive project.", 200, null, false, "archiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Failed to  archive project.", "PMService", "archiveProject", loggedUser, tenant, moduleName);

                            }
                        } else {
                            result = await responseHandler.sendResponse("Warning", " Failed to  archive project.", 200, null, false, "archiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            appLogger.logMessage("info", "Failed to  archive project.", "PMService", "archiveProject", loggedUser, tenant, moduleName);

                        }


                    } else {
                        appLogger.logMessage("info", "Project is not closed or completed.", "PMService", "archiveProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Project is not closed or completed.", 400, null, false, "archiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to get status of project", "PMService", "archiveProject", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to archive project.", 400, null, false, "archiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "archiveProject", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "archiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "archiveProject", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "archiveProject Service completed.", "PMService", "archiveProject", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "archiveProject", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "archiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    //API TO UNARCHIVE PROJECTS
    unArchiveProject: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "unArchiveProject Service initiated.", "PMService", "unArchiveProject", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.projectId != undefined && body.projectId != null) {
                let query = mysqlQueries.isArchived
                let param = [
                    body.projectId,
                    body.tenantId]
                result = await dbOperations.executeQuery(query, param, loggedUser, "unArchiveProject", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result[0].IS_ARCHIVED == 'Y') {
                        let query = mysqlQueries.unArchiveProject
                        let param = [
                            body.loggedUserId,
                            body.projectId,
                            body.tenantId]

                        result = await dbOperations.executeQuery(query, param, loggedUser, "unArchiveProject", false, null, tenant, appLogger, meteringLogger, moduleName)
                        if (result != undefined && result != null && result != 'Error') {
                            if (result.affectedRows > 0) {
                                result = await responseHandler.sendResponse("Success", "Project unarchived successfully.", 200, null, false, "unArchiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Project unarchived successfully. ", "PMService", "unArchiveProject", loggedUser, tenant, moduleName);

                            } else {
                                result = await responseHandler.sendResponse("Warning", " Failed to  unarchive project.", 200, null, false, "unArchiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Failed to  unarchive project.", "PMService", "unArchiveProject", loggedUser, tenant, moduleName);

                            }
                        } else {
                            result = await responseHandler.sendResponse("Warning", " Failed to  unarchive project.", 200, null, false, "unArchiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            appLogger.logMessage("info", "Failed to  unarchive project.", "PMService", "unArchiveProject", loggedUser, tenant, moduleName);

                        }


                    } else {
                        appLogger.logMessage("info", "Project is not archived.", "PMService", "archiveProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Project is not archived.", 400, null, false, "unArchiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to unarchive project.", "PMService", "archiveProject", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to unarchive project..", 400, null, false, "unArchiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "archiveProject", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "unArchiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "unArchiveProject", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "removeDependancy Service completed.", "PMService", "unArchiveProject", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "unArchiveProject", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "unArchiveProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //CREATE GROUP
    createGroup: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "createGroup Service initiated.", "PMService", "createGroup", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.projectId != undefined && body.projectId != null && body.groupName != undefined && body.groupName != null &&
                body.groupDescription != undefined && body.groupDescription != null && body.groupStatus != undefined && body.groupStatus != null) {

                let isNameExists = await supportHandler.isGroupNameExists(body.groupName, body.projectId, body.tenantId, loggedUser, tenant)
                if (isNameExists == null) {
                    appLogger.logMessage("info", "Failed to check group exists", "PMService", "createGroup", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to check group exists.", 400, null, false, "createGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                } else {
                    if (isNameExists.length == 0) {
                        let newGroupOrder
                        fetchGroup = await dbOperations.executeQuery(mysqlQueries.fetchGroups, [body.projectId, body.tenantId], loggedUser, "createGroup", false, null, tenant, appLogger, meteringLogger, moduleName)
                        if (fetchGroup != null && fetchGroup != undefined && fetchGroup != 'Error' && fetchGroup.length > 0) {
                            for (const [index, data] of fetchGroup.entries()) {
                                if (data.GROUP_ORDER == null || data.GROUP_ORDER == undefined) {
                                    let order = index+1
                                    result = await dbOperations.executeQuery(mysqlQueries.updateGroupOrder, [order, body.projectId, body.tenantId, data.ID], body.loggedUser, "updateGroupOrder", false, null, body.tenant, appLogger, meteringLogger, moduleName);
                                    if (result.affectedRows == 0 && result == null && result == 'Error' && result == undefined) {
                                        break;
                                    }
                                }
                            }
                            let lastGroup = fetchGroup.length
                            newGroupOrder = lastGroup + 1
                        }
                        let query = mysqlQueries.createGroup
                        let param = [
                            body.tenantId,
                            body.projectId,
                            body.groupName,
                            body.groupDescription,
                            body.groupStatus,
                            newGroupOrder,
                            body.loggedUserId,
                            body.loggedUserId
                        ]
                        result = await dbOperations.executeQuery(query, param, loggedUser, "createGroup", false, null, tenant, appLogger, meteringLogger, moduleName)
                        if (result != undefined && result != null && result != 'Error') {
                            if (result.affectedRows > 0) {
                                await BudgetSupport.addClassBudget(result.insertId, body.classType, body.tenantId, body.currencyCode, body.type, body.maxAmount, body.minAmount, body.loggedUserId, loggedUser, tenant, null, null, body.projectId);
                                let res = []
                                res.push({ 'ID': result.insertId })
                                appLogger.logMessage("info", "Group created successfully.", "PMService", "createGroup", loggedUser, tenant, moduleName);
                                result = await responseHandler.sendResponse("Success", "Group created successfully.", 400, res, true, "createGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                            }
                        } else {
                            appLogger.logMessage("info", "Failed to create group", "PMService", "createGroup", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "Failed to create group.", 400, null, false, "createGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    } else {
                        appLogger.logMessage("info", " Group name exists.", "PMService", "createGroup", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Group name exists.", 400, isNameExists, true, "createGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                }




            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "createGroup", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "createGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "createGroup", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "createGroup Service completed.", "PMService", "createGroup", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "createGroup", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "createGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },


    //FETCH GROUP
    fetchGroup: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "fetchGroup Service initiated.", "PMService", "fetchGroup", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.projectId != undefined && body.projectId != null) {
                let query = mysqlQueries.fetchGroup
                let param = [
                    body.projectId,
                    body.tenantId
                ]
                result = await dbOperations.executeQuery(query, param, loggedUser, "fetchGroup", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", "Group fetched  successfully.", "PMService", "fetchGroup", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Group fetched successfully.", 200, result, true, "createGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", " No group available.", "PMService", "fetchGroup", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", " No group available.", 400, null, false, "fetchGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch group", "PMService", "fetchGroup", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch group.", 400, null, false, "fetchGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "fetchGroup", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "fetchGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "fetchGroup", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "fetchGroup Service completed.", "PMService", "fetchGroup", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "fetchGroup", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "fetchGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    getProjectsOfEmployee: async function (body) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully fetched getProjectsOfEmployee",
            data: []
        }
        try {
            let loggedUser = body.loggedUser
            let tenant = body.tenant
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getProjectsOfEmployee);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("error", "Failed to getProjectsOfEmployee due to missing parameters: " + JSON.stringify(missingParams), className, "getProjectsOfEmployee", body.loggedUser, body.tenant);
                    out.status = "Failure";
                    out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {
                    let query = mysqlQueries.getProjectsOfEmployee;
                    let param = [body.loggedUserId];
                    let result = await dbOperations.executeQuery(query, param, loggedUser, "getProjectsOfEmployee", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != 'Error') {
                        if (result.length > 0) {
                            appLogger.logMessage("info", " getProjectsOfEmployee fetched successfully", className, "getProjectsOfEmployee", body.loggedUser, body.tenant);
                            out.status = "Success";
                            out.message = "getProjectsOfEmployees fetched successfully";
                            out.data = result
                            out.statusCode = 200
                        } else {
                            appLogger.logMessage("info", "Failed to getProjectsOfEmployee", className, "getProjectsOfEmployee", body.loggedUser, body.tenant);
                            out.status = "Warning";
                            out.message = "getProjectsOfEmployee details not available";
                            out.data = []
                            out.statusCode = 404
                        }
                    } else {
                        appLogger.logMessage("info", "Failed to fetch  sub tasks details ", className, "getProjectsOfEmployee", body.loggedUser, body.tenant);
                        out.status = "Warning";
                        out.message = "Failed to getProjectsOfEmployee ";
                        out.data = []
                        out.statusCode = 404
                    }
                }
            } else {
                appLogger.logMessage("error", "Failed to getProjectsOfEmployee", className, "getProjectsOfEmployee", body.loggedUser, body.tenant);
                out.status = "Failure";
                out.message = "Invalid request body";
                out.statusCode = 404
                out.data = []
            }

        } catch (error) {
            appLogger.logMessage("error", "Failed to getProjectsOfEmployee: " + JSON.stringify(error.message), className, "getProjectsOfEmployee", req.body.loggedUser, req.body.tenant);
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(body.tenant, body.loggedUser, className, "getProjectsOfEmployee", startDateTime, endDateTime, diffInMS);
        return out;
    },
    getIssueCountByType: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getIssueCountByType Service initiated.", "PMService", "getIssueCountByType", loggedUser, tenant, moduleName);
        let result, keyName;
        try {
            if (data.projectId != undefined && data.projectId != null) {
                result = await dbOperations.executeQuery(mysqlQueries.getIssueCountByStatus, [data.projectId], loggedUser, "getIssueByProject", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null) {
                    if (result.length > 0) {
                        result = await responseHandler.sendResponse("Success", "Successfully fetched issues count by project id.", 200, result[0], true, "getIssueCountByType", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        result = await responseHandler.sendResponse("Success", "No issues found.", 200, null, false, "getIssueCountByType", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to fetched issues by project id.", 400, null, false, "getIssueCountByType", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getIssueCountByType", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getIssueCountByType", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getIssueCountByType Service completed.", "PMService", "getIssueCountByType", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getIssueCountByType", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getIssueCountByType", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    //CHANGE MILESTONE OF TASK
    changeTaskMilestone: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "changeTaskMilestone Service initiated.", "PMService", "changeTaskMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.milestoneId != undefined && body.milestoneId != null && body.tasks != undefined && body.tasks != null) {
                let tasks = body.tasks.split(",")
                let query = mysqlQueries.fetchSubTaskForMilestone
                let param = [tasks, body.tenantId]
                result = await dbOperations.executeQuery(query, param, loggedUser, "changeTaskMilestone", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        tasks = tasks.concat(result.map(x => Number(x.ID)))
                    } else {
                        appLogger.logMessage("info", "No subtasks under maintask", "PMService", "changeTaskMilestone", loggedUser, tenant, moduleName);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch subtasks under maintask", "PMService", "changeTaskMilestone", loggedUser, tenant, moduleName);
                }
                query = mysqlQueries.changeTaskMilestone
                query = query.replace('@StrParam1', "'" + tasks.join("','") + "'")
                result = await dbOperations.executeQuery(query, [body.milestoneId], loggedUser, "changeTaskMilestone", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.affectedRows > 0) {
                        appLogger.logMessage("info", "Task added to the milestone successfully.", "PMService", "changeTaskMilestone", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Task added to the milestone successfully.", 200, result, true, "changeTaskMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "Failed to  add task to milestone.", "PMService", "removeFavouriteProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Failed to  add task to milestone", 400, null, false, "changeTaskMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to add task to milestone.", "PMService", "changeTaskMilestone", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to add task to miletsone", 400, null, false, "changeTaskMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "changeTaskMilestone", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "changeTaskMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "changeTaskMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "changeTaskMilestone Service completed.", "PMService", "changeTaskMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "changeTaskMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "changeTaskMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    //CHANGE MILESTONE OF TASK
  removeTaskFromMilestone: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "removeTaskFromMilestone Service initiated.", "PMService", "removeTaskFromMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.milestoneId != undefined && body.milestoneId != null && body.taskId != undefined && body.taskId != null) {
                let taskIdArray = JSON.parse(body.taskId)
                let query = mysqlQueries.getMilestoneSubTask
                let param = [taskIdArray, body.tenantId]
                result = await dbOperations.executeQuery(query, param, loggedUser, "removeTaskFromMilestone", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        for (let item of result) {
                            taskIdArray.push(item.ID)
                        }
                    } else {
                        appLogger.logMessage("info", "No sub task exists.", "PMService", "removeTaskFromMilestone", loggedUser, tenant, moduleName);

                    }
                } else {
                    appLogger.logMessage("info", "Error occured while fetching sub task.", "PMService", "removeTaskFromMilestone", loggedUser, tenant, moduleName);

                }
                query = mysqlQueries.removeTaskFromMilestone
                param = [moment().format('YYYY-MM-DD'), taskIdArray, body.milestoneId, body.tenantId]
                result = await dbOperations.executeQuery(query, param, loggedUser, "removeTaskFromMilestone", true, [2], tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.affectedRows > 0) {
                        appLogger.logMessage("info", "Task removed from milestone. ", "PMService", "removeTaskFromMilestone", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Task removed from milestone successfully.", 200, null, false, "removeTaskFromMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        // if task added to watch list , notify watch list users on assigning 
                        //body['addedToWatchList']=true 
                        // if (body.action == 'multipleDelete') {
                        //    await supportHandler.notifyWatchlistUsersinMilestone(body)
                        // }else if(body.action == undefined){
                        //     if(body.addedToWatchList=='true'){
                        //         let nofifyResult=await supportHandler.watchListNotification(body,'remove_task_milestone',body.loggedUser,body.tenant)
                        //         appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                        //     }
                        // }

                    } else {
                        result = await responseHandler.sendResponse("Warning", "Failed to remove task from milestone", 400, null, false, "removeTaskFromMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        appLogger.logMessage("info", "Failed to dremove task from milestone.", "PMService", "removeTaskFromMilestone", loggedUser, tenant, moduleName);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to remove task from milestone", 400, null, false, "removeTaskFromMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    appLogger.logMessage("info", "Failed to dremove task from milestone", "PMService", "removeTaskFromMilestone", loggedUser, tenant, moduleName);
                }

            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "removeTaskFromMilestone", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "removeTaskFromMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "removeTaskFromMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "removeTaskFromMilestone Service completed.", "PMService", "removeTaskFromMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "removeTaskFromMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "removeTaskFromMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },


    // FETCH RULES FOR SETIING A TASK AS RECURRING TASK
    fetchRecurringRules: async function (body, loggedUser, tenant) {
        delete body['token']
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "fetchRecurringRules Service initiated.", "PMService", "fetchRecurringRules", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.tenantId != undefined && body.tenantId != null) {
                let query = mysqlQueries.fetchRecurringRules
                let param = [
                    body.tenantId
                ]
                result = await dbOperations.executeQuery(query, param, loggedUser, "fetchRecurringRules", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", " Recurring rules fetched  successfully.", "PMService", "fetchRecurringRules", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Recurring rules fetched  successfully.", 200, result, true, "createGroup", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", " No recurring rules available.", "PMService", "fetchRecurringRules", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", " No recurring rules available.", 400, null, false, "fetchRecurringRules", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch recurring rules", "PMService", "fetchRecurringRules", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch recurring rules.", 400, null, false, "fetchRecurringRules", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "fetchRecurringRules", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "fetchRecurringRules", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "fetchRecurringRules", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "fetchRecurringRules Service completed.", "PMService", "fetchRecurringRules", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "fetchRecurringRules", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "fetchRecurringRules", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },


    // ADD TASK TO RECURRING TABLE
    addRecurringData: async function (newTaskId, data, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "addRecurringData Service initiated.", "PMService", "addRecurringData", loggedUser, tenant, moduleName);
        let result;
        try {

            // data.ruleObj=JSON.parse(data.ruleObj)
            let nextOccuranceDate = moment(data.estimatedStartDate).add(data.ruleObj.VALUE, 'd').format('YYYY-MM-DD')
            let query = mysqlQueries.addRecurringData
            let record = [data.tenantId,
                newTaskId, data.ruleObj.ID,
                nextOccuranceDate, data.estimatedStartDate,
            data.recurringEndDate, data.loggedUserId, data.loggedUserId, 1
            ]
            let param = []
            param.push(record)
            result = await dbOperations.executeQuery(query, [param], loggedUser, "addRecurringData", false, null, tenant, appLogger, meteringLogger, moduleName)
            if (result != undefined && result != null && result != 'Error') {
                if (result.affectedRows > 0) {
                    appLogger.logMessage("info", "Task set as recurring task.", "PMService", "addRecurringData", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Success", "Task set as recurring task.", 200, result, true, "addRecurringData", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    appLogger.logMessage("info", "Failed to set the task as recurring task.", "PMService", "addRecurringData", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", " Failed to set the task as recurring task.", 400, null, false, "addRecurringData", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                }
            } else {
                appLogger.logMessage("info", "Failed to set the task as recurring task.", "PMService", "addRecurringData", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Failed to set the task as recurring task.", 400, null, false, "addRecurringData", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addRecurringData", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "addRecurringData Service completed.", "PMService", "fetchRecurringRules", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addRecurringData", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addRecurringData", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //ADD SUBTASK TO RECURRING TABLE IF ITS MAIN TASK IS IN RECURRING
    isRecurringTask: async function (newTaskId, body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Recurring task fetched. Service initiated.", "PMService", "isRecurringTask", loggedUser, tenant, moduleName);
        let result;
        try {
            if (newTaskId != undefined && newTaskId != null && body != undefined && body != null) {
                if (body.ruleObj != undefined && body.ruleObj != null) {
                    //body.ruleObj=JSON.parse(body.ruleObj)
                    let recurringResult
                    if (body.type == "SUB") {
                        let mainTaskId = body.mainTaskId
                        let query = mysqlQueries.getRecurringData
                        let param = [mainTaskId, body.tenantId]
                        result = await dbOperations.executeQuery(query, param, loggedUser, "isRecurringTask", false, null, tenant, appLogger, meteringLogger, moduleName)
                        if (result != undefined && result != null && result != 'Error') {
                            if (result.length > 0) {
                                appLogger.logMessage("info", "Recurring task fetched.", "PMService", "isRecurringTask", loggedUser, tenant, moduleName);
                                // call function to add entry in recurring table
                                recurringResult = await this.addRecurringData(newTaskId, body, loggedUser, tenant)

                                //result = await responseHandler.sendResponse("Success", "Recurring task fetched.", 200, result, true, "addRecurringData", tenant, loggedUser, moduleName,appLogger,meteringLogger);
                            } else {
                                appLogger.logMessage("info", "Main task is not a recurring task.", "PMService", "isRecurringTask", loggedUser, tenant, moduleName);
                                result = await responseHandler.sendResponse("Warning", " Main task is not a recurring task.", 400, null, false, "isRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                            }
                        }

                    } else if (body.type == "MAIN") {
                        if (body.ruleObj != undefined && body.ruleObj != null) {
                            // check whether new task  is recurring task
                            recurringResult =  await this.addRecurringData(newTaskId, body, loggedUser, tenant)
                        }
                        result = recurringResult
                    }
                } else {
                    appLogger.logMessage("info", "Task is not a recurring task.", "PMService", "isRecurringTask", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Task is not a recurring task.", 400, null, false, "isRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }

            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "isRecurringTask", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "isRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "isRecurringTask", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "isRecurringTask Service completed.", "PMService", "isRecurringTask", loggedUser, tenant, moduleName, moduleName);

        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "isRecurringTask", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "isRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //EDIT RECURRING TASK DATA
    editRecurringTask: async function (data, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Recurring task fetched. Service initiated.", "PMService", "editRecurringTask", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.ruleObj != undefined && body.ruleObj != null) {

            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "setSubTaskAsRecurring", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "setSubTaskAsRecurring Service completed.", "PMService", "setSubTaskAsRecurring", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "setSubTaskAsRecurring", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "setSubTaskAsRecurring", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    populateRecurringTask: async function (currentdate, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "populateRecurringTask Service initiated.", "PMService", "populateRecurringTask", loggedUser, tenant, moduleName);
        let result;
        try {
            let validDay;
            let weekDay = new Date(currentdate).toLocaleString("default", { weekday: "long" })
            result = await dbOperations.executeQuery(mysqlQueries.getRecurringTasks, [currentdate, currentdate], loggedUser, "getRecurringTasks", false, null, tenant, appLogger, meteringLogger, moduleName)
            if (result != undefined && result != null) {
                if (result.length > 0) {
                    appLogger.logMessage("debug", "Successfully fetched recurring tasks: " + JSON.stringify(result), "PMService", "populateRecurringTask", loggedUser, tenant, moduleName, moduleName);
                    // group based on rule type eg: daily, weekly etc.
                    let groupRes = result.reduce((hash, obj) => ({ ...hash, [obj["RULE_NAME"]]: (hash[obj["RULE_NAME"]] || []).concat(obj) }), {})
                    for (let type in groupRes) {
                        validDay = false;
                        if (type != "Daily") {
                            if (type == "Weekday") {
                                // exclude sat & sun if type is weekday
                                if (weekDay != "Saturday" && weekDay != "Sunday")
                                    validDay = true;
                            } else {
                                // exclude sun for other types except daily and weekday
                                if (weekDay != "Sunday")
                                    validDay = true;
                            }
                        } else {
                            validDay = true;
                        }
                        result = await supportHandler.populateTasks(validDay, currentdate, groupRes, type, loggedUser, tenant);
                    }
                    result = await responseHandler.sendResponse("Success", "Successfully created recurrsive tasks.", 200, null, false, "populateRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Success", "No recurring tasks found.", 200, null, false, "getRecurringTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Failed to fetched recurring tasks.", 400, null, false, "getRecurringTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "populateRecurringTask", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "populateRecurringTask Service completed.", "PMService", "populateRecurringTask", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "populateRecurringTask", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "populateRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    //FETCH RECURRING TASK UNDER PROJECT
    recurringTaskByProject: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "recurringTaskByProject service initiated", "PMService", "recurringTaskByProject", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.projectId != undefined && body.projectId != null) {
                let query = mysqlQueries.recurringTaskByProject
                let param = [body.tenantId, body.projectId]
                result = await dbOperations.executeQuery(query, param, loggedUser, "recurringTaskByProject", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", "Recurring task fetched successfully.", "PMService", "recurringTaskByProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Recurring task fetched successfully.", 200, result, true, "recurringTaskByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("info", "Failed to fetch recurring task.", "PMService", "recurringTaskByProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No recurring task available.", 400, null, false, "recurringTaskByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch recurring task.", "PMService", "recurringTaskByProject", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch recurring task.", 400, null, false, "recurringTaskByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }

            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "recurringTaskByProject", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "recurringTaskByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "recurringTaskByProject", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "recurringTaskByProject Service completed.", "PMService", "recurringTaskByProject", loggedUser, tenant, moduleName, moduleName);

        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "recurringTaskByProject", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "recurringTaskByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //FETCH RECURRING TASK UNDER PROJECT
    getRecurringSubTask: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getRecurringSubTask service initiated", "PMService", "getRecurringSubTask", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.projectId != undefined && body.projectId != null) {
                let query = mysqlQueries.getRecurringSubTask
                let param = [body.taskId, body.tenantId];
                result = await dbOperations.executeQuery(query, param, loggedUser, "getRecurringSubTask", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", "Recurring task fetched successfully.", "PMService", "getRecurringSubTask", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Recurring task fetched successfully.", 200, result, true, "getRecurringSubTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("info", "Failed to fetch recurring task.", "PMService", "getRecurringSubTask", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No recurring task available.", 400, null, false, "getRecurringSubTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch recurring task.", "PMService", "getRecurringSubTask", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch recurring task.", 400, null, false, "getRecurringSubTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }

            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "getRecurringSubTask", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getRecurringSubTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getRecurringSubTask", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getRecurringSubTask Service completed.", "PMService", "getRecurringSubTask", loggedUser, tenant, moduleName, moduleName);

        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getRecurringSubTask", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getRecurringSubTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    stopRecurringTask: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "stopRecurringTask service initiated", "PMService", "stopRecurringTask", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.taskId != undefined && body.taskId != null) {
                let param = String(body.taskId).split(",");
                let query = mysqlQueries.getTaskNSubTaskIds;
                query = query.split("@StrParam1").join("'" + param.join("','") + "'")
                result = await dbOperations.executeQuery(query, [], loggedUser, "getTaskNSubTaskIds", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("debug", "Recurring task ids : " + JSON.stringify(result), "PMService", "stopRecurringTask", loggedUser, tenant, moduleName);
                        query = mysqlQueries.stopRecurringTask
                        query = query.replace("@StrParam1", "'" + result.map(x => x.ID).join("','") + "'")
                        result = await dbOperations.executeQuery(query, [], loggedUser, "stopRecurringTask", false, null, tenant, appLogger, meteringLogger, moduleName)
                        if (result != undefined && result != null && result.affectedRows > 0) {
                            appLogger.logMessage("info", "Successfully stopped Recurring task.", "PMService", "stopRecurringTask", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Success", "Successfully stopped Recurring task.", 200, null, false, "stopRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("info", "Failed to stop Recurring task.", "PMService", "stopRecurringTask", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "Failed to stop Recurring task.", 400, null, false, "stopRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    } else {
                        appLogger.logMessage("info", "No recurring task available.", "PMService", "stopRecurringTask", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No recurring task available.", 400, null, false, "stopRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to stop Recurring task.", "PMService", "stopRecurringTask", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to stop Recurring task.", 400, null, false, "stopRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "stopRecurringTask", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "stopRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "stopRecurringTask", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "stopRecurringTask Service completed.", "PMService", "stopRecurringTask", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "stopRecurringTask", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "stopRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    postponeTask: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "postponeTask function called with the payload: " + JSON.stringify(req.body), className, "postponeTask", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully postponed the task",
            data: []
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.postponeTask);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to postpone task due to missing parameters: " + JSON.stringify(missingParams), className, "postponeTask", loggedUser, tenant, moduleName);
                    out.status = "Warning"; out.message = "Missing parameters: " + JSON.stringify(missingParams);

                } else {
                    let query = mysqlQueries.postponeTask;
                    let param = [
                        body.durationInDays,
                        body.taskId
                    ];
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "postponeTask", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result.affectedRows > 0) {
                            appLogger.logMessage("info", "task postponed successfully", className, "postponeTask", loggedUser, tenant, moduleName);
                            let fetchDates = mysqlQueries.getUpdatedTaskDates;
                            let dates = await dbOperations.executeQuery(fetchDates, [body.taskId], body.loggedUser, "fetchUpdatedDates", false, null, body.tenant, appLogger, meteringLogger, moduleName);
                            if (dates != null && dates != undefined && dates != "error") {
                                out.status = "Success"; out.message = "Successfully postponed the task"; out.data = { startDate: moment(dates[0].ESTIMATED_START_DATE, "YYYY-MM-DD").format("YYYY-MM-DD"), endDate: moment(dates[0].ESTIMATED_COMPLETION_DATE, "YYYY-MM-DD").format("YYYY-MM-DD") };
                            } else {
                                out.status = "Failed"; out.message = "Failed to postpone the task due to invalid data received from the server";
                            }
                        } else {
                            appLogger.logMessage("debug", "Failed to postpone the task . Result received after executing the query: " + JSON.stringify(result), className, "postponeTask", body.loggedUser, tenant, moduleName);
                            out.status = "Failed"; out.message = "Failed to postpone the task";
                        }
                    } else {
                        out.status = "Failed";
                        out.message = "Failed to postpone the task due to invalid data received from the server";
                        appLogger.logMessage("debug", out.message, className, "postponeTask", body.loggedUser, body.tenant, moduleName);
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to update project details due to invalid request body", className, "postponeTask", loggedUser, tenant, moduleName);
                out.status = "Failed";
                out.message = "Failed to update project details due to invalid request body";
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "postponeTask", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to update project details due to: " + JSON.stringify(error.message), className, "postponeTask", req.body.loggedUser, moduleName);
            out.status = "Failed";
            out.message = "Failed to postpone the task due to: " + JSON.stringify(error.message);
        }

        return out;
    },
    addMultiReccTask: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "addMultiReccTask service initiated", "PMService", "addMultiReccTask", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.taskId != undefined && body.taskId != null) {
                let nextOccuranceDate;
                let param = JSON.parse(body.taskId);
                let query = mysqlQueries.getTaskNSubTaskIds;
                body.ruleObj = JSON.parse(body.ruleObj)
                query = query.split("@StrParam1").join("'" + param.join("','") + "'")
                result = await dbOperations.executeQuery(query, [], loggedUser, "getTaskNSubTaskIds", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("debug", "Recurring task ids : " + JSON.stringify(result), "PMService", "addMultiReccTask", loggedUser, tenant, moduleName);
                        let updateNewRecTasksDate = mysqlQueries.updateNewRecTasksDate
                        updateNewRecTasksDate = updateNewRecTasksDate.replace("@StrParam1", "'" + result.map(x => x.ID).join("','") + "'")
                        let param = []
                        for (let i of result) {
                            nextOccuranceDate = moment(body.estimatedStartDate).add(body.ruleObj.VALUE, 'd').format('YYYY-MM-DD')
                            param.push([body.tenantId, i.ID, body.ruleObj.ID, nextOccuranceDate, body.estimatedStartDate,
                            body.recurringEndDate, body.loggedUserId, body.loggedUserId,1])
                        }
                        let queries = [
                            {
                                id: 'updateNewRecTasksDate',
                                query: updateNewRecTasksDate,
                                parameters: [body.estimatedStartDate, body.estimatedStartDate, body.estimatedStartDate, body.estimatedStartDate]
                            },
                            {
                                id: 'addRecurringData',
                                query: mysqlQueries.addRecurringData,
                                parameters: [param]
                            }
                        ];
                        result = await dbOperations.executeTransactions(queries, loggedUser, "addRecurringData", tenant, appLogger, meteringLogger, moduleName)
                        if (result != undefined && result != null && result.addRecurringData.result.affectedRows > 0) {
                            appLogger.logMessage("info", "Successfully added Recurring task.", "PMService", "addMultiReccTask", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Success", "Successfully added Recurring task.", 200, null, false, "addMultiReccTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("info", "Failed to add Recurring task.", "PMService", "addMultiReccTask", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "Failed to add Recurring task.", 400, null, false, "addMultiReccTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    } else {
                        appLogger.logMessage("info", "No task available.", "PMService", "addMultiReccTask", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No recurring task available.", 400, null, false, "addMultiReccTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to stop Recurring task.", "PMService", "addMultiReccTask", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to add Recurring task.", 400, null, false, "addMultiReccTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "addMultiReccTask", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "addMultiReccTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addMultiReccTask", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "addMultiReccTask Service completed.", "PMService", "addMultiReccTask", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addMultiReccTask", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addMultiReccTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // Cancel the occurence of recurring task.
    cancelRecurringTask: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "cancelRecurringTask service initiated", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
        let result, param, query;
        try {
            if (body.taskId != undefined && body.taskId != null && body.cancelDates != null && body.cancelDates != undefined && body.cancelDates.length > 0) {
                let dates = [];
                let date = body.cancelDates
                for (let day of date) {
                    let nextOccuranceDate = moment(day, 'DD-MM-YYYY').format('YYYY-MM-DD');
                    dates.push(nextOccuranceDate)
                }
                param = String(body.taskId).split(",");
                query = mysqlQueries.getTaskNSubTaskIds;
                query = query.split("@StrParam1").join("'" + param.join("','") + "'")
                result = await dbOperations.executeQuery(query, [], loggedUser, "getTaskNSubTaskIds", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("debug", "Recurring task ids : " + JSON.stringify(result), "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                        query = mysqlQueries.cancelRecurringTask
                        query = query.replace("@StrParam1", "'" + result.map(x => x.ID).join("','") + "'")
                        let strValue = String(dates);
                        result = await dbOperations.executeQuery(query, strValue, loggedUser, "cancelRecurringTask", false, null, tenant, appLogger, meteringLogger, moduleName)
                        if (result != undefined && result != null && result.affectedRows > 0) {
                            appLogger.logMessage("info", "Successfully cancelled Recurring task.", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Success", "Successfully cancelled Recurring task.", 200, null, false, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("info", "Failed to cancelled Recurring task.", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "Failed to cancelled Recurring task.", 400, null, false, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                    } else {
                        appLogger.logMessage("info", "No recurring task available.", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No recurring task available.", 400, null, false, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to cancelled Recurring task.", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to cancelled Recurring task.", 400, null, false, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }

            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "cancelRecurringTask", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "cancelRecurringTask Service completed.", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // Populates recurring dates
    populateRecurringDates: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "cancelRecurringTask service initiated", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
        let result, param, query;
        try {
            if (body.taskId != undefined && body.taskId != null) {
                param = body.taskId;
                query = mysqlQueries.getRecuringTaskDetails;
                result = await dbOperations.executeQuery(query, param, loggedUser, "getRecuringTaskDetails", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        let start_date = moment(result[0].NEXT_OCCURANCE_DATE, "YYYY-MM-DD");
                        let end_date = moment(result[0].END_DATE, "YYYY-MM-DD")
                        let dates = []
                        let currentDate = start_date;
                        do {
                            if (result[0].RULE_NAME.toUpperCase() == 'DAILY') {
                                if (dates.length == 0) {
                                    dates.push(currentDate.format('YYYY-MM-DD'))
                                } else {
                                    currentDate.add(result[0].RULE_VALUE, 'day');
                                    if (currentDate.isSameOrBefore(end_date, 'day')) {
                                        dates.push(currentDate.format('YYYY-MM-DD'))
                                    }
                                }
                            } else if (result[0].RULE_NAME.toUpperCase() == 'WEEKLY') {
                                if (currentDate.day() === 0) {
                                    currentDate.add(1, 'day');
                                    continue;
                                } else {
                                    if (dates.length == 0) {
                                        dates.push(currentDate.format('YYYY-MM-DD'))
                                    } else {
                                        currentDate.add(result[0].RULE_VALUE, 'day');
                                        if (currentDate.isSameOrBefore(end_date, 'day')) {
                                            dates.push(currentDate.format('YYYY-MM-DD'))
                                        }
                                    }
                                }
                            } else if (result[0].RULE_NAME.toUpperCase() == 'WEEKDAY') {
                                if (currentDate.day() === 5) {
                                    if (dates.length == 0) {
                                        dates.push(currentDate.format('YYYY-MM-DD'))
                                    } else {
                                        currentDate.add(3, 'days');
                                        dates.push(currentDate.format('YYYY-MM-DD'))
                                    }
                                } else {
                                    if (dates.length == 0) {
                                        dates.push(currentDate.format('YYYY-MM-DD'))
                                    } else {
                                        currentDate.add(result[0].RULE_VALUE, 'day');
                                        if (currentDate.isSameOrBefore(end_date, 'day')) {
                                            dates.push(currentDate.format('YYYY-MM-DD'))
                                        }
                                    }
                                }
                            } else if (result[0].RULE_NAME.toUpperCase() == 'YEARLY') {
                                if (currentDate.day() === 0) {
                                    currentDate.add(1, 'day');
                                    continue;
                                } else {
                                    if (dates.length == 0) {
                                        dates.push(currentDate.format('YYYY-MM-DD'))
                                    } else {
                                        currentDate.add(result[0].RULE_VALUE, 'day');
                                        if (currentDate.isSameOrBefore(end_date, 'day')) {
                                            dates.push(currentDate.format('YYYY-MM-DD'))
                                        }
                                    }
                                }
                            } else if (result[0].RULE_NAME.toUpperCase() == 'MONTHLY') {
                                if (currentDate.day() === 0) {
                                    currentDate.add(1, 'day');
                                    continue;
                                } else {
                                    if (dates.length == 0) {
                                        dates.push(currentDate.format('YYYY-MM-DD'))
                                    } else {
                                        currentDate.add(result[0].RULE_VALUE, 'day');
                                        if (currentDate.isSameOrBefore(end_date, 'day')) {
                                            dates.push(currentDate.format('YYYY-MM-DD'))
                                        }
                                    }
                                }
                            } else {
                                dates.push = []
                                appLogger.logMessage("info", "No Matching recurrence rule found.", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                            }
                        } while (currentDate.isSameOrBefore(end_date, 'day'));
                        if (dates.length > 0) {
                            appLogger.logMessage("info", "Successfully fetched the data", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Success", "Successfully fetched the data.", 200, dates, true, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        } else {
                            appLogger.logMessage("info", "Successfully fetched the data", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "Failed to fetch the data.", 200, null, false, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }

                    } else {
                        appLogger.logMessage("info", "No recurring task details found.", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No recurring task details found.", 400, null, false, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch recurring task details .", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch recurring task details.", 400, null, false, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }

            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "cancelRecurringTask", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "cancelRecurringTask Service completed.", "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "cancelRecurringTask", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "cancelRecurringTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // add issue to milestone
    addIssueToMilestone: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "addIssueToMilestone service initiated", "PMService", "addIssueToMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.issueId != undefined && body.issueId != null && body.milestoneId != null && body.milestoneId != undefined) {
                let ids = JSON.parse(body.issueId);
                let params = [];
                for (let id of ids) {
                    params.push([body.tenantId, body.milestoneId, id, moment().format("YYYY-MM-DD"), body.loggedUserId, body.loggedUserId])
                }
                result = await dbOperations.executeQuery(mysqlQueries.addIssueToMilestone, [params], loggedUser, "addIssueToMilestone", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.affectedRows > 0) {
                    appLogger.logMessage("info", "Successfully mapped Issue to milestone.", "PMService", "addIssueToMilestone", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Success", "Successfully mapped Issue to milestone.", 200, null, false, "addIssueToMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    appLogger.logMessage("info", "Failed to mapped Issue to milestone.", "PMService", "addIssueToMilestone", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to mapped Issue to milestone.", 400, null, false, "addIssueToMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "addIssueToMilestone", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "addIssueToMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addIssueToMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "addIssueToMilestone Service completed.", "PMService", "addIssueToMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addIssueToMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addIssueToMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // change issue milestone to another
    changeIssueMilestone: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "changeIssueMilestone service initiated", "PMService", "changeIssueMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.issueId != undefined && body.issueId != null && body.milestoneId != null && body.milestoneId != undefined) {
                let param = JSON.parse(body.issueId);
                result = await dbOperations.executeQuery(mysqlQueries.changeIssueMilestone, [body.milestoneId, body.loggedUserId, param], loggedUser, "changeIssueMilestone", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.affectedRows > 0) {
                    appLogger.logMessage("info", "Successfully mapped Issue to milestone..", "PMService", "changeIssueMilestone", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Success", "Successfully mapped Issue to milestone.", 200, null, false, "changeIssueMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    appLogger.logMessage("info", "Failed to mapped Issue to milestone.", "PMService", "changeIssueMilestone", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to mapped Issue to milestone.", 400, null, false, "changeIssueMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "changeIssueMilestone", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "changeIssueMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "changeIssueMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "changeIssueMilestone Service completed.", "PMService", "changeIssueMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "changeIssueMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "changeIssueMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // remove issue from milestone
    removeIssueFromMilestone: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "removeIssueFromMilestone service initiated", "PMService", "removeIssueFromMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.issueId != undefined && body.issueId != null && body.milestoneId != null && body.milestoneId != undefined) {
                let param = JSON.parse(body.issueId);
                result = await dbOperations.executeQuery(mysqlQueries.removeIssueFromMilestone, [body.loggedUserId, param, body.milestoneId], loggedUser, "getTaskNSubTaskIds", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.affectedRows > 0) {
                    appLogger.logMessage("info", "Successfully added Recurring task.", "PMService", "removeIssueFromMilestone", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Success", "Successfully removed issue from milestone.", 200, null, false, "removeIssueFromMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    appLogger.logMessage("info", "Failed to stop Recurring task.", "PMService", "removeIssueFromMilestone", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to remove issue from milestone.", 400, null, false, "removeIssueFromMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "removeIssueFromMilestone", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "removeIssueFromMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "removeIssueFromMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "removeIssueFromMilestone Service completed.", "PMService", "removeIssueFromMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "removeIssueFromMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "removeIssueFromMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // get issue under milestone
    getIssuesUnderMilestone: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getIssuesUnderMilestone service initiated", "PMService", "getIssuesUnderMilestone", loggedUser, tenant, moduleName);
        let result;
        try {
            if (body.milestoneId != null && body.milestoneId != undefined) {
                result = await dbOperations.executeQuery(mysqlQueries.getIssuesUnderMilestone, [body.milestoneId, body.tenantId], loggedUser, "getIssuesUnderMilestone", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        for(let data of result) {
                            let assignee=[]
                            assignee.push({ 'ID': data.ASSIGNED_TO, 'FULL_NAME': data.ASSIGNED_TO_NAME })
                            data['ASSIGNEE'] = assignee
                        }
                        appLogger.logMessage("info", "Successfully fetched issues under milestone.", "PMService", "getIssuesUnderMilestone", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Successfully fetched issues under milestone.", 200, result, true, "getIssuesUnderMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "No issues found under milestone.", "PMService", "getIssuesUnderMilestone", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No issues found under milestone.", 400, null, false, "getIssuesUnderMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch issues under milestone.", "PMService", "getIssuesUnderMilestone", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch issues under milestone.", 400, null, false, "getIssuesUnderMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "getIssuesUnderMilestone", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getIssuesUnderMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getIssuesUnderMilestone", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getIssuesUnderMilestone Service completed.", "PMService", "getIssuesUnderMilestone", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getIssuesUnderMilestone", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getIssuesUnderMilestone", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },


    // Convert a task to issue
    convertTaskToIssue: async function (req, data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "convertTaskToIssue", loggedUser, tenant, moduleName);
        let result;
        let param, query;
        try {
            if (data.taskName != undefined && data.taskName != null && data.projectId != undefined && data.projectId != null && data.taskId != undefined && data.taskId != null && data.priority != undefined && data.priority != null && data.severity != undefined && data.severity != null) {
                Object.keys(data).forEach(k => data[k] = (data[k] === '' || data[k] === 'null' || data[k] === undefined) ? null : data[k])
                result = await dbOperations.executeQuery(mysqlQueries.updateStatusOfTask, data.taskId, loggedUser, "convertTaskToIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null) {
                    if (result.affectedRows > 0) {
                        // update group status
                        let gropuStatusChange = await supportHandler.groupStatusChange(data.projectId, data.groupId, data.tenantId, data.loggedUserId, data.loggedUser, data.tenant)
                        if (gropuStatusChange.affectedRows > 0) {
                            let moduleId, assignedTo
                            if (data.moduleId != null && data.moduleId != undefined && data.moduleId != '') {
                                moduleId = data.moduleId
                            } else {
                                moduleId = null
                            }
                            if (data.assignedTo != null && data.assignedTo != undefined && data.assignedTo != '') {
                                assignedTo = data.assignedTo
                            } else {
                                assignedTo = null
                            }
                            // add task to issue
                            param = { tenantId: data.tenantId, projectId: data.projectId, issueName: data.taskName, issueDescription: data.taskDescription, priority: data.priority, severity: data.severity, assignedTo: assignedTo, status: data.status, assigneeComment: null, moduleId: moduleId }
                            result = await this.addIssue(req, param, loggedUser, tenant)
                            if (result != undefined && result != null && result.data.affectedRows > 0) {
                                let issueId = [result.data.insertId]
                                // fetch and remove milestone data if exists.
                                result = await dbOperations.executeQuery(mysqlQueries.getMilestoneIfExists, data.taskId, loggedUser, "convertTaskToIssue", true, null, tenant, appLogger, meteringLogger, moduleName)
                                if (result != undefined && result != null) {
                                    if (result.length > 0) {
                                        // remove milestone data from task milestone mapping.
                                        let query = mysqlQueries.removeTaskFromMilestoneMapping;
                                        param = data.taskId;
                                        result = await dbOperations.executeQuery(query, param, loggedUser, "convertTaskToIssue", true, null, tenant, appLogger, meteringLogger, moduleName)
                                        if (result != undefined && result != null) {
                                            if (result.affectedRows > 0) {
                                                

                                                appLogger.logMessage("info", "Successfully  remove task from milestone mapping.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                            } else {
                                                appLogger.logMessage("info", "Failed to remove task from milestone mapping.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                            }
                                        } else {
                                            appLogger.logMessage("info", "Failed to remove task from milestone mapping.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                        }
                                    } else {
                                        appLogger.logMessage("info", "No milestone exists.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                    }
                                } else {
                                    appLogger.logMessage("info", "No milestone exists.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                }
                                // if task added to watch list , notify watch list users on assigning 
                                                //body['addedToWatchList']=true
                                    if(data.addedToWatchList=='true'){
                                        let notifyResult=await supportHandler.watchListNotification(data,'convert_to_issue',data.loggedUser,data.tenant)
                                        appLogger.logMessage("debug", " Result after notify watchers"+JSON.stringify(notifyResult) , className, "assignUserToTask", loggedUser, tenant, moduleName);

                                        query=mysqlQueries.updateWatchList
                                        param=['INACTIVE',data.loggedUserId,[data.taskId],'TASK',data.tenantId]
                                        result = await dbOperations.executeQuery(query, param, loggedUser, "convertTaskToIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                                        if(result!=undefined && result!=null && result!='Error'){
                                            if(result.affectedRows>0){
                                                appLogger.logMessage("info", "Watch list updated successfully " , className, "assignUserToTask", loggedUser, tenant, moduleName);
 
                                            }else{
                                                appLogger.logMessage("info", " Failed to update watch list" , className, "assignUserToTask", loggedUser, tenant, moduleName);

                                            }
                                    }

                                    }
                                // add issue to milestone 
                                if (data.milestoneId != null && data.milestoneId != undefined) {
                                    let body = { tenantId: data.tenantId, issueId: JSON.stringify([issueId]), milestoneId: data.milestoneId, loggedUserId: data.loggedUserId }
                                    let addDatatoMilestone = await this.addIssueToMilestone(body, loggedUser, tenant)
                                    if (addDatatoMilestone.type == "Success") {
                                        result = await responseHandler.sendResponse("Success", "Task is converted to Issue and added to milestone successfully.", 200, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                        appLogger.logMessage("info", "Task is converted to Issue successfully.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                    } else {
                                        result = await responseHandler.sendResponse("Warning", "Task is converted to Issue but failed to add milestone.", 200, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                        appLogger.logMessage("info", "Task is converted to Issue successfully.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);

                                    }
                                } else {
                                    result = await responseHandler.sendResponse("Success", "Task is converted to Issue successfully.", 200, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                    appLogger.logMessage("info", "Task is converted to Issue successfully.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                }
                                // update attachment if exists
                                let updateResult = await supportHandler.updateAttachment(issueId[0], data.loggedUserId, data.tenantId, loggedUser, tenant, 'ISSUE')
                                if (updateResult.type != 'Success') {
                                    appLogger.logMessage("info", "Failed to update attachment of task.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                    result = await responseHandler.sendResponse("Warning", "Failed to update attachment of task", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                }
                                // update comment if exists
                                let updateComment = await supportHandler.updateComment(issueId[0], data.loggedUserId, data.tenantId, loggedUser, tenant, 'ISSUE')
                                if (updateComment.type != 'Success') {
                                    result = await responseHandler.sendResponse("Warning", "Failed to update attachment of task", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                }
                                // update details of task created via template
                                let updateTemplate = await supportHandler.updateTemplateTasks(req, data, loggedUser, tenant)
                                if (updateTemplate.type != 'Success') {
                                    result = await responseHandler.sendResponse("Warning", "Failed to update details of task created via template", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                }

                                let updateBudget = await BudgetSupport.editClassBudget(data.taskId, 'TASK', data.tenantId, null, null, 0, 0, data.loggedUserId, loggedUser, tenant, null, data.groupId, data.projectId)
                                if (updateBudget.statusCode != 200) {
                                    result = await responseHandler.sendResponse("Warning", "Failed to update the budget of task.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                }
                                // update dates of group.
                                let updateTaskObj = {
                                    "loggedUserId": data.loggedUserId,
                                    "groupId": data.groupId,
                                    "projectId": data.projectId,
                                    "tenantId": data.tenantId
                                }
                                let res = await supportHandler.setStartDateEndDateOfGroup(updateTaskObj, data.loggedUser, data.tenant)
                                if (!res) {
                                    result = await responseHandler.sendResponse("Warning", "Failed to update the dates of group.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                }
                            } else {
                                result = await responseHandler.sendResponse("Warning", "Failed to convert task to issue.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Failed to convert task to issue.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                            }

                        } else {
                            result = await responseHandler.sendResponse("Warning", "Failed to update group status.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            appLogger.logMessage("info", "Failed to update group status.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                        }

                    } else {
                        result = await responseHandler.sendResponse("Warning", "Failed to update task status.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        appLogger.logMessage("info", "Failed to update task status.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);

                    }

                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to update task status.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    appLogger.logMessage("info", "Failed to update task status.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                }

            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                appLogger.logMessage("info", "Invalid Parameters.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "convertTaskToIssue", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "convertTaskToIssue", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    // CONVERT ISSUES TO TASK
    issueToTask: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "issueToTask service initiated", "PMService", "issueToTask", loggedUser, tenant, moduleName);
        let result;
        try {

            if (body.issueId != null && body.issueId != undefined && body.projectId != null && body.projectId != undefined  &&
                body.isRecurring != null && body.isRecurring != undefined) {
                let query;
                let param;
                let formatedTaskName = await validationHandler.validateString(body.taskName, loggedUser, tenant, appLogger, meteringLogger, moduleName);
                body.taskName = formatedTaskName;
                let isExists = await supportHandler.isTaskNameExists(body.taskName, body.tenantId, body.projectId, loggedUser, tenant);
                if (isExists != null) {
                    if (isExists == 0) {
                        // create new group if groupId is nt given from UI
                        if(body.groupId==null || body.groupId==undefined){
                            let groupResult = await this.createGroup(body, body.loggedUser, body.tenant)
                            if (groupResult.type == 'Success') {
                                body['groupId'] = groupResult.data[0].ID
                            } else {
                                result = await responseHandler.sendResponse("Warning", "Failed to create new group.", 200, result, true, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Failed to create new group.", "PMService", "issueToTask", loggedUser, tenant, moduleName);
                                return result
                            }
                        }                        
                        
                        // create task 
                        body['actualStartDate'] = moment().format('YYYY-MM-DD')
                        body['estimatedStartDate'] = moment().format('YYYY-MM-DD')
                        // let estimatedCompletionDate = moment(moment().format('YYYY-MM-DD')).add(2, 'd').format('YYYY-MM-DD')
                        // body['estimatedCompletionDate'] = body.estimatedCompletionDate
                        // body['actualCompletionDate'] = estimatedCompletionDate
                        body['type'] = "MAIN"
                        // body['actualEffort'] = body.estimatedEffort
                        // body['estimatedEffort'] = body.estimatedEffort

                        query = mysqlQueries.createTaskByEmp;
                        param = [
                            body.projectId,
                            body.tenantId,
                            body.taskName,// task name
                            body.taskDescription,// task  description  
                            body.taskTypeCode || null,
                            body.assignedTo || null,
                            body.loggedUserId || null, // assigned by
                            body.taskStatusTypeCode,
                            body.priorityTypeCode,
                            body.estimatedStartDate,
                            body.estimatedCompletionDate,
                            body.estimatedEffort,
                            body.actualStartDate,
                            body.actualCompletionDate,
                            body.actualEffort,
                            body.type,
                            null, // main task id  is null 
                            body.groupId,
                            body.tag || null
                        ];
                        result = await dbOperations.executeQuery(query, param, loggedUser, "issueToTask", true, [16, 17], tenant, appLogger, meteringLogger, moduleName);
                        if (result != undefined && result != null && result != 'Error') {
                            if (result.affectedRows > 0) {
                                let newTaskId = result.insertId
                                result = await responseHandler.sendResponse("Success", "Task created successfully", 200, result, true, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Task created successfully.", "PMService", "issueToTask", loggedUser, tenant, moduleName);
                                
                                let updateTaskObj = {
                                    'actualCompletionDate': body.actualCompletionDate,
                                    'estimatedStartDate': body.estimatedStartDate,
                                    'estimatedCompletionDate': body.estimatedCompletionDate,
                                    'taskStatusTypeCode': "NS", 'mainTaskStatus': null,
                                    'groupId': body.groupId, 'mainTaskId': null, 'projectId': body.projectId,
                                    'type': body.type, 'loggedUserId': body.loggedUserId, 'tenantId': body.tenantId
                                }

                                // update start date and end date of task and group
                                let res = await supportHandler.taskDateChange(updateTaskObj, body.loggedUser, body.tenant)
                                appLogger.logMessage("debug", "Result after updating start date and end date of task and group." + JSON.stringify(res), "PMService", "issueToTask", loggedUser, tenant, moduleName);

                                // update the status of the group
                                await supportHandler.taskStatusChange(updateTaskObj, body.loggedUser, body.tenant)
                                // set as recurring task 
                                if (body.isRecurring == 'true') {
                                    body.ruleObj=JSON.stringify(body.ruleObj)
                                    let recurringResult = await this.isRecurringTask(newTaskId, body, loggedUser, tenant)
                                    appLogger.logMessage("debug", "Result after  setting task as recurring." + JSON.stringify(recurringResult), "PMService", "issueToTask", loggedUser, tenant, moduleName);
                                    if (recurringResult.type != 'Success') {
                                        result = await responseHandler.sendResponse("Warning", "Failed to set task as recurring", 400, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                                    }
                                }
                                //update budget
                                let updateBudget = await BudgetSupport.editClassBudget(newTaskId, 'TASK', body.tenantId, null, null, 0, 0, body.loggedUserId, loggedUser, tenant, null, body.groupId, body.projectId)
                                if (updateBudget.statusCode != 200) {
                                    result = await responseHandler.sendResponse("Warning", "Failed to update the budget of task.", 400, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                }
                                //update milestone
                                if ((body.oldMilestoneId!=null && body.oldMilestoneId!=undefined && body.oldMilestoneId!='' && body.oldMilestoneId!='null' && body.oldMilestoneId!='undefined') ) {
                                    // remove issue from old miletsone
                                    query = mysqlQueries.deleteFromMilestone
                                    param = [body.issueId, body.oldMilestoneId, body.tenantId]
                                    result = await dbOperations.executeQuery(query, param, loggedUser, "issueToTask", false, null, tenant, appLogger, meteringLogger, moduleName)
                                    if (result != undefined && result != null && result != 'Error') {
                                        if (result.affectedRows > 0) {
                                            appLogger.logMessage("info", "Successfully deleted issue from milestone.", "PMService", "issueToTask", loggedUser, tenant, moduleName);
                                            //result = await responseHandler.sendResponse("Success", "Successfully deleted issue from issue tracker.", 200, null, true, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                        } else {
                                            appLogger.logMessage("info", "Failed to delete issue from milestone.", "PMService", "issueToTask", loggedUser, tenant, moduleName);
        
                                        }
                                    } else {
                                        appLogger.logMessage("info", "Failed to delete issue from milestone.", "PMService", "issueToTask", loggedUser, tenant, moduleName);
        
                                    }
                                }
                                // update attachment
                                let updateResult = await supportHandler.updateAttachment(newTaskId, body.loggedUserId, body.tenantId, body.loggedUser, body.tenant, 'TASK')
                                if (updateResult.type != 'Success') {
                                    result = await responseHandler.sendResponse("Warning", "Failed to update attachment of issue", 400, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                }
                                let updateComment = await supportHandler.updateComment(newTaskId, body.loggedUserId, body.tenantId, body.loggedUser, body.tenant, 'TASK')
                                if (updateComment.type != 'Success') {
                                    result = await responseHandler.sendResponse("Warning", "Failed to update comments of issue", 400, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                }
                                if (body.milestoneId!=undefined && body.milestoneId!=null && body.milestoneId!='' && body.milestoneId!='null' && body.milestoneId!='undefined'){
                                    // map to milestone
                                    let taskIdArry = []
                                    taskIdArry.push(newTaskId)
                                    body['tasks'] = JSON.stringify(taskIdArry)
                                    let miletstoneResult = await this.addTaskToMilestone(body, body.loggedUser, body.tenant)
                                    if (miletstoneResult.type == "Success") {
                                        appLogger.logMessage("debug", "Result after  maping  task  to milestone." + JSON.stringify(miletstoneResult), "PMService", "issueToTask", loggedUser, tenant, moduleName);
                                    } else {
                                        appLogger.logMessage("debug", "Failed to map task to milestone." + JSON.stringify(miletstoneResult), "PMService", "issueToTask", loggedUser, tenant, moduleName);
                                        result = await responseHandler.sendResponse("Warning", "Failed to add task to milestone.", 200, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                    }
                                }
                                
                                // remove issue from issue tracker
                                query = mysqlQueries.updateIssue
                                param = [body.loggedUserId, body.issueId]
                                result = await dbOperations.executeQuery(query, param, loggedUser, "issueToTask", false, null, tenant, appLogger, meteringLogger, moduleName)
                                if (result != undefined && result != null && result != 'Error') {
                                    if (result.affectedRows > 0) {
                                        appLogger.logMessage("info", "Successfully deleted issue from issue tracker and converted to task.", "PMService", "issueToTask", loggedUser, tenant, moduleName);
                                        result = await responseHandler.sendResponse("Success", "Successfully converted issue to task.", 200, null, true, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                        
                                    } else {
                                        result = await responseHandler.sendResponse("Warning", "Failed to  delete issue from issue tracker.", 400, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                        appLogger.logMessage("info", "Failed to  delete issue from issue tracker.", "PMService", "issueToTask", loggedUser, tenant, moduleName);
                                    }
                                } else {
                                    appLogger.logMessage("info", "Failed to  delete issue from issue tracker.", "PMService", "issueToTask", loggedUser, tenant, moduleName);
                                    result = await responseHandler.sendResponse("Warning", "Failed to  delete issue from issue tracker.", 400, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                }
                                // send mail
                                let userData = await supportHandler.getTeamMailData(body.projectId, body.tenantId, body.loggedUser, body.tenant)
                                if (userData.length > 0) {
                                    if( body.projectName != null && body.projectName != undefined
                                        && body.createdByName != null && body.createdByName != undefined 
                                        && body.groupName != null && body.groupName != undefined 
                                        && body.taskName != null && body.taskName != undefined
                                        && body.taskDescription != null && body.taskDescription != undefined){
                    
                                    let sub = mailConfig.task.create.sub
                                    sub = sub.replace('{projectName}', body.projectName)
                                    sub = sub.replace('{createdByName}', body.createdByName)
                                    sub = sub.replace('{taskId}', newTaskId)
                  
                                    if(body.assignedTo != null && body.assignedTo != ''){
                                        mes = mailConfig.task.create.message1
                                    }
                                    else{
                                        mes = mailConfig.task.create.message
                                    }
                                    let groupName1;

                                    if (body.groupName == null) {
                                        groupName1='General'
                                    } else {
                                        groupName1= body.groupName
                                    }
                                    const payLoad = {
                                        taskId: newTaskId,
                                        projectName:body.projectName,
                                        taskName:body.taskName,
                                        taskDescription:body.taskDescription,
                                        groupName:groupName1,
                                        createdByName:body.createdByName,
                                        assignTo:body.assignedToName
                                         
                                      };
                                      // Create an array of attachments
                                    const imageFilePath = path.join(__dirname,'..', '..', 'utils', 'pictures', '1.png');
                                    const imageData = fs.readFileSync(imageFilePath);
                                    // Encode the binary data to base64
                                    const base64Image = imageData.toString('base64');
                                    const attachments = [
                                        {
                                            "@odata.type": "#microsoft.graph.fileAttachment",
                                            "name": "1.png",
                                            "contentBytes": base64Image,
                                            "isInline": true,
                                            "contentId": "attached-image"
                                        }
                                       
                                    ];
                                    
                                     ejs.renderFile(mes,payLoad,(err, message) => {
                                        if (err) {
                                          console.error('Error rendering email template:', err);
                                          res.status(500).json({ error: 'Internal server error' });
                                          return;
                                        }
                                    sendMails(userData, null, null, sub, message, body.loggedUser, body.tenant, attachments, true, body.tenantId, appLogger, meteringLogger, moduleName)
                                });
                                   }else{
                                    appLogger.logMessage("info", "Invalid parameters for email.", "PMService", "issueToTask", loggedUser, tenant, moduleName, moduleName);
                                   }

                                } else {
                                    appLogger.logMessage("info", "Failed to get  team  members email", "PMService", "issueToTask", loggedUser, tenant, moduleName, moduleName);

                                }

                                let notify = await supportHandler.notifyProjectManagerforCreation(newTaskId, body.loggedUserId, loggedUser, tenant, body.tenantId, 'TASK', null, null, null, null)

                                appLogger.logMessage("debug", "Task created successfully and Result received after executing the query: " + JSON.stringify(result), className, "issueToTask", loggedUser, tenant, moduleName);

                            } else {
                                appLogger.logMessage("info", " Failed to create task.", "PMService", "issueToTask", loggedUser, tenant, moduleName);
                                result = await responseHandler.sendResponse("Warning", "Failed to create task.", 400, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                            }
                        } else {
                            appLogger.logMessage("info", " Failed to create task.", "PMService", "issueToTask", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "Failed to create task.", 400, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }
                        
                    } else {
                        appLogger.logMessage("info", "Task with the same name exists", className, "issueToTask", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Task with the same name exists", 404, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                }

            } else {
                appLogger.logMessage("info", "Invalid Parameters.", "PMService", "issueToTask", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "issueToTask", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getIssuesUnderMilestone Service completed.", "PMService", "issueToTask", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "issueToTask", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "issueToTask", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    addfunctionalroles: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initited", "PMService", "addfunctionalroles", loggedUser, tenant, moduleName);
        let result;
        let roleDescription = data.role;
        try {
            if (data.role != undefined && data.role != null && data.tenantId != undefined && data.tenantId != null && roleDescription != undefined && roleDescription != null) {
                role = data.role.toUpperCase().trim()
                let isEmpRole = (role == "EMPLOYEE") ? true : false;
                result = await dbOperations.executeQuery(mysqlQueries.checkRoleExists, [role, data.tenantId], loggedUser, "checkRoleExists", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (result != undefined && result != null) {
                    if (result.length == 0 && isEmpRole == false) {
                        param = [data.tenantId, data.role, roleDescription, data.loggedUserId, data.loggedUserId]
                        result = await dbOperations.executeQuery(mysqlQueries.addFunctionalRoles, param, loggedUser, "addfunctionalroles", true, [4, 6], tenant, appLogger, meteringLogger, moduleName);
                        if (result != undefined && result != null) {
                            if (result.affectedRows > 0) {
                                let roleId = result.insertId
                                result = await responseHandler.sendResponse("Success", "Successfully  added functional role.", 200, roleId, true, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Successfully  added functional role.", "addfunctionalroles", "addIssue", loggedUser, tenant, moduleName, moduleName);
                            } else {
                                result = await responseHandler.sendResponse("Warning", "Failed to add functional roles.", 400, null, false, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Failed to add functional role.", "addfunctionalroles", "addIssue", loggedUser, tenant, moduleName, moduleName);
                            }
                        } else {
                            result = await responseHandler.sendResponse("Warning", "Failed to add functional roles.", 400, null, false, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            appLogger.logMessage("info", "Failed to add functional role.", "addfunctionalroles", "addIssue", loggedUser, tenant, moduleName, moduleName);
                        }
                    } else {
                        appLogger.logMessage("info", "Functional role already exists.", "addfunctionalroles", "addIssue", loggedUser, tenant, moduleName, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Functional role already exists.", 400, result, true, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to check role exists.", "addfunctionalroles", "addIssue", loggedUser, tenant, moduleName, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Functional role already exists.", 400, result, true, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid parameters.", "addfunctionalroles", "addIssue", loggedUser, tenant, moduleName, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid Parameter.", 404, null, false, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addfunctionalroles", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed", "PMService", "addfunctionalroles", loggedUser, tenant, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addfunctionalroles", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    editfunctionalrole: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initited", "PMService", "editFunctionalRoles", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.roleId != undefined && data.roleId != null && data.roleName != undefined && data.roleName != null && data.tenantId != undefined && data.tenantId != null && data.roleDescription != undefined && data.roleDescription != null) {
                role = data.roleName.toUpperCase().trim()
                result = await dbOperations.executeQuery(mysqlQueries.checkRoleExistsForEdit, [data.roleId, data.tenantId], loggedUser, "checkRoleExists", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (result != undefined && result != null) {
                    if (result.length > 0) {
                        param = [data.roleName, data.roleDescription, data.loggedUserId, data.loggedUserId, data.roleId, data.tenantId]
                        result = await dbOperations.executeQuery(mysqlQueries.editFunctionalRoles, param, loggedUser, "editFunctionalRoles", false, null, tenant, appLogger, meteringLogger, moduleName);
                        if (result != undefined && result != null) {
                            if (result.affectedRows > 0) {
                                result = await responseHandler.sendResponse("Success", "Successfully  edited functional role.", 200, result, true, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Successfully  edited functional role.", "convertTaskToIssue", "addIssue", loggedUser, tenant, moduleName, moduleName);
                            } else {
                                result = await responseHandler.sendResponse("Warning", "Failed to edit functional roles.", 400, null, false, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Failed to edit functional role.", "convertTaskToIssue", "addIssue", loggedUser, tenant, moduleName, moduleName);
                            }
                        } else {
                            result = await responseHandler.sendResponse("Warning", "Failed to edit functional roles.", 400, null, false, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            appLogger.logMessage("info", "Failed to edit functional role.", "convertTaskToIssue", "addIssue", loggedUser, tenant, moduleName, moduleName);
                        }
                    } else {
                        result = await responseHandler.sendResponse("Warning", "No such functional role found.", 400, null, false, "editFunctionalRoles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to check functional role exists.", 400, null, false, "editFunctionalRoles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameter.", 404, null, false, "editFunctionalRoles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "editFunctionalRoles", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed", "PMService", "editFunctionalRoles", loggedUser, tenant, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "editFunctionalRoles", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "editFunctionalRoles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    deleteFunctionalRole: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initited", "PMService", "deleteFunctionalRole: ", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.roleId != null && data.roleId != undefined && data.roleName != null && data.roleName != undefined) {
                role = data.roleName.toUpperCase().trim()
                result = await dbOperations.executeQuery(mysqlQueries.checkRoleExists, [role, data.tenantId], loggedUser, "checkRoleExists", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (result != undefined && result != null) {
                    if (result.length > 0) {
                        param = [data.roleId, data.tenantId]
                        result = await dbOperations.executeQuery(mysqlQueries.checkroleIsMpped, param, loggedUser, "deleteFunctionalRole: ", false, null, tenant, appLogger, meteringLogger, moduleName);
                        if (result != undefined && result != null) {
                            if (result.length == 0) {
                                param = [data.roleId, data.tenantId]
                                result = await dbOperations.executeQuery(mysqlQueries.deletFunctionalRole, param, loggedUser, "deleteFunctionalRole: ", false, null, tenant, appLogger, meteringLogger, moduleName);
                                if (result != undefined && result != null) {
                                    if (result.affectedRows > 0) {
                                        result = await responseHandler.sendResponse("Success", "Successfully  deleted functional role.", 200, null, false, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                        appLogger.logMessage("info", "Successfully  deleted functional role.", "convertTaskToIssue", "addIssue", loggedUser, tenant, moduleName, moduleName);
                                    } else {
                                        result = await responseHandler.sendResponse("Warning", "Failed to delete functional role.", 200, null, false, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                        appLogger.logMessage("info", "Failed to delete functional role.", "convertTaskToIssue", "addIssue", loggedUser, tenant, moduleName, moduleName);
                                    }
                                } else {
                                    result = await responseHandler.sendResponse("Warning", "Failed to delete functional role.", 200, null, false, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                    appLogger.logMessage("info", "Failed to deleted functional role.", "convertTaskToIssue", "addIssue", loggedUser, tenant, moduleName, moduleName);
                                }
                            } else {
                                result = await responseHandler.sendResponse("Warning", "Failed to deleted. Already mapped with users.", 200, null, false, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Failed to delete. Already mapped with users. ", "convertTaskToIssue", "addIssue", loggedUser, tenant, moduleName, moduleName);
                            }
                        } else {
                            result = await responseHandler.sendResponse("Warning", "Failed to deleted. Already mapped with users.", 200, null, false, "addfunctionalroles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            appLogger.logMessage("info", "Failed to deleted. Already mapped with users.", "convertTaskToIssue", "addIssue", loggedUser, tenant, moduleName, moduleName);
                        }
                    } else {
                        result = await responseHandler.sendResponse("Warning", "No functional role exists.", 400, null, false, "deleteFunctionalRole: ", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to check functional role exists.", 400, null, false, "editFunctionalRoles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameter.", 404, null, false, "deleteFunctionalRole: ", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "deleteFunctionalRole: ", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed", "PMService", "deleteFunctionalRole: ", loggedUser, tenant, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "deleteFunctionalRole: ", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "deleteFunctionalRole: ", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    fetchfunctionalroles: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initited", "PMService", "fetchFunctionalRoles", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.tenantId != undefined && data.tenantId != null) {
                param = [data.tenantId]
                result = await dbOperations.executeQuery(mysqlQueries.getFunctionalRoles, param, loggedUser, "fetchFunctionalRoles", true, [4, 6], tenant, appLogger, meteringLogger, moduleName);
                if (result != undefined && result != null) {
                    if (result.length > 0) {
                        result = await responseHandler.sendResponse("Success", "Successfully  fetched functional role.", 200, result, true, "fetchFunctionalRoles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        appLogger.logMessage("info", "Successfully  fetched functional role.", "convertTaskToIssue", "addIssue", loggedUser, tenant, moduleName, moduleName);
                    } else {
                        result = await responseHandler.sendResponse("Warning", "Failed to fetch functional role.", 200, null, false, "fetchFunctionalRoles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        appLogger.logMessage("info", "Failed to fetched functional role.", "convertTaskToIssue", "addIssue", loggedUser, tenant, moduleName, moduleName);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch functional role.", 200, null, false, "fetchFunctionalRoles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    appLogger.logMessage("info", "Failed to fetched functional role.", "convertTaskToIssue", "addIssue", loggedUser, tenant, moduleName, moduleName);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "fetchFunctionalRoles", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed", "PMService", "fetchFunctionalRoles", loggedUser, tenant, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "fetchFunctionalRoles", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "fetchFunctionalRoles", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },


    // COUNT ISSUE BY ITS STATUS
    issueCountByStatus: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "issueCountByStatus service initiated", "PMService", "issueCountByStatus", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.issueCountByStatus);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch issue count due to missing parameters: " + JSON.stringify(missingParams), className, "issueCountByStatus", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "issueCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let query
                let param = []
                let dataArray = [], seriesArray = [], labelArray = []
                // if (String(body.isAllProjects).toLowerCase() == "true") {
                 if (projectsLength==0){
                    query = mysqlQueries.allIssueCountByStatus
                    param = [body.loggedUserId, body.tenantId]
                } else {
                    query = mysqlQueries.issueCountByStatus
                    param = [body.loggedUserId, body.tenantId,Projects]
                }

                result = await dbOperations.executeQuery(query, param, loggedUser, "issueToTask", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", "Issue count  by status fetched successfully", "PMService", "issueCountByStatus", loggedUser, tenant, moduleName);
                        for (let x of result) {
                            let dispValue = String(x.DISPLAY_VALUE).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            labelArray.push(dispValue);
                            seriesArray.push(x.TOTAL);
                        }

                        let obj = { 'series': seriesArray, 'label': labelArray }
                        dataArray.push(obj)
                        result = await responseHandler.sendResponse("Success", "Count  of issue status by project fetched ", 200, dataArray, true, "issueCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("info", "No isues avaliable", "PMService", "issueCountByStatus", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No issues available ", 400, null, false, "issueCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch issue count by status", "PMService", "issueCountByStatus", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch issue count ", 400, null, false, "issueCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "issueCountByStatus", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "issueCountByStatus Service completed.", "PMService", "issueCountByStatus", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "issueCountByStatus", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "issueCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    // COUNT OF PROJECT BY ITS STATUS
    projectCountByStatus: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "projectCountByStatus service initiated", "PMService", "projectCountByStatus", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.projectCountByStatus);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch project count due to missing parameters: " + JSON.stringify(missingParams), className, "issueCountByStatus", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "issueCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let dataArray = [], seriesArray = [], labelArray = [];
                let param
                if (projectsLength==0){
                    query = mysqlQueries.projectCountByStatus
                    param = [body.tenantId, body.loggedUserId]
                } else {
                    query = mysqlQueries.specificProjectByStatus
                    param = [body.tenantId, body.loggedUserId,Projects]
                    
                }

                // let query = mysqlQueries.projectCountByStatus
                // let param = [body.tenantId, body.loggedUserId]
                result = await dbOperations.executeQuery(query, param, loggedUser, "projectCountByStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        for (let x of result) {
                            let dispValue = String(x.STATUS).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            labelArray.push(dispValue + " Projects")
                            seriesArray.push(x.TOTAL_COUNT)
                        }

                        let obj = { 'series': seriesArray, 'label': labelArray }
                        dataArray.push(obj)
                        appLogger.logMessage("info", "Project count fetched successfully", "PMService", "projectCountByStatus", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Count  of issue status by project fetched ", 200, dataArray, true, "projectCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        let outObj = {
                            series: [],
                            label: []
                        }
                        appLogger.logMessage("info", "No projects avaliable", "PMService", "projectCountByStatus", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No project found", 400, [outObj], false, "projectCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch project count by status", "PMService", "projectCountByStatus", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch project count ", 400, null, false, "projectCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "projectCountByStatus", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "projectCountByStatus Service completed.", "PMService", "projectCountByStatus", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "projectCountByStatus", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "projectCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // COUNT OF PROJECT BY ASSGINEE FOR PROJECT MANAGER
    issueCountByAssignee: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "issueCountByAssignee service initiated", "PMService", "issueCountByAssignee", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.issueCountByAssignee);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch issue count  due to missing parameters: " + JSON.stringify(missingParams), className, "issueCountByAssignee", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "issueCountByAssignee", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let dataArray = [], seriesArray = [], labelArray = []
                let query, param = []
                //if (String(body.isAllProjects).toLowerCase() == "true") {
             if (projectsLength==0){
                    query = mysqlQueries.allIssueCountByAssignee
                    param = [body.loggedUserId, body.tenantId]
                } else {
                    query = mysqlQueries.issueCountByAssignee
                    param = [body.loggedUserId, body.tenantId, Projects]
                }

                result = await dbOperations.executeQuery(query, param, loggedUser, "issueCountByAssignee", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        //let res = result.reduce((hash, obj) => ({ ...hash, [obj["ID"]]: (hash[obj["ID"]] || []).concat(obj) }), {})
                        for (let x of result) {
                            let dispValue = String(x.FULL_NAME).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            labelArray.push(dispValue)
                            seriesArray.push(x.ISSUE_COUNT)
                        }

                        let obj = { 'series': seriesArray, 'label': labelArray }
                        dataArray.push(obj)
                        appLogger.logMessage("info", "Issue count  by assignee fetched successfully", "PMService", "issueCountByAssignee", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Count  of issues fetched ", 200, dataArray, true, "issueCountByAssignee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "No projects avaliable", "PMService", "issueCountByAssignee", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No issues available ", 400, null, false, "issueCountByAssignee", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch issue count", "PMService", "issueCountByAssignee", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch issue count ", 400, null, false, "issueCountByAssignee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "issueCountByAssignee", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "issueCountByAssignee Service completed.", "PMService", "issueCountByAssignee", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "issueCountByAssignee", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "issueCountByAssignee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // COUNT OF TASK BY ASSGINEE FOR PROJECT MANAGER
    taskCountByAssignee: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "issueCountByAssignee service initiated", "PMService", "issueCountByAssignee", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.taskCountByAssignee);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to   fetch task count due to missing parameters: " + JSON.stringify(missingParams), className, "issueCountByAssignee", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "issueCountByAssignee", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let query, param = []
                let dataArray = [], seriesArray = [], labelArray = []
                // if (String(body.isAllProjects).toLowerCase() == "true") {
                if (projectsLength==0){
                    //fetch task count in all projects
                    query = mysqlQueries.allTaskCountByAssignee
                    param = [body.loggedUserId, body.tenantId]
                } else {
                    // fetch task count in a specfic project
                    query = mysqlQueries.taskCountByAssignee
                    param = [body.loggedUserId, body.tenantId, Projects]
                }
                result = await dbOperations.executeQuery(query, param, loggedUser, "taskCountByAssignee", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        for (let x of result) {
                            let dispValue = String(x.FULL_NAME).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            labelArray.push(dispValue)
                            seriesArray.push(x.TASK_COUNT)
                        }

                        let obj = { 'series': seriesArray, 'label': labelArray }
                        dataArray.push(obj)
                        appLogger.logMessage("info", "Task count  by assignee fetched successfully", "PMService", "taskCountByAssignee", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Count  of tasks fetched ", 200, dataArray, true, "taskCountByAssignee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "No projects avaliable", "PMService", "issueCountByAssignee", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No task available ", 400, null, false, "taskCountByAssignee", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch task count", "PMService", "taskCountByAssignee", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch task count ", 400, null, false, "taskCountByAssignee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "taskCountByAssignee", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "taskCountByAssignee Service completed.", "PMService", "taskCountByAssignee", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "taskCountByAssignee", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "taskCountByAssignee", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    // TASK COUNT BY STATUS  FOR ALL PROJECT AND  SPECEFIC PROJECT
    taskCountByStatus: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "taskCountByStatus service initiated", "PMService", "taskCountByStatus", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.taskCountByStatus);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch task count  due to missing parameters: " + JSON.stringify(missingParams), className, "taskCountByStatus", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "taskCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let query
                let param = []
                let dataArray = []
                if (String(body.role).toLowerCase() == "employee") {
                    if (projectsLength==0) {
                        // show  task count for all projects employee is onboarded
                        query = mysqlQueries.allTaskCountByStatusForEmp
                        param = [body.loggedUserId, body.tenantId]
                    } else {
                        //show  task count for a specefic project in which loggedUser is on boarded
                        query = mysqlQueries.taskCountByStatusForEmp
                        param = [body.loggedUserId, body.tenantId, Projects]
                    }

                } else if (String(body.role).toLowerCase() == "project_manager") {
                    if (projectsLength==0) {
                        //show  task count for all projects in which loggedUser is a part of it 
                        query = mysqlQueries.allTaskCountByStatusForPM
                        param = [body.loggedUserId, body.tenantId]
                    } else {
                        //show  task count for a specfic project in which loggedUser is a part of it 
                        query = mysqlQueries.taskCountByStatusForPM
                        param = [body.loggedUserId, body.tenantId, Projects]
                    }

                }

                result = await dbOperations.executeQuery(query, param, loggedUser, "taskCountByStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", "Task count  by status fetched successfully", "PMService", "taskCountByStatus", loggedUser, tenant, moduleName);
                        let statusArray = [];
                        let countArray = [];
                        let outObj = {}
                        for (let item of result) {
                            let dispValue = String(item.DISPLAY_VALUE).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            statusArray.push(dispValue);
                            countArray.push(item.TOTAL);
                        }
                        outObj["label"] = statusArray;
                        outObj["series"] = countArray;
                        dataArray.push(outObj)
                        result = await responseHandler.sendResponse("Success", "Task count  fetched ", 200, dataArray, true, "taskCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        let outObj = {
                            label: [],
                            series: []
                        }
                        appLogger.logMessage("info", "No task avaliable", "PMService", "taskCountByStatus", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No Task available ", 400, [outObj], false, "taskCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch task count by status", "PMService", "taskCountByStatus", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch task count ", 400, null, false, "taskCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "taskCountByStatus", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "taskCountByStatus Service completed.", "PMService", "taskCountByStatus", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "taskCountByStatus", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "taskCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // change user existing functional role
    changeExistsFuncRole: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "changeExistsFuncRole service initiated", "PMService", "changeExistsFuncRole", loggedUser, tenant, moduleName);
        let result;
        let notifyResult
        try {
            if (body.userId != null && body.userId != undefined && body.projectId != null && body.projectId != undefined && body.roleCode != null && body.roleCode != undefined) {
                let roleId = null;
                if (body.isNewRole == 'true') {
                    if (body.role != undefined && body.role != null){
                        if(body.role.trim() != '') {
                            let assignRole = await this.addfunctionalroles(body, loggedUser, tenant)
                            if (assignRole.statusCode == 200) {
                                roleId = assignRole.data;
                            } else {
                                roleId = (assignRole.data.length > 0) ? assignRole.data[0].ID : null
                            }
                        } else {
                            appLogger.logMessage("debug", "Invalid entry for Role.", className, "changeExistsFuncRole", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse('Warning', "Please enter valid functional role.", 400, null, false, "changeExistsFuncRole", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                            return result;
                        }
                    }
                } else {
                    if (body.role != undefined && body.role != null){
                        if(body.role.trim() != '') {
                            roleId = body.role
                        }
                    }
                }
                let assignResult = await dbOperations.executeQuery(mysqlQueries.updateProjectRole, [body.roleCode, roleId, body.userId, body.projectId], loggedUser, "updateProjectRole", false, null, tenant, appLogger, meteringLogger, moduleName);
                if (assignResult != null && assignResult != undefined && assignResult.affectedRows > 0) {
                    
						 let sender=await dbOperations.executeQuery(mysqlQueries.sendersData, [body.loggedUserId,body.tenantId,body.projectId], loggedUser, "recipientdata", false, null, tenant, appLogger, meteringLogger, moduleName);
                         let recipient=await dbOperations.executeQuery(mysqlQueries.recipientData, [body.userId,body.tenantId,body.role], loggedUser, "recipientdata", false, null, tenant, appLogger, meteringLogger, moduleName); 
                         appLogger.logMessage("debug", "Successfully updated functional role.", className, "changeExistsFuncRole", loggedUser, tenant, moduleName);
                         result = await responseHandler.sendResponse('Success', "Successfully updated functional role.", 200, null, false, "changeExistsFuncRole", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                         if (recipient[0].ROLE_NAME==="Project Manager"||recipient[0].ROLE_NAME==="Delegated Project Manager"){
                             let message=sender[0].FULL_NAME+" made an update to your role in the Project "+sender[0].PROJECT_NAME+", and you are now the "+recipient[0].ROLE_NAME;
                             let payload = {
                                 "message":message,
                                 "loggedUser":sender[0].FULL_NAME,
                                 "whatsappNumber":recipient[0].WHATSAPP_NUMBER,
                                 "tenant": body.tenant,
                                 "tenantId": body.tenantId,
                                 "whatsappId":recipient[0].WHATSAPP_ID
                             }
                             endPoint = config.whatsAppServerUrl + config.whatsAppEndpoints.notifyUser;
                             //in local
                             //endPoint = "http://localhost:7052" + config.whatsAppEndpoints.notifyUser;
                             notifyResult = await PMSSupport.sendNotificationInWhatsapp(endPoint,payload,body.loggedUser,body.tenant);
                             
                         }
                       
                         appLogger.logMessage("debug", "Response after notifying user about funtional role change: " + JSON.stringify(notifyResult), className, "updateTaskPriority", body.loggedUser,body.tenant, moduleName); 
                    appLogger.logMessage("debug", "Successfully updated functional role.", className, "changeExistsFuncRole", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse('Success', "Successfully updated functional role.", 200, null, false, "changeExistsFuncRole", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                } else {
                    appLogger.logMessage("debug", "Failed to update functional role.", className, "changeExistsFuncRole", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse('Warning', "Failed to update functional role.", 400, null, false, "changeExistsFuncRole", tenant, loggedUser, moduleName, appLogger, meteringLogger)
                }
            } else {
                appLogger.logMessage("debug", "Invalid parameters.", className, "changeExistsFuncRole", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse('Warning', "Invalid parameters.", 400, null, false, "changeExistsFuncRole", tenant, loggedUser, moduleName, appLogger, meteringLogger)
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "changeExistsFuncRole", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "changeExistsFuncRole Service completed.", "PMService", "changeExistsFuncRole", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "changeExistsFuncRole", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "changeExistsFuncRole", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // TASK COUNT BASED ON PRIORITY FOR EMPLOYEE AND PM
    taskCountByPriority: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "taskCountByPriority service initiated", "PMService", "taskCountByPriority", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.taskCountByPriority);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch task count  due to missing parameters: " + JSON.stringify(missingParams), className, "taskCountByPriority", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "taskCountByPriority", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let query
                let param = []
                let dataArray = [], seriesArray = [], labelArray = []
                if (String(body.role).toLowerCase() == "employee") {
                    //if (String(body.isAllProjects).toLowerCase() == "true") {
                    if (projectsLength==0){
                    // show  task count for all projects employee is onboarded
                        query = mysqlQueries.allTaskCountByPriorityForEmp
                        param = [body.loggedUserId, body.tenantId]
                    } else {
                        //show  task count for a specefic project in which loggedUser is on boarded
                        query = mysqlQueries.taskCountByPriorityForEmp
                        param = [body.loggedUserId, body.tenantId, Projects]
                    }

                } else if (String(body.role).toLowerCase() == "project_manager") {
                   // if (String(body.isAllProjects).toLowerCase() == "true") {
                    if (projectsLength==0){   
                         //show  task count for all projects in which loggedUser is a part of it 
                        query = mysqlQueries.allTaskCountByPriorityForPM
                        param = [body.loggedUserId, body.tenantId]
                    } else {
                        //show  task count for a specfic project in which loggedUser is a part of it 
                        query = mysqlQueries.taskCountByPriorityForPM
                        param = [body.loggedUserId, body.tenantId, Projects]
                    }
                }
                result = await dbOperations.executeQuery(query, param, loggedUser, "taskCountByPriority", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", "Task count  by priority fetched successfully", "PMService", "taskCountByPriority", loggedUser, tenant, moduleName);
                        for (let x of result) {
                            let dispValue = String(x.DISPLAY_VALUE).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            labelArray.push(dispValue);
                            seriesArray.push(x.TOTAL);
                        }
                        let obj = { 'series': seriesArray, 'label': labelArray }
                        dataArray.push(obj)
                        result = await responseHandler.sendResponse("Success", "Task count  fetched ", 200, dataArray, true, "taskCountByPriority", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "No task avaliable", "PMService", "taskCountByPriority", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No Task available ", 400, null, false, "taskCountByPriority", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch task count by status", "PMService", "taskCountByPriority", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch task count ", 400, null, false, "taskCountByPriority", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "taskCountByPriority", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "taskCountByPriority Service completed.", "PMService", "taskCountByPriority", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "taskCountByPriority", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "taskCountByPriority", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    // COUNT OF ISSUE BY PROJECT FOR EMPLOYEE AND PM
    issueCountByProject: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "issueCountByProject service initiated", "PMService", "issueCountByProject", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.issueCountByProject);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch issue count  due to missing parameters: " + JSON.stringify(missingParams), className, "issueCountByProject", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "issueCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let issueArray = []
                let query, param = []
                // fetch task count in each project
                if (String(body.role).toLowerCase() == "employee") {
                    if (projectsLength==0){
                    query = mysqlQueries.issueCountByProjectForEmp
                    param = [body.loggedUserId, body.tenantId]
                    }
                    else{
                    query = mysqlQueries.specificIssueCountByProjectForEmp
                    param = [body.loggedUserId, body.tenantId,Projects]
                    

                    }
                } else if (String(body.role).toLowerCase() == "project_manager") {
                    if (projectsLength==0){
                    query = mysqlQueries.issueCountByProjectForPM
                    param = [body.loggedUserId, body.tenantId]
                    }
                    else{
                    query = mysqlQueries.specificIssueCountByProjectForPM
                    param = [body.loggedUserId, body.tenantId,Projects]

                    }
                }

                result = await dbOperations.executeQuery(query, param, loggedUser, "issueCountByProject", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        let projectArray = [], countArray = []
                        for (let item of result) {
                            let dispValue = String(item.PROJECT_NAME).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            projectArray.push(dispValue);
                            countArray.push(item.ISSUE_COUNT);
                        }
                        let obj = { 'series': countArray, 'label': projectArray }
                        issueArray.push(obj)
                        appLogger.logMessage("info", "Issue count  fetched successfully", "PMService", "issueCountByProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Count  of issues fetched ", 200, issueArray, true, "issueCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "No issues avaliable", "PMService", "issueCountByProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No issues available ", 400, null, false, "issueCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch issue count", "PMService", "issueCountByProject", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch issue count ", 400, null, false, "issueCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "issueCountByAssignee", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "issueCountByAssignee Service completed.", "PMService", "issueCountByProject", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "issueCountByAssignee", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "issueCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    // COUNT OF TASK BY PROJECT FOR EMPLOYEE AND PM
    taskCountByProject: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "taskCountByProject service initiated", "PMService", "taskCountByProject", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.issueCountByProject);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch issue count  due to missing parameters: " + JSON.stringify(missingParams), className, "taskCountByProject", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "taskCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let taskArray = []
                let query, param = []
                if (String(body.role).toLowerCase() == "employee") {
                    if(projectsLength===0){
                    query = mysqlQueries.taskCountByProjectForEmp
                    param = [body.loggedUserId, body.tenantId] 
                    }
                    else{
                    query = mysqlQueries.specificTaskCountByProjectForEmp
                    param = [body.loggedUserId, body.tenantId,Projects] 
                    }
                   
                } else if (String(body.role).toLowerCase() == "project_manager") {
                    if(projectsLength===0){
                        query = mysqlQueries.taskCountByProjectForPM
                        param = [body.loggedUserId, body.tenantId]
                    }
                    else{
                        query = mysqlQueries.specificTaskCountByProjectForPM
                        param = [body.loggedUserId, body.tenantId,Projects]
                    }
                  
                }

                result = await dbOperations.executeQuery(query, param, loggedUser, "taskCountByProject", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        let projectArray = [], countArray = []
                        for (let item of result) {
                            let dispValue = String(item.PROJECT_NAME).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            projectArray.push(dispValue)
                            countArray.push(item.TASK_COUNT)
                        }
                        let obj = { 'series': countArray, 'label': projectArray }
                        taskArray.push(obj)
                        appLogger.logMessage("info", "Task count  fetched successfully", "PMService", "taskCountByProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Task count fetched ", 200, taskArray, true, "taskCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "No task avaliable", "PMService", "taskCountByProject", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No task available ", 400, null, false, "taskCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch task count", "PMService", "taskCountByProject", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch task count ", 400, null, false, "taskCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "taskCountByProject", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "taskCountByProject Service completed.", "PMService", "taskCountByProject", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "taskCountByProject", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "taskCountByProject", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    // COUNT ISSUE BY ITS PRIORITY
    issueCountByPriority: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "issueCountByStatus service initiated", "PMService", "issueCountByStatus", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.issueCountByPriority);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch issue count due to missing parameters: " + JSON.stringify(missingParams), className, "issueCountByPriority", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "issueCountByPriority", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let query
                let param = []
                let dataArray = [], seriesArray = [], labelArray = []
                //if (String(body.isAllProjects).toLowerCase() == "true") {
                    if (projectsLength==0){ 
                query = mysqlQueries.allIssueCountByPriority
                    param = [body.loggedUserId, body.tenantId]
                } else {
                    query = mysqlQueries.issueCountByPriority
                    let pIds = String(body.projectId).split(',');
                    param = [body.loggedUserId, body.tenantId, Projects]
                }

                result = await dbOperations.executeQuery(query, param, loggedUser, "issueToTask", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", "Issue count  by status fetched successfully", "PMService", "issueCountByPriority", loggedUser, tenant, moduleName);
                        for (let x of result) {
                            let dispValue = String(x.DISPLAY_VALUE).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            labelArray.push(dispValue);
                            seriesArray.push(x.TOTAL);
                        }
                        let obj = { 'series': seriesArray, 'label': labelArray }
                        dataArray.push(obj)
                        result = await responseHandler.sendResponse("Success", "Count  of issue status by project fetched ", 200, dataArray, true, "issueCountByPriority", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "No isues avaliable", "PMService", "issueCountByPriority", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No issues available ", 400, null, false, "issueCountByPriority", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch issue count by status", "PMService", "issueCountByPriority", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch issue count ", 400, null, false, "issueCountByPriority", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "issueCountByPriority", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "issueCountByPriority Service completed.", "PMService", "issueCountByPriority", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "issueCountByPriority", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "issueCountByPriority", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },


    // COUNT ISSUE BY ITS  ASSIGNED BY PERSON
    issueCountByAssignedBy: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "issueCountByAssignedBy service initiated", "PMService", "issueCountByAssignedBy", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.issueCountByAssignedBy);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch issue count due to missing parameters: " + JSON.stringify(missingParams), className, "issueCountByAssignedBy", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "issueCountByAssignedBy", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let query
                let param = []
                let dataArray = [], seriesArray = [], labelArray = []
                //if (String(body.isAllProjects).toLowerCase() == "true") {
                if (projectsLength==0){  
                query = mysqlQueries.allIssueCountByAssignedBy
                    param = [body.loggedUserId, body.tenantId]
                } else {
                    query = mysqlQueries.issueCountByAssignedBy
                    param = [body.loggedUserId, body.tenantId, Projects]
                }

                result = await dbOperations.executeQuery(query, param, loggedUser, "issueCountByAssignedBy", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", "Issue count  by status fetched successfully", "PMService", "issueCountByAssignedBy", loggedUser, tenant, moduleName);
                        for (let x of result) {
                            let dispValue = String(x.FULL_NAME).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            labelArray.push(dispValue);
                            seriesArray.push(x.ISSUE_COUNT);
                        }
                        let obj = { 'series': seriesArray, 'label': labelArray }
                        dataArray.push(obj)
                        result = await responseHandler.sendResponse("Success", "Count  of issue status by project fetched ", 200, dataArray, true, "issueCountByPriority", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("info", "No isues avaliable", "PMService", "issueCountByAssignedBy", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No issues available ", 400, null, false, "issueCountByAssignedBy", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch issue count by status", "PMService", "issueCountByAssignedBy", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch issue count ", 400, null, false, "issueCountByAssignedBy", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "issueCountByAssignedBy", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "issueCountByAssignedBy Service completed.", "PMService", "issueCountByAssignedBy", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "issueCountByAssignedBy", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "issueCountByAssignedBy", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    // COUNT ISSUE BY ITS  CREATED  BY PERSON
    issueCountByCreatedBy: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "issueCountByCreatedBy service initiated", "PMService", "issueCountByCreatedBy", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.issueCountByCreatedBy);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch issue count due to missing parameters: " + JSON.stringify(missingParams), className, "issueCountByCreatedBy", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "issueCountByCreatedBy", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let query
                let param = []
                let dataArray = [], seriesArray = [], labelArray = []
                //if (String(body.isAllProjects).toLowerCase() == "true") {
                if (projectsLength==0){  
                query = mysqlQueries.allIssueCountByCreatedBy
                    param = [body.loggedUserId, body.tenantId]
                } else {
                    query = mysqlQueries.issueCountByCreatedBy
                    param = [body.loggedUserId, body.tenantId,Projects]
                }

                result = await dbOperations.executeQuery(query, param, loggedUser, "issueCountByCreatedBy", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", "Issue count  fetched successfully", "PMService", "issueCountByCreatedBy", loggedUser, tenant, moduleName);
                        let res = result.reduce((hash, obj) => ({ ...hash, [obj["ID"]]: (hash[obj["ID"]] || []).concat(obj) }), {})
                        for (let x of result) {
                            let dispValue = String(x.FULL_NAME).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            labelArray.push(dispValue)
                            seriesArray.push(x.ISSUE_COUNT)
                        }
                        let obj = { 'series': seriesArray, 'label': labelArray }
                        dataArray.push(obj)
                        result = await responseHandler.sendResponse("Success", "Issue count by project fetched ", 200, dataArray, true, "issueCountByCreatedBy", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("info", "No isues avaliable", "PMService", "issueCountByCreatedBy", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No issues available ", 400, null, false, "issueCountByCreatedBy", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch issue count", "PMService", "issueCountByCreatedBy", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch issue count ", 400, null, false, "issueCountByCreatedBy", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "issueCountByCreatedBy", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "issueCountByCreatedBy Service completed.", "PMService", "issueCountByCreatedBy", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "issueCountByCreatedBy", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "issueCountByCreatedBy", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getIssuesBasedOnSeverity: async function (req, projectsLength,loggedUser, tenant,Projects) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully fetched issue details",
            data: []
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getIssuesBasedOnSeverity);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to fetch issues based on priority due to missing parameters: " + JSON.stringify(missingParams), className, "getIssuesBasedOnSeverity", loggedUser, tenant, moduleName);
                    out.status = "Warning"; out.message = "Missing parameters: " + JSON.stringify(missingParams);

                } else {
                    let query;
                    let param = [];
                    // if (String(req.body.isAllProjects).toLowerCase() == "true") {
                        if (projectsLength==0){
                        query = mysqlQueries.getIssuesBasedOnSeverity;
                        param = [body.loggedUserId];
                    } else {
                        query = mysqlQueries.getIssuesBasedOnSeverityByProject;
                        param = [body.loggedUserId, Projects];
                    }
                    let result = await dbOperations.executeQuery(query, param, body.loggedUser, "getIssuesBasedOnSeverity", false, null, tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined && result != "error") {
                        if (result.length > 0) {
                            appLogger.logMessage("info", "issues fetched based on severity successfully", className, "getIssuesBasedOnSeverity", loggedUser, tenant, moduleName);
                            let projectData = {};
                            let severity = [];
                            let total = [];
                            for (let row of result) {
                                let dispValue = String(row.SEVERITY).toUpperCase();
                                let firstChar = dispValue[0];
                                dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                                dispValue = firstChar+dispValue;
                                severity.push(dispValue);
                                total.push(row.TOTAL);
                            }
                            projectData["label"] = severity;
                            projectData["series"] = total;

                            out.data = [projectData];
                        } else {
                            appLogger.logMessage("debug", "Failed to postpone the task . Result received after executing the query: " + JSON.stringify(result), className, "getIssuesBasedOnSeverity", body.loggedUser, tenant, moduleName);
                            out.status = "Failed"; out.message = "Failed to postpone the task";
                        }
                    } else {
                        out.status = "Failed";
                        out.message = "Failed to postpone the task due to invalid data received from the server";
                        appLogger.logMessage("debug", out.message, className, "getIssuesBasedOnSeverity", body.loggedUser, body.tenant, moduleName);
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to update project details due to invalid request body", className, "getIssuesBasedOnSeverity", loggedUser, tenant, moduleName);
                out.status = "Failed";
                out.message = "Failed to update project details due to invalid request body";
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "getIssuesBasedOnSeverity", startDateTime, endDateTime, diffInMS, moduleName);

        } catch (error) {
            appLogger.logMessage("error", "Failed to fetch issues based on priority due to: " + JSON.stringify(error.message), className, "getIssuesBasedOnSeverity", loggedUser, tenant, moduleName);
            out.status = "Failure";
            out.message = "Failed to fetch issued based on severity due to: " + JSON.stringify(error.message);
        }
        out = result = await responseHandler.sendResponse(out.status, out.message, out.statusCode, out.data, false, "getIssuesBasedOnSeverity", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        return out;
    },
    createDashboard: async function (req, loggedUser, tenant) {
        let functionName = "createDashboard";
        appLogger.logMessage("info", "createDashboard function called", className, functionName, loggedUser, tenant, moduleName);
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        let out = {
            status: "Success",
            message: "Successfully created the dashboard",
            statusCode: 200,
            data: {}
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.createDashboard);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to create dashboard due to missing parameters: " + JSON.stringify(missingParams), className, functionName, loggedUser, tenant, moduleName);
                    out.status = "Warning"; out.message = "Missing parameters: " + JSON.stringify(missingParams);
                } else {

                
                        let dashboardJson = {
                            userId: req.body.loggedUserId,
                            dashboardName: req.body.dashboardName,
                            dashboardDescription: req.body.dashboardDescription,
                            cardStructure: []
                        }
                        dashboardJson["tblFilterRequired"] = true;
                        let projectData;
                        let countData = [];
                        let i = 0;
                        let position = -1;
                        let dashboardConfiguration;
                        let insertFlag = true;
                        if (req.body.configuration || req.body.isGet) {
                            dashboardConfiguration = req.body.configuration;
                            insertFlag = false;
                        } else {
                            dashboardConfiguration = dashboardConfig;
                        }
                        if (dashboardConfiguration.cardCounts) {
                            if (String(dashboardConfiguration.cardCounts.defaultCategory).toLowerCase() == "projects") {
                                projectData = await this.projectCountByStatus(req.body,0, loggedUser, tenant);
                                if (projectData.data.length > 0) {
                                    let k = 0
                                    for (let data of projectData.data[0].series) {
                                        countData.push({
                                            cardId: i,
                                            status: projectData.data[0].label[k],
                                            count: projectData.data[0].series[k]
                                        })
                                        k++;
                                        i += 1;
                                    }
                                }
                            } else if (String(dashboardConfiguration.cardCounts.defaultCategory).toLowerCase() == "tasks") {
                                let taskData = await this.taskCountByStatus(req.body,0,loggedUser, tenant);
                                if (taskData.data.length > 0) {
                                    let k = 0
                                    for (let data of taskData.data[0].series) {
                                        countData.push({
                                            cardId: i,
                                            status: taskData.data[0].label[k],
                                            count: taskData.data[0].series[k]
                                        })
                                        k++;
                                        i += 1;
                                    }
                                }
                            } else if (String(dashboardConfiguration.cardCounts.defaultCategory).toLowerCase() == "issues") {
                                let issueData = await this.issueCountByStatus(req.body,0, loggedUser, tenant);
                                if (issueData.data.length > 0) {
                                    let k = 0
                                    for (let data of issueData.data[0].series) {
                                        countData.push({
                                            cardId: i,
                                            status: issueData.data[0].label[k],
                                            count: issueData.data[0].series[k]
                                        })
                                        k++;
                                        i += 1;
                                    }
                                }
                            }
                            let position = 0;
                            let cardCounts = {
                                "cardType": "cardCounts",
                                "category": dashboardConfiguration.cardCounts.defaultCategory,
                                "position": position,
                                "cardId": ++i,
                                "data": countData
                            }
                            dashboardJson.cardStructure.push(cardCounts);
                        }
                        if (dashboardConfiguration.table) {
                            let table = {
                                "cardType": "table",
                                "category": dashboardConfiguration.table.defaultCategory,
                                "data": {
                                    "cardId": ++i,
                                    "tableData": []
                                }
                            }
                            let projectData = await supportHandler.checkIfPMOrDPM({
                                loggedUser:loggedUser,
                                loggedUserId:req.body.loggedUserId,
                                tenant:tenant
                            })
                            if(String(projectData.status).toLowerCase() == "success"){
                                appLogger.logMessage("debug","Project Ids where the user is owner: "+projectData.data,className,functionName,req.body.loggedUser,tenant,moduleName);
                                let tableData = await supportHandler.getTasksList({
                                    loggedUser:loggedUser,
                                    tenant:tenant,
                                    loggedUserId:req.body.loggedUserId
                                })
                                if(String(tableData.status).toLowerCase() == "success"){
                                    tableData = tableData.data;
                                    if(tableData.length>0){
                                        for (let task of tableData) {
                                            table.data.tableData.push({
                                                Id: task.ID,
                                                Task: task.TASK_NAME,
                                                Project: task.PROJECT_NAME,
                                                "Estimated Start Date": moment(task.ESTIMATED_START_DATE).format("DD/MM/YYYY"),
                                                "Estimated End Date": moment(task.ESTIMATED_COMPLETION_DATE).format("DD/MM/YYYY"),
                                                "Actual Start Date": moment(task.ACTUAL_START_DATE).format("DD/MM/YYYY"),
                                                "Actual End Date": moment(task.ACTUAL_COMLETION_DATE).format("DD/MM/YYYY"),
                                                Status: task.STATUS,
                                                Assignee:task.ASSIGNEE
                                            })
                                    }
                                    dashboardJson.cardStructure.push(table);
                                    }
                                }else{
                                    let tableData = await dashboardService.getProjectTaskList(req.body, loggedUser, tenant);
                                    tableData = tableData.data;
                                    if(tableData.length>0){
                                        for (let task of tableData) {
                                            table.data.tableData.push({
                                                Id: task.ID,
                                                Task: task.TASK_NAME,
                                                Project: task.PROJECT_NAME,
                                                "Estimated Start Date": moment(task.ESTIMATED_START_DATE).format("DD/MM/YYYY"),
                                                "Estimated Completion Date": moment(task.ESTIMATED_COMPLETION_DATE).format("DD/MM/YYYY"),
                                                "Actual Start Date": moment(task.ACTUAL_START_DATE).format("DD/MM/YYYY"),
                                                "Actual Completion Date": moment(task.ACTUAL_COMPLETION_DATE).format("DD/MM/YYYY"),
                                                Status: task.DISPLAY_VALUE
                                            })
                                    }
                                    dashboardJson.cardStructure.push(table);
                                    }
                                }
                            }else{
                                let tableData = await dashboardService.getProjectTaskList(req.body, loggedUser, tenant);
                                tableData = tableData.data;
                                if(tableData.length>0){
                                    for (let task of tableData) {
                                        table.data.tableData.push({
                                            Id: task.ID,
                                            Task: task.TASK_NAME,
                                            Project: task.PROJECT_NAME,
                                            "Estimated Start Date": moment(task.ESTIMATED_START_DATE).format("DD/MM/YYYY"),
                                            "Estimated Completion Date": moment(task.ESTIMATED_COMPLETION_DATE).format("DD/MM/YYYY"),
                                            "Actual Start Date": moment(task.ACTUAL_START_DATE).format("DD/MM/YYYY"),
                                            "Actual Completion Date": moment(task.ACTUAL_COMPLETION_DATE).format("DD/MM/YYYY"),
                                            Status: task.DISPLAY_VALUE
                                        })
                                }
                                dashboardJson.cardStructure.push(table);
                                }
                            }
                        
                            
                        }
                        let chartData
                        let multiGraphs = {
                            "cardType": "multiGraphs",
                            "cardId": ++i,
                            "data": []
                        }
                        if (dashboardConfiguration.multiGraphs) {
                            for (let graph of Object.keys(dashboardConfiguration.multiGraphs)) {
                                switch (String(graph).toLowerCase()) {
                                    case "linechart":
                                        if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "status") {
                                            chartData = await this.taskCountByStatus(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "assignee") {
                                            chartData = await this.taskCountByAssignee(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "priority") {
                                            chartData = await this.taskCountByPriority(req.body, dashboardConfiguration.multiGraphs[graph].projectIds.length,loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "project") {
                                            chartData = await this.taskCountByProject(req.body, dashboardConfiguration.multiGraphs[graph].projectIds.length,loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "progress") {
                                            chartData = await this.getTaskProgress(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "projects" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "status") {
                                            chartData = await this.projectCountByStatus(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "projects" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "progress") {
                                            chartData = await this.getProjectProgress(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length,loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "status") {
                                            chartData = await this.issueCountByStatus(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "assignee") {
                                            chartData = await this.issueCountByAssignee(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "assigned by") {
                                            chartData = await this.issueCountByAssignedBy(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "priority") {
                                            chartData = await this.issueCountByPriority(req.body, dashboardConfiguration.multiGraphs[graph].projectIds.length,loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "created by") {
                                            chartData = await this.issueCountByCreatedBy(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "severity") {
                                            chartData = await this.getIssuesBasedOnSeverity(req,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "projects") {
                                            chartData = await this.issueCountByProject(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        }

                                        if(String(chartData.type).toLowerCase() =="success"){
                                            if(chartData.data.length>0){
                                                chartData = chartData.data[0];
                                                let defaultCategory = String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase();
                                                let firstChar = String(dashboardConfiguration.multiGraphs[graph].defaultCategory[0]).toUpperCase();
                                                defaultCategory = String(defaultCategory).slice(1,defaultCategory.length);
                                                defaultCategory = firstChar+defaultCategory;
                                                multiGraphs.data.push({
                                                    "type": graph,
                                                    "cardId": ++i,
                                                    "position": ++position,
                                                    "category": dashboardConfiguration.multiGraphs[graph].defaultCategory,
                                                    "overallProjects": dashboardConfiguration.multiGraphs[graph].overallProjects,
                                                    "projectIds": dashboardConfiguration.multiGraphs[graph].projectIds,
                                                    "fieldName": dashboardConfiguration.multiGraphs[graph].fieldName,
                                                    "series": [
                                                        {
                                                            "name": defaultCategory,
                                                            "data": chartData.series
                                                        }
                                                    ],
                                                    "xaxis": {
                                                        "categories": chartData.label
                                                    }
                                                })
                                             break;
                                            }else{
                                                if(req.body.addWidget || !insertFlag ||(req.body.isGet == undefined || req.body.isGet == null || req.body.isGet == false)){
                                                    // out.status = "Failure",
                                                    // out.message = "Can not create this dashboard because there is no data available for this dashboard.";
                                                    // return out;
                                                    // break;
                                                }else if(req.body.updateWidget){
                                                     out.status = "Failure",
                                                    out.message = "Cannot update this widget because there is no data available for this widget.";
                                                    //  return out;
                                                    // break;
                                                }
                                            
                                            }
                                        }else{
                                        if(req.body.addWidget || !insertFlag ||(req.body.isGet == undefined || req.body.isGet == null || req.body.isGet == false)){
                                                    // out.status = "Failure",
                                                    // out.message = "Can not create this dashboard because there is no data available for this dashboard.";
                                                    // return out;
                                                    if(req.body.updateWidget){
                                                        out.status = "Failure",
                                                       out.message = "Cannot update this widget because there is no data available for this widget.";
                                                      return out;
                                                    break;
                                                   }
                                                }else if(req.body.updateWidget){
                                                    out.status = "Failure",
                                                   out.message = "Cannot update this widget because there is no data available for this widget.";
                                                //    break;
                                                // return out;
                                               }
                                        }
                                        break;
                                    case "piechart":
                                        if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "severity") {
                                            chartData = await this.getIssuesBasedOnSeverity(req,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "status") {
                                            chartData = await this.issueCountByStatus(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "assignee") {
                                            chartData = await this.issueCountByAssignee(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "assigned by") {
                                            chartData = await this.issueCountByAssignedBy(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "priority") {
                                            chartData = await this.issueCountByPriority(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "created by") {
                                            chartData = await this.issueCountByCreatedBy(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "projects") {
                                            chartData = await this.issueCountByProject(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "status") {
                                            chartData = await this.taskCountByStatus(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "assignee") {
                                            chartData = await this.taskCountByAssignee(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "priority") {
                                            chartData = await this.taskCountByPriority(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "progress") {
                                            chartData = await this.getTaskProgress(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "project") {
                                            chartData = await this.taskCountByProject(req.body, dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "projects" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "status") {
                                            chartData = await this.projectCountByStatus(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "projects" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "progress") {
                                            chartData = await this.getProjectProgress(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length,loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        }
                                        if(String(chartData.type).toLowerCase() =="success"){
                                            if(chartData.data.length>0){
                                                chartData = chartData.data;
                                                let defaultCategory = String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase();
                                                let firstChar = String(dashboardConfiguration.multiGraphs[graph].defaultCategory[0]).toUpperCase();
                                                defaultCategory = String(defaultCategory).slice(1,defaultCategory.length);
                                                defaultCategory = firstChar+defaultCategory;
                                                multiGraphs.data.push({
                                                    "type": graph,
                                                    "cardId": ++i,
                                                    "position": ++position,
                                                    "category": defaultCategory,
                                                    "overallProjects":dashboardConfiguration.multiGraphs[graph].overallProjects,
                                                    "projectIds": dashboardConfiguration.multiGraphs[graph].projectIds,
                                                    "fieldName": dashboardConfiguration.multiGraphs[graph].fieldName,
                                                    "series": chartData[0].series,
                                                    "labels": chartData[0].label
                                                })
                                                break;
                                            }else{
                                                if(req.body.addWidget){
                                                    out.status = "Failure";
                                                    out.message = "Can not create this dashboard because there is no data available for this dashboard.";
                                                    return out;
                                                }else if(req.body.updateWidget){
                                                    out.status = "Failure",
                                                   out.message = "Can not update this widget because there is no data available for this widget.";
                                                   return out;
                                               }
                                            }
                                        }else{
                                        if(req.body.addWidget){
                                                    out.status = "Failure";
                                                    out.message = "Can not create this dashboard because there is no data available for this dashboard.";
                                                    return out;
                                                }else if(req.body.updateWidget){
                                                    out.status = "Failure",
                                                   out.message = "Can not update this widget because there is no data available for this widget.";
                                                   return out;
                                                   break;
                                               }
                                        }
                                        
                                    case "barchart":
                                        if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "projects" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "progress") {
                                            chartData = await this.getProjectProgress(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "projects" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "status") {
                                            chartData = await this.projectCountByStatus(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "status") {
                                            chartData = await this.taskCountByStatus(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "priority") {
                                            chartData = await this.taskCountByPriority(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "assignee") {
                                            chartData = await this.taskCountByAssignee(req.body, dashboardConfiguration.multiGraphs[graph].projectIds.length,loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "project") {
                                            chartData = await this.taskCountByProject(req.body, dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "tasks" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "progress") {
                                            chartData = await this.getTaskProgress(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "status") {
                                            chartData = await this.issueCountByStatus(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "priority") {
                                            chartData = await this.issueCountByPriority(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "severity") {
                                            chartData = await this.getIssuesBasedOnSeverity(req,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "assignee") {
                                            chartData = await this.issueCountByAssignee(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "assigned by") {
                                            chartData = await this.issueCountByAssignedBy(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "created by") {
                                            chartData = await this.issueCountByCreatedBy(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        } else if (String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase() == "issues" && String(dashboardConfiguration.multiGraphs[graph].fieldName).toLowerCase() == "projects") {
                                            chartData = await this.issueCountByProject(req.body,dashboardConfiguration.multiGraphs[graph].projectIds.length, loggedUser, tenant,dashboardConfiguration.multiGraphs[graph].projectIds);
                                        }
                                        if(String(chartData.type).toLowerCase() =="success"){
                                            if(chartData.data.length>0){
                                                chartData = chartData.data;
                                                let defaultCategory = String(dashboardConfiguration.multiGraphs[graph].defaultCategory).toLowerCase();
                                                let firstChar = String(dashboardConfiguration.multiGraphs[graph].defaultCategory[0]).toUpperCase();
                                                defaultCategory = String(defaultCategory).slice(1,defaultCategory.length);
                                                defaultCategory = firstChar+defaultCategory;
                                                multiGraphs.data.push({
                                                    "type": graph,
                                                    "cardId": ++i,
                                                    "position": position++,
                                                    "category": defaultCategory,
                                                    "overallProjects": dashboardConfiguration.multiGraphs[graph].overallProjects,
                                                    "projectIds": dashboardConfiguration.multiGraphs[graph].projectIds,
                                                    "fieldName": dashboardConfiguration.multiGraphs[graph].fieldName,
                                                    "series": [{
                                                        "name": dashboardConfiguration.multiGraphs[graph].defaultCategory,
                                                        "data": chartData[0].series
                                                    }],
                                                    "xaxis": {
                                                        "categories": chartData[0].label
                                                    }
                                                })
                                              // break;
                                            }else{
                                                if(req.body.addWidget || !insertFlag ||(req.body.isGet == undefined || req.body.isGet == null || req.body.isGet == false)){
                                                    // out.status = "Failure",
                                                    // out.message = "Can not create this dashboard because there is no data available for this dashboard.";
                                                    // return out;
                                                    if(req.body.updateWidget){
                                                        out.status = "Failure",
                                                       out.message = "Can not update this widget because there is no data available for this widget.";
                                                       return out;
                                                   }
                                                }else if(req.body.updateWidget){
                                                    out.status = "Failure",
                                                   out.message = "Can not update this widget because there is no data available for this widget.";
                                                   return out;
                                               }
                                            }
                                        }else{
                                        if(req.body.addWidget || !insertFlag ||(req.body.isGet == undefined || req.body.isGet == null || req.body.isGet == false)){
                                                    // out.status = "Failure",
                                                    // out.message = "Can not create this dashboard because there is no data available for this dashboard.";
                                                    // return out;
                                                    if(req.body.updateWidget){
                                                        out.status = "Failure",
                                                       out.message = "Can not update this widget because there is no data available for this widget.";
                                                       return out;
                                                       break;
                                                   }
                                                }else if(req.body.updateWidget){
                                                    out.status = "Failure",
                                                   out.message = "Can not update this widget because there is no data available for this widget.";
                                                //    return out;
                                               }
                                        }
                                        
                                }
                            }
                            dashboardJson.cardStructure.push(multiGraphs);
                        }
                    
                        let dispObj = {
                            status:"Success",
                            message:"Successfully added widget"
                        }
                        if(dashboardConfiguration.customeWidgets){
                            let res = await this.populateCustomeWidgets(req,dashboardJson.cardStructure,dashboardConfiguration,loggedUser,tenant,i,position);
                            if(String(res.status).toLowerCase() == "success"){
                                dashboardJson.cardStructure = res.data;
                            }else{
                                dispObj.status = "Failure";
                                dispObj.message = res.message;
                                return dispObj
                            }
                        }
                        if (insertFlag) {
                            let isExists=await supportHandler.isDashBoardExists(body.dashboardName,body.loggedUserId,body.loggedUser,body.tenant)  
                            if(isExists.status=='Warning'){
                                out.status='Warning'
                                out.statusCode=400
                                out.message="Dashboard name already exists."
                                out.data=[]
                            }else if(isExists.status=='Failure') {
                                out.status='Failure'
                                out.statusCode=500
                                out.message="Failed to create dashboard."
                                out.data=[]
                            } else if(isExists.status=='Success')  {
                            let createQuery = { "dashboard": dashboardJson, "configuration": dashboardConfiguration }
                            let result = await mongoOperations.executeMongoInsert(loggedUser, "dashboard", createQuery, "createDashboard", tenant, appLogger, meteringLogger, moduleName);
                            if (result != null && result != undefined) {
                                if (result.insertedId) {
                                    out.status = "Success";
                                    out.message = "Dashboard Created Successfully";
                                    out.statusCode = 200;
                                    dashboardJson["tblFilterRequired"] = true;
                                    out.data = { dashboardId: result.insertedId };
                                    appLogger.logMessage("debug", "dashboard  added  successfully. Result received after executing the query: " + JSON.stringify(result), className, "createDashboard", loggedUser, tenant, moduleName);

                                } else {
                                    out.status = "Failure";
                                    out.message = "Internal server error";
                                    out.data = "Failed to insert dashboard to mongodb due to invalid server error: " + JSON.stringify(result);
                                    appLogger.logMessage("debug", "Failed to craate dashboard. Result received after executing the query: " + JSON.stringify(result), className, "createDashboard", loggedUser, tenant, moduleName);
                                }
                            } else {
                                out.status = "Failure";
                                out.message = "Internal server error";
                                out.data = "Failed to insert dashboard to mongodb due to internal server error";
                                appLogger.logMessage("error", out.data, className, functionName, loggedUser, tenant, moduleName);
                            }
                            }
                        } else if (req.body.isGet) {
                            out.status = "Success";
                            out.message = "Dashboard Created Successfully";
                            out.statusCode = 200;
                            dashboardJson["dashboardId"] = req.body.id;
                            dashboardJson["tblFilterRequired"] = true;
                            out.data = dashboardJson;
                        } else {
                            let createQuery = { "$set": { "dashboard": dashboardJson, "configuration": dashboardConfiguration } }
                            let condition = { '_id': ObjectID(req.body.dashboardId) }
                            let result = await mongoOperations.executeMongoUpdate(loggedUser, "dashboard", condition, createQuery, "updateDashboard", tenant, appLogger, meteringLogger, moduleName);
                            if(req.body.addWidget){
                                out.status = dispObj.status;
                                out.message = dispObj.message;
                            }else{
                                out.status = "Success";
                                out.message = "Successfully updated the dashboard";
                                out.data = {
                                    dashboardId: req.body.dashboardId
                                }
                            }
                        }
                    
                }
            } else {
                appLogger.logMessage("info", "Failed to create dashboard due to invalid request body", className, functionName, loggedUser, tenant, moduleName);
                out.status = "Failed";
                out.message = "Failed to create dashboard due to invalid request body";
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to create dashboard due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", out.data, className, functionName, loggedUser, tenant, moduleName);
        }
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(tenant, loggedUser, className, functionName, startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },
    getFilteredTaskList:async function(req,loggedUser,tenant){
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        let functionName = "getFilteredTaskList";
        let out = {
            status:"Success",
            message:"Successfully fetched task list based on date filter",
            data:[]
        }
        try {
            let tableData = await supportHandler.getTasksList(req);
            if(String(tableData.status).toLowerCase() == "success"){
                tableData = tableData.data;
                if(tableData.length>0){
                    for (let task of tableData) {
                        out.data.push({
                            Id: task.ID,
                            Task: task.TASK_NAME,
                            Project: task.PROJECT_NAME,
                            "Estimated Start Date": moment(task.ESTIMATED_START_DATE).format("DD/MM/YYYY"),
                            "Estimated End Date": moment(task.ESTIMATED_COMPLETION_DATE).format("DD/MM/YYYY"),
                            "Actual Start Date": moment(task.ACTUAL_START_DATE).format("DD/MM/YYYY"),
                            "Actual End Date": moment(task.ACTUAL_COMLETION_DATE).format("DD/MM/YYYY"),
                            Status: task.STATUS,
                            Assignee:task.ASSIGNEE
                        })
                }
                }else{
                    out.status = "Failure";
                    out.message = "No tasks to displays for the last week"
                }
            }else{
                out.status = "Failure";
                out.message = "Failed to fetch task list due to invalid response received from the server";
            }
        } catch (error) {
            out.status = "Error";
            out.message = "Failed to fetch task list due to: "+JSON.stringify(error.message);
            appLogger.logMessage("error",out.message,className,functionName,loggedUser,tenant,moduleName);
        }
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(tenant, loggedUser, className, functionName, startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },
    populateCustomeWidgets:async function(req,cardStructure,configuration,loggedUser,tenant,i,position){
        let out = {
            "status":"Success",
            "message":"added new widget",
            "data":{}
        }
        appLogger.logMessage("info","populateCustomeWidget called",className,"populateCustomeWidget",loggedUser,tenant,moduleName);
        try {
            if(configuration.customeWidgets){
                if(configuration.customeWidgets.length>0){
                    let outCard = {
                        "cardType":"multiGraphs",
                        "data":[]
                    }
                    let chartData;
                    for(let widget of configuration.customeWidgets){
                        let graph = Object.keys(widget)[1];
                            switch (String(graph).toLowerCase()) {
                                case "linechart":
                                    if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "status") {
                                        chartData = await this.taskCountByStatus(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "assignee") {
                                        chartData = await this.taskCountByAssignee(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "priority") {
                                        chartData = await this.taskCountByPriority(req.body,widget[graph].projectIds.length,loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "project") {
                                        chartData = await this.taskCountByProject(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "progress") {
                                        chartData = await this.getTaskProgress(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "projects" && String(widget[graph].fieldName).toLowerCase() == "status") {
                                        chartData = await this.projectCountByStatus(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "projects" && String(widget[graph].fieldName).toLowerCase() == "progress") {
                                        chartData = await this.getProjectProgress(req.body,widget[graph].projectIds.length,loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "status") {
                                        chartData = await this.issueCountByStatus(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "assignee") {
                                        chartData = await this.issueCountByAssignee(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "assigned by") {
                                        chartData = await this.issueCountByAssignedBy(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "priority") {
                                        chartData = await this.issueCountByPriority(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "created by") {
                                        chartData = await this.issueCountByCreatedBy(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "severity") {
                                        chartData = await this.getIssuesBasedOnSeverity(req,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "projects") {
                                        chartData = await this.issueCountByProject(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    }
                                    if(String(chartData.type).toLowerCase() =="success"){
                                        if(chartData.data.length>0){
                                            chartData = chartData.data;
                                            let cardId = ++i;
                                            widget["cardId"] = cardId;
                                            let defaultCategory = String(widget[graph].defaultCategory).toLowerCase();
                                            let firstChar = String(widget[graph].defaultCategory[0]).toUpperCase();
                                            defaultCategory = String(defaultCategory).slice(1,defaultCategory.length);
                                            defaultCategory = firstChar+defaultCategory;
                                            outCard.data.push({
                                                "type": graph,
                                                "cardId": cardId,
                                                "position": ++position,
                                                "category": defaultCategory,
                                                "overallProjects": widget[graph].overallProjects,
                                                "projectIds": widget[graph].projectIds,
                                                "fieldName": widget[graph].fieldName,
                                                "series": [
                                                    {
                                                        "name": defaultCategory,
                                                        "data": chartData[0].series
                                                    }
                                                ],
                                                "xaxis": {
                                                    "categories": chartData[0].label
                                                }
                                            })
                                        } else {
                                            if (req.body.addWidget) {
                                                out.status = "Failure";
                                                out.message = "Can not create this widget because there is no data available for this widget.";
                                                return out;
                                            }
                                            else if(req.body.updateWidget){
                                                out.status = "Failure",
                                               out.message = "Can not update this widget because there is no data available for this widget.";
                                               return out;
                                           }

                                        }
                                    } else {
                                        if (req.body.addWidget) {
                                            out.status = "Failure";
                                            out.message = "Can not create this widget because there is no data available for this widget.";
                                            return out;
                                        }else if(req.body.updateWidget){
                                            out.status = "Failure",
                                           out.message = "Can not update this widget because there is no data available for this widget.";
                                           return out;
                                       }
                                    }
                                   
                                    break;
                                case "piechart":
                                    if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "severity") {
                                        chartData = await this.getIssuesBasedOnSeverity(req,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "status") {
                                        chartData = await this.issueCountByStatus(req.body,widget[graph].projectIds.length,loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "assignee") {
                                        chartData = await this.issueCountByAssignee(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "assigned by") {
                                        chartData = await this.issueCountByAssignedBy(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "priority") {
                                        chartData = await this.issueCountByPriority(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "created by") {
                                        chartData = await this.issueCountByCreatedBy(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "projects") {
                                        chartData = await this.issueCountByProject(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "status") {
                                        chartData = await this.taskCountByStatus(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "assignee") {
                                        chartData = await this.taskCountByAssignee(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "priority") {
                                        chartData = await this.taskCountByPriority(req.body,widget[graph].projectIds.length,loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "progress") {
                                        chartData = await this.getTaskProgress(req.body,widget[graph].projectIds.length,loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "project") {
                                        chartData = await this.taskCountByProject(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "projects" && String(widget[graph].fieldName).toLowerCase() == "status") {
                                        chartData = await this.projectCountByStatus(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "projects" && String(widget[graph].fieldName).toLowerCase() == "progress") {
                                        chartData = await this.getProjectProgress(req.body,widget[graph].projectIds.length,  loggedUser, tenant,widget[graph].projectIds);
                                    }
                                    if (String(chartData.type).toLowerCase() == "success") {
                                        if (chartData.data.length > 0) {
                                            chartData = chartData.data;
                                            let cardId = ++i;
                                            widget["cardId"] = cardId;
                                            let defaultCategory = String(widget[graph].defaultCategory).toLowerCase();
                                            let firstChar = String(widget[graph].defaultCategory[0]).toUpperCase();
                                            defaultCategory = String(defaultCategory).slice(1,defaultCategory.length);
                                            defaultCategory = firstChar+defaultCategory;
                                            outCard.data.push({
                                                "type": graph,
                                                "cardId": cardId,
                                                "position": ++position,
                                                "category": defaultCategory,
                                                "overallProjects": widget[graph].overallProjects,
                                                "projectIds": widget[graph].projectIds,
                                                "fieldName": widget[graph].fieldName,
                                                "series": chartData[0].series,
                                                "labels": chartData[0].label
                                            })
                                            break;
                                        } else {
                                            if (req.body.addWidget) {
                                                out.status = "Failure";
                                                out.message = "Can not create this widget because there is no data available for this widget.";
                                                return out;
                                            }
                                        }
                                    } else {
                                        if (req.body.addWidget) {
                                            out.status = "Failure";
                                            out.message = "Can not create this widget because there is no data available for this widget.";
                                            return out;
                                        }
                                    }
                                    
                                case "barchart":
                                    if (String(widget[graph].defaultCategory).toLowerCase() == "projects" && String(widget[graph].fieldName).toLowerCase() == "progress") {
                                        chartData = await this.getProjectProgress(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "projects" && String(widget[graph].fieldName).toLowerCase() == "status") {
                                        chartData = await this.projectCountByStatus(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "status") {
                                        chartData = await this.taskCountByStatus(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "priority") {
                                        chartData = await this.taskCountByPriority(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "assignee") {
                                        chartData = await this.taskCountByAssignee(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "project") {
                                        chartData = await this.taskCountByProject(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "tasks" && String(widget[graph].fieldName).toLowerCase() == "progress") {
                                        chartData = await this.getTaskProgress(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "status") {
                                        chartData = await this.issueCountByStatus(req.body,widget[graph].projectIds.length,loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "priority") {
                                        chartData = await this.issueCountByPriority(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "severity") {
                                        chartData = await this.getIssuesBasedOnSeverity(req,widget[graph].projectIds.length,loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "assignee") {
                                        chartData = await this.issueCountByAssignee(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "assigned by") {
                                        chartData = await this.issueCountByAssignedBy(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "created by") {
                                        chartData = await this.issueCountByCreatedBy(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    } else if (String(widget[graph].defaultCategory).toLowerCase() == "issues" && String(widget[graph].fieldName).toLowerCase() == "projects") {
                                        chartData = await this.issueCountByProject(req.body,widget[graph].projectIds.length, loggedUser, tenant,widget[graph].projectIds);
                                    }
                                    if(String(chartData.type).toLowerCase() =="success"){
                                        if(chartData.data.length>0){
                                            chartData = chartData.data;
                                            let cardId = ++i;
                                            widget["cardId"] = cardId;
                                            let defaultCategory = String(widget[graph].defaultCategory).toLowerCase();
                                            let firstChar = String(widget[graph].defaultCategory[0]).toUpperCase();
                                            defaultCategory = String(defaultCategory).slice(1,defaultCategory.length);
                                            defaultCategory = firstChar+defaultCategory;
                                            outCard.data.push({
                                                "type": graph,
                                                "cardId": cardId,
                                                "position": position++,
                                                "category": defaultCategory,
                                                "overallProjects": widget[graph].overallProjects,
                                                "projectIds": widget[graph].projectIds,
                                                "fieldName": widget[graph].fieldName,
                                                "series": [{
                                                    "name": defaultCategory,
                                                    "data": chartData[0].series
                                                }],
                                                "xaxis": {
                                                    "categories": chartData[0].label
                                                }
                                            })
                                            break;
                                        }else{
                                            if (req.body.addWidget) {
                                                out.status = "Failure";
                                                    out.message = "Can not create this widget because there is no data available for this widget.";
                                                return out;
                                            }
                                        }
                                    }else{
                                        if (req.body.addWidget) {
                                            out.status = "Failure";
                                                out.message = "Can not create this widget because there is no data available for this widget.";
                                            return out;
                                        }else if(req.body.updateWidget){
                                            out.status = "Failure",
                                           out.message = "Can not update this widget because there is no data available for this widget.";
                                           return out;
                                           break;
                                       }
                                    }
                                    
                            }
                        
                    }
                    cardStructure.push(outCard);
                }
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to add populate new widget due to: "+JSON.stringify(error.message);
        }
        out.data = cardStructure;
        return out;
    },
    //TASK PROGRESS OF PROJECT FOR PROJECT MANAGER
    getTaskProgress: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getTaskProgress service initiated", "PMService", "getTaskProgress", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getTaskProgress);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch issue count due to missing parameters: " + JSON.stringify(missingParams), className, "getTaskProgress", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "getTaskProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let query
                let param = []
                let taskProgressArray = []
                //if (String(body.isAllProjects).toLowerCase() == "true") {
                    if (projectsLength==0){
                    if(String(body.role).toLowerCase() == "employee"){
                        query = mysqlQueries.taskProgressAllProjectForEmp
                        param = [body.loggedUserId, body.tenantId]
                    }else if(String(body.role).toLowerCase() == "project_manager"){
                        query = mysqlQueries.taskProgressAllProject
                        param = [body.loggedUserId, body.tenantId]
                    }
                    
                } else {
                    if(String(body.role).toLowerCase() == "employee"){
                        query = mysqlQueries.taskProgressForEmp
                        param = [body.loggedUserId, body.tenantId,Projects]
                    }else if(String(body.role).toLowerCase() == "project_manager"){
                        query = mysqlQueries.taskProgress
                        param = [body.loggedUserId, body.tenantId,Projects]
                    }
                    
                }

                result = await dbOperations.executeQuery(query, param, loggedUser, "getTaskProgress", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", "Task progress fetched successfully", "PMService", "getTaskProgress", loggedUser, tenant, moduleName);
                        //let res = result.reduce((hash, obj) => ({ ...hash, [obj["ID"]]: (hash[obj["ID"]] || []).concat(obj) }), {})
                        let taskArray=[],dateArray=[]
                        for (let x of result) {
                            let dispValue = String(x.TASK_NAME).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            if (x.TASK_STATUS_TYPE_CODE == 'NS') {
                                taskArray.push(dispValue)
                                dateArray.push(0)
                            } else {
                                if (x.ACTUAL_EFFORT > x.ESTIMATED_EFFORT) {
                                    taskArray.push(dispValue)
                                    dateArray.push(100)
                                } else if (x.ACTUAL_EFFORT == 0) {
                                    taskArray.push(dispValue)
                                    dateArray.push(0)
                                }
                                else {
                                    let percentage = ((x.ACTUAL_EFFORT / x.ESTIMATED_EFFORT) * 100).toFixed(2)
                                    taskArray.push(dispValue)
                                    dateArray.push(percentage)
                                }

                            }

                        }
                        let obj = {  'series': dateArray, 'label': taskArray }
                        taskProgressArray.push(obj)
                        result = await responseHandler.sendResponse("Success", "Task progress fetched ", 200, taskProgressArray, true, "getTaskProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("info", "No isues avaliable", "PMService", "getTaskProgress", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No task available ", 400, null, false, "getTaskProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch task progress", "PMService", "getTaskProgress", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch task progress ", 400, null, false, "getTaskProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getTaskProgress", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getTaskProgress Service completed.", "PMService", "getTaskProgress", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getTaskProgress", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getTaskProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //  PROJECT PROGRESS 
    getProjectProgress: async function (body,projectsLength, loggedUser, tenant,Projects) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getProjectProgress service initiated", "PMService", "getProjectProgress", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getProjectProgress);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch project progress due to missing parameters: " + JSON.stringify(missingParams), className, "getProjectProgress", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "getProjectProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                let query
                let param = []
                let projectProgressArray = []
                if(String(body.role).toLowerCase() == "employee"){
                    if(projectsLength===0){
                        query = mysqlQueries.projectProgressForEmp
                    param = [body.loggedUserId,body.tenantId]
                    }
                    else{
                        query = mysqlQueries.specificProjectProgressForEmp
                    param = [body.loggedUserId,body.tenantId,Projects]
                        
                    }
                    
                }else if(String(body.role).toLowerCase() == "project_manager"){
                    if(projectsLength===0){
                        query = mysqlQueries.projectProgressForPM
                        param = [body.loggedUserId,body.tenantId]
                    }
                    else{
                        query = mysqlQueries.specificProjectProgressForPM
                    param = [body.loggedUserId,body.tenantId,Projects]
                    }
                    
                }
                

                result = await dbOperations.executeQuery(query, param, loggedUser, "getProjectProgress", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("info", "Project progress fetched successfully", "PMService", "getProjectProgress", loggedUser, tenant, moduleName);
                        let projectArray = [], dateArray = []
                        for (let item of result) {
                            let dispValue = String(item.PROJECT_NAME).toUpperCase();
                            let firstChar = dispValue[0];
                            dispValue = String(dispValue).slice(1,dispValue.length).toLowerCase();
                            dispValue = firstChar+dispValue;
                            if (item.PROJECT_STATUS_TYPE_CODE == 'NS') {
                                projectArray.push(dispValue)
                                dateArray.push(0)
                            } else {
                                //convert difference of  actual start date and estimated completion date 
                                // convert the days to hour
                                let actualDiff = moment(item.ESTIMATED_COMPLETION_DATE).diff(moment(item.ACTUAL_START_DATE), 'days');
                                let estimatedEffort = Math.ceil(actualDiff ? actualDiff * 8 : 8)
                                if (item.ACTUAL_EFFORT > estimatedEffort) {
                                    projectArray.push(dispValue)
                                    dateArray.push(100)
                                } else if (item.ACTUAL_EFFORT == 0) {
                                    projectArray.push(dispValue)
                                    dateArray.push(0)
                                } else {
                                    let percentage = ((item.ACTUAL_EFFORT / estimatedEffort) * 100).toFixed(2)
                                    projectArray.push(dispValue)
                                    dateArray.push(percentage)
                                }

                            }

                        }
                        let obj = { 'series': dateArray, 'label': projectArray }
                        projectProgressArray.push(obj)
                        result = await responseHandler.sendResponse("Success", "Project progress fetched ", 200, projectProgressArray, true, "getProjectProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    } else {
                        appLogger.logMessage("info", "No isues avaliable", "PMService", "getProjectProgress", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No project available ", 400, null, false, "getProjectProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch project progress", "PMService", "getProjectProgress", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch project progress ", 400, null, false, "getProjectProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getProjectProgress", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getProjectProgress Service completed.", "PMService", "getProjectProgress", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getProjectProgress", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getProjectProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    editDashboard: async function (req, loggedUser, tenant) {
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        appLogger.logMessage("info", "editDashboard function called", className, "editDashboard", req.body.loggedUser, req.body.tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully updated and refreshed the dashboard data",
            data: {},
            statusCode: 200
        }
        try {
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.editDashboard);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }

            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to update dashboard due to missing parameters: " + JSON.stringify(missingParams), className, "editDashboard", loggedUser, tenant, moduleName);
                out = {
                    status: "Failure",
                    message: "Missing parameters: " + JSON.stringify(missingParams),
                    statusCode: 400
                }
            } else {
                let dashboardId = req.body.dashboardId;
                let cardId = req.body.cardId;
                let fieldName = req.body.fieldName;
                let category = req.body.category;
                let projectIds;

                // if (req.body.projectId) {
                //     if (typeof req.body.projectId === 'string') {
                //         // Split the string into an array using comma as the delimiter
                //         projectIds = req.body.projectId.split(',');
                //     } else if (Array.isArray(req.body.projectId)) {
                //         projectIds = req.body.projectId;
                //     } else {
                //         // Wrap the single value in an array
                //         projectIds = [req.body.projectId];
                //     }
                // }
                if (req.body.projectId) {
                    if (typeof req.body.projectId === 'string') {
                        // Split the string into an array using comma as the delimiter
                        projectIds = req.body.projectId.split(',');
                    } else if (Array.isArray(req.body.projectId)) {
                        projectIds = req.body.projectId;
                    } else {
                        // Wrap the single value in an array
                        projectIds = [req.body.projectId];
                    }
                }
                let condition = { '_id': ObjectID(dashboardId) }
                let result = await mongoOperations.executeMongoGet(loggedUser, "dashboard", condition, "editDashboard", tenant, appLogger, meteringLogger, moduleName);
                if (result != null && result != undefined) {
                    for (let chart of result[0].dashboard.cardStructure) {
                        if (Array.isArray(chart.data)) {
                            for (let widget of chart.data) {
                                if (widget.cardId == cardId) {
                                    let isUpdated = false;
                                    if (result[0].configuration.customeWidgets) {
                                        for (let customWidget of result[0].configuration.customeWidgets) {
                                            if (customWidget.cardId == cardId) {
                                                for (let key of Object.keys(customWidget)) {
                                                    if (String(key).toLowerCase() != "cardid" && String(key).toLowerCase() != "name") {
                                                        if (typeof (customWidget[key]) == "object") {
                                                            isUpdated = true;
                                                            customWidget[key].defaultCategory = category;
                                                            customWidget[key].fieldName = fieldName;
                                                            if (projectIds && Array.isArray(projectIds)) {
                                                                {
                                                                    if (projectIds.length > 0) {
                                                                        customWidget[key].overallProjects = true;
                                                                        customWidget[key].projectIds = projectIds;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }


                                            }
                                        }
                                    }
                                    if (!isUpdated) {
                                        result[0].configuration[chart.cardType][widget.type].defaultCategory = category;
                                        result[0].configuration[chart.cardType][widget.type].fieldName = fieldName;
                                        if (projectIds && Array.isArray(projectIds)) {
                                            {
                                                if (projectIds.length > 0) {
                                                    result[0].configuration[chart.cardType][widget.type].overallProjects = true;
                                                    result[0].configuration[chart.cardType][widget.type].projectIds = projectIds;
                                                }
                                            }
                                        }
                                        else if(req.body.isAllProjects){
                                            result[0].configuration[chart.cardType][widget.type].overallProjects = true;
                                            result[0].configuration[chart.cardType][widget.type].projectIds = [];
                                        }
                                    }
                                    break;
                                }
                            }
                        } else {
                            result[0].configuration[chart.cardType].defaultCategory = category;
                            // break;
                        }
                    }
                    req.body["configuration"] = result[0].configuration;
                    req.body["dashboardId"] = dashboardId;
                    req.body["dashboardName"] = result[0].dashboard.dashboardName;
                    req.body["dashboardDescription"] = result[0].dashboard.dashboardDescription;
                    req.body["updateWidget"] = true;
                    //new
                    if (req.body.configuration.customeWidgets) {
                        const customeWidgets = req.body.configuration.customeWidgets;
                    
                        for (let i = 0; i< customeWidgets.length; i++) {
                            if (customeWidgets[i].cardId.toString()=== cardId.toString() && req.body.isAllProjects==='true') {
                                if (customeWidgets[i].barChart && req.body.isAllProjects) {
                                    req.body.configuration.customeWidgets[i].barChart.projectIds = [];
                                }
                                else if (customeWidgets[i].linrChart && req.body.isAllProjects) {
                                    req.body.configuration.customeWidgets[i].lineChart.projectIds = [];
                                }
                                else if (customeWidgets[i].pieChart && req.body.isAllProjects) {
                                    req.body.configuration.customeWidgets[i].pieChart.projectIds = [];
                                }
                                break;
                            }
                        }
                    }
                    //end
                    
                    out = await this.createDashboard(req, loggedUser, tenant);
                } else {
                    out.status = "Failure";
                    out.message = "Failed to get the dashboard to update";
                    out.statusCode = 500;
                    appLogger.logMessage("error", out.message, className, "editDashboard", loggedUser, tenant, moduleName);
                }
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to update the dashboard due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", out.data, className, "editDashboard", req.body.loggedUser, req.body.tenant, moduleName);
        }
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, "PMService", "editDashboard", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },
    createWidget: async function (req, loggedUser, tenant) {
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        appLogger.logMessage("info", "createWidget function called", className, "createWidget", req.body.loggedUser, req.body.tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully added the widget",
            data: {},
            statusCode: 200
        }
        try {
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.createWidget);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }

            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to update dashboard due to missing parameters: " + JSON.stringify(missingParams), className, "createWidget", loggedUser, tenant, moduleName);
                out = {
                    status: "Failure",
                    message: "Missing parameters: " + JSON.stringify(missingParams),
                    statusCode: 400
                }
            } else {
                let dashboardId = req.body.dashboardId;
                let fieldName = req.body.fieldName;
                let category = req.body.category;
                let multiGraphName = req.body.multiGraphName;
                let isAllProjects = req.body.isAllProjects;
                let widgetName = req.body.widgetName;
                let projectIds = [];
                if(req.body.projectIds){
                    projectIds = JSON.parse(req.body.projectIds); 
                }
                let condition = { '_id': ObjectID(dashboardId) }
                let result = await mongoOperations.executeMongoGet(loggedUser, "dashboard", condition, "createWidget", tenant, appLogger, meteringLogger, moduleName);
                if (result != null && result != undefined) {
                    let conf = {
                        "defaultCategory":category,
                        "overallProjects":isAllProjects,
                        "projectIds":projectIds,
                        "fieldName":fieldName
                    }
                    let payload = {};
                    payload["name"] = widgetName;
                    payload[multiGraphName] = conf;
                    if(result[0].configuration["customeWidgets"]){
                        result[0].configuration["customeWidgets"].push(payload);
                    }else{
                        result[0].configuration["customeWidgets"] = [
                            payload
                        ]
                    }
                    req.body["configuration"] = result[0].configuration;
                    req.body["dashboardId"] = dashboardId;
                    req.body["dashboardName"] = result[0].dashboard["dashboardName"];
                    req.body["dashboardDescription"] = result[0].dashboard["dashboardDescription"];
                    req.body["addWidget"] = true;
                    out = await this.createDashboard(req, loggedUser, tenant);
                } else {
                    out.status = "Failure";
                    out.message = "Failed to get the widget to update";
                    out.statusCode = 500;
                    appLogger.logMessage("error", out.message, className, "createWidget", loggedUser, tenant, moduleName);
                }
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to add widget due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", out.data, className, "createWidget", req.body.loggedUser, req.body.tenant, moduleName);
        }
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, "PMService", "createWidget", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },
    //PROJECT COUNT FOR ITS STATUS
    getProjectCount: async function (req, body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getProjectCount service initiated", "PMService", "getProjectCount", loggedUser, tenant, moduleName);
        let result;
        try {
            let requestParams = Object.keys(body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.projectCountByStatus);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch project count due to missing parameters: " + JSON.stringify(missingParams), className, "issueCountByStatus", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "issueCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            } else {
                // if (body.role == 'PROJECT_MANAGER') {
                //     result = await this.viewProjectsByManager(req, loggedUser, tenant)
                // } else if (body.role == 'EMPLOYEE') {
                //     result = await this.viewProjectsByEmployee(req, loggedUser, tenant)
                // }

                result = await this.viewProjectsByManager(req, loggedUser, tenant)
                if (result != undefined && result != null && result.statusCode == 200) {
                    if (result.data.length > 0) {
                        let countObj = { IP: 0, NS: 0, OPEN: 0, COMPLETE: 0, HOLD: 0, CLOSED: 0, TOTAL: 0 }
                        for (let x of result.data) {
                            if (x.PROJECT_STATUS_TYPE_CODE == 'IP') {
                                countObj.IP = countObj.IP + 1
                            } else if (x.PROJECT_STATUS_TYPE_CODE == 'NS') {
                                countObj.NS = countObj.NS + 1
                            } else if (x.PROJECT_STATUS_TYPE_CODE == 'OPEN') {
                                countObj.OPEN = countObj.OPEN + 1
                            } else if (x.PROJECT_STATUS_TYPE_CODE == 'COM') {
                                countObj.COMPLETE = countObj.COMPLETE + 1
                            } else if (x.PROJECT_STATUS_TYPE_CODE == 'HOLD') {
                                countObj.HOLD = countObj.HOLD + 1
                            } else if (x.PROJECT_STATUS_TYPE_CODE == 'CLOSED') {
                                countObj.CLOSED = countObj.CLOSED + 1
                            }
                        }
                        countObj.TOTAL = result.data.length
                        appLogger.logMessage("info", "Project count fetched successfully", "PMService", "projectCountByStatus", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Project count fetched successfully", 200, countObj, true, "projectCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    } else {
                        appLogger.logMessage("info", "No projects avaliable", "PMService", "projectCountByStatus", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "No projects available ", 400, null, false, "projectCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    }
                } else {
                    appLogger.logMessage("info", "Failed to fetch project count by status", "PMService", "projectCountByStatus", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch project count ", 400, null, false, "projectCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }

            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "projectCountByStatus", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "projectCountByStatus Service completed.", "PMService", "projectCountByStatus", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "projectCountByStatus", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "projectCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },

    //GET DASHBOARD FROM MONGODB
    getDashboard: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "getTemplate function called with the payload: " + JSON.stringify(req.body), className, "getDashboard", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Warning",
            message: "Failed to get dashboard",
            statusCode: '200',
            data: []
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getDashboard);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Missing parameters: " + JSON.stringify(missingParams), className, "getDashboard", loggedUser, tenant, moduleName);
                    out.status = "warning"
                    out.message = "Missing parameters: " + JSON.stringify(missingParams)
                    out.statusCode = 404
                } else {
                    const ObjectID = require('mongodb').ObjectId;
                    let condition = { '_id': ObjectID(body.id) }
                    let result = await mongoOperations.executeMongoGet(loggedUser, "dashboard", condition, "getDashboard", tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined) {
                        if (result.length) {
                            if (result.length > 0) {
                                body["dashboardName"] = result[0].dashboard.dashboardName;
                                body["dashboardDescription"] = result[0].dashboard.dashboardDescription
                                body['configuration'] = result[0].configuration;
                                body["isAllProjects"] = true;
                                body["isGet"] = true;
                                out.status = "Success";
                                out.message = "Dashboard fetched successfully";
                                out.statusCode = 200;
                                let dashboardResult = await this.createDashboard(req, body.loggedUser, body.tenant)
                                out.data = [dashboardResult]
                                appLogger.logMessage("info", "Template fetched successdully", className, "getTemplate", loggedUser, tenant, moduleName);
                            } else {
                                out.status = "Warning";
                                out.message = "No dashboard available";
                                out.statusCode = 404;
                                appLogger.logMessage("debug", "Failed to get dashboard. Result received after executing the query: " + JSON.stringify(result), className, "getDashboard", loggedUser, tenant, moduleName);
                            }
                        } else {
                            appLogger.logMessage("debug", "Failed to get dashboard. Result received after executing the query: " + JSON.stringify(result), className, "getDashboard", loggedUser, tenant, moduleName);
                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to get dashboard", className, "getDashboard", loggedUser, tenant, moduleName);
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to  get dashboard due to invalid request body", className, "getDashboard", loggedUser, tenant, moduleName);
                out.status = "Warning"
                out.message = "Failed to get dashboard due to invalid request body"
                out.statusCode = 404
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "getDashboard", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to get dashboard due to" + error.message, "PMSSupport", "getDashboard", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failure"
            out.message = "Internal server error " + error.message
            out.statusCode = 500
        }
        appLogger.logMessage("info", "getDashboard completed", className, "getDashboard", loggedUser, tenant, moduleName);
        return out;
    },
    deleteDashboard: async function (req, loggedUser, tenant) {
        return new Promise(async function (resolve, reject) {
            startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            appLogger.logMessage("info", "deleteDashboard function called", className, "deleteDashboard", loggedUser, tenant, moduleName);
            let out = {
                status: "Success",
                message: "Deleted dashboard successfully",
                data: "",
                statusCode: 200
            }
            try {
                let requestParams = Object.keys(req.body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.deleteDashboard);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to fetch project count due to missing parameters: " + JSON.stringify(missingParams), className, "issueCountByStatus", loggedUser, tenant, moduleName);
                    out = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "issueCountByStatus", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    //code to delete dashboard entirely
                    let dashboardId = req.body.dashboardId;
                    let condition = { '_id': ObjectID(dashboardId) }
                    let result = await mongoOperations.deleteFromMongo(req.body.loggedUser, "dashboard", condition, "deleteDashboard", tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined) {
                        if (result.deletedCount == 1) {
                            appLogger.logMessage("debug", "Dashboard deleted successfully", className, "deleteDashboard", loggedUser, tenant, moduleName);
                        } else {
                            out.status = "Success",
                                out.message = "No records deleted please check whether it is already deleted"
                        }
                    } else {
                        out.status = "Failure";
                        out.message = "Failed to delete dashboard";
                        out.statusCode = 500
                    }
                }
            } catch (error) {
                out.status = "Failure";
                out.message = "Internal server error";
                out.data = "Failed to delete dashboard due to: " + JSON.stringify(error.message);
                out.statusCode = 500
                appLogger.logMessage("error", out.data, className, "deleteDashboard", loggedUser, tenant, moduleName);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "deleteDashboard", startDateTime, endDateTime, diffInMS, moduleName);
            resolve(out);
        })
    },

    //GET DASHBOARD OF A USER FROM MONGODB
    getUserDashboard: async function (req, loggedUser, tenant) {
        appLogger.logMessage("debug", "getUserDashboard function called with the payload: " + JSON.stringify(req.body), className, "getUserDashboard", loggedUser, tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Warning",
            message: "Failed to get dashboard",
            statusCode: '200',
            data: []
        }
        try {
            let body = req.body;
            if (body) {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getUserDashboard);
                for (let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Missing parameters: " + JSON.stringify(missingParams), className, "getUserDashboard", loggedUser, tenant, moduleName);
                    out.status = "warning"
                    out.message = "Missing parameters: " + JSON.stringify(missingParams)
                    out.statusCode = 404
                } else {

                    let param1 = { $unwind: "$dashboard" };
                    let param2 = { $match: { "dashboard.userId": { $eq: body.loggedUserId } } };
                    //let param3 = { $project: { "dashboard.dashboardName": 1 } }
                    let params = [param1, param2];
                    let result = await mongoOperations.executeMongoGetSpecificData(loggedUser, "dashboard", params, "getUserDashboard", tenant, appLogger, meteringLogger, moduleName);
                    if (result != null && result != undefined) {
                        if (result.length) {
                            if (result.length > 0) {
                                let respData = [];
                                for(let item of result){
                                    respData.push({
                                        id:item._id,
                                        dashboardName:item.dashboard.dashboardName
                                    })
                                }
                                body['configuration'] = result[0].configuration
                                out.status = "Success";
                                out.message = "Dashboard fetched successfully";
                                out.statusCode = 200;
                                out.data = respData;
                                appLogger.logMessage("info", "Dashboard fetched successdully", className, "getUserDashboard", loggedUser, tenant, moduleName);
                            } else {
                                out.status = "Success";
                                out.message = "No dashboard available";
                                out.statusCode = 200;
                                appLogger.logMessage("debug", "Failed to get dashboard. Result received after executing the query: " + JSON.stringify(result), className, "getUserDashboard", loggedUser, tenant, moduleName);
                            }
                        } else {
                            appLogger.logMessage("debug", "Failed to get dashboard. Result received after executing the query: " + JSON.stringify(result), className, "getUserDashboard", loggedUser, tenant, moduleName);
                        }
                    } else {
                        appLogger.logMessage("debug", "Failed to get dashboard", className, "getUserDashboard", loggedUser, tenant, moduleName);
                    }
                }
            } else {
                appLogger.logMessage("info", "Failed to  get dashboard due to invalid request body", className, "getUserDashboard", loggedUser, tenant, moduleName);
                out.status = "Warning"
                out.message = "Failed to get dashboard due to invalid request body"
                out.statusCode = 404
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, className, "getUserDashboard", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Failed to get dashboard due to" + error.message, "PMSSupport", "getUserDashboard", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failure"
            out.message = "Internal server error " + error.message
            out.statusCode = 500
        }
        appLogger.logMessage("info", "getUserDashboard completed", className, "getUserDashboard", loggedUser, tenant, moduleName);
        return out;
    },
    fetchProjectsForDashboard: async function (req, loggedUser, tenant) {
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        appLogger.logMessage("info", "fetchProjectsForDashboard function called", className, "fetchProjectsForDashboard", req.body.loggedUser, req.body.tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully fetched projects for dashboard",
            data: [],
            statusCode: 200
        }
        try {
            let body=req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.fetchProjectsForDashboard);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }

            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to  fetch projects for dashboard due to missing parameters: " + JSON.stringify(missingParams), className, "fetchProjectsForDashboard", loggedUser, tenant, moduleName);
                out = {
                    status: "Failure",
                    message: "Missing parameters: " + JSON.stringify(missingParams),
                    statusCode: 400
                }
            } else {
                let query,param=[]
                
                if(String(body.role).toLowerCase() == "employee"){
                    query = mysqlQueries.fetchDashboardProjectsForEmp
                    param = [body.loggedUserId,body.tenantId]
                }else if(String(body.role).toLowerCase() == "project_manager"){
                    query = mysqlQueries.fetchDashboardProjectsForPM
                    param = [body.loggedUserId,body.tenantId]
                }
                
                result = await dbOperations.executeQuery(query, param, loggedUser, "fetchProjectsForDashboard", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error') {
                    if (result.length > 0) {
                        appLogger.logMessage("Success", "Projects for dashboard fetched sucessfully " , className, "fetchProjectsForDashboard", loggedUser, tenant, moduleName);
                        out = {
                            status: "Success",
                            message: "Projects for dashboard fetched sucessfully",
                            statusCode: 200,
                            data:result
                        }

                    }else{
                        out = {
                            status: "Warning",
                            message: "No projects available",
                            statusCode: 404
                        }
                    }
                }else{
                    out = {
                        status: "Warning",
                        message: "Failed to fetch projects",
                        statusCode: 404
                    }
                }
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to fetch projects  due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", out.data, className, "fetchProjectsForDashboard", req.body.loggedUser, req.body.tenant, moduleName);
        }
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, "PMService", "fetchProjectsForDashboard", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },
    // GET ALL EXPENSE TYPES FOR THE TENANT (COMBINATION OF PREDEFINED & CUSTOM TYPES (ALL TYPES WITH TENANT_ID 0 IS CONSIDERED AS PREDEFINED TYPES THAT ARE COMMON FOR ALL TENANTS) 
    // CUSTOM TYPES ARE MAPPED WITH EACH TENANT)
    getAllExpType: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getAllExpType service initiated", "PMService", "getAllExpType", loggedUser, tenant, moduleName);
        let result;
        try {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.getAllExpType);
                for(let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to fetch expense types because of missing parameters : " + JSON.stringify(missingParams), className, "getAllExpType", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "getAllExpType", tenant, loggedUser, moduleName,appLogger,meteringLogger);

                } else {
                    let epxenseTypeArray=[];
                    let query=mysqlQueries.getAllExpTypes;
                    let param=[body.tenantId]
                    result = await dbOperations.executeQuery(query,param, loggedUser, "getAllExpType", false, null, tenant, appLogger, meteringLogger, moduleName)
                    if (result != undefined && result != null && result != 'Error'){
                        if(result.length>0){
                               for(let item in result){
                                epxenseTypeArray.push({
                                        ID : result[item].ID,
                                        NAME:result[item].NAME
                                    });
                                }
                            appLogger.logMessage("info", "Expense types fetched successfully.", "PMService", "getAllExpType", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Success", "Count  of Expense types  fetched." , 200, epxenseTypeArray, true, "getAllExpType", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }else{
                            appLogger.logMessage("info", "No Expense types  avaliable", "PMService", "getAllExpType", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "No expense types available.",400, null, false, "getAllExpType", tenant, loggedUser, moduleName,appLogger,meteringLogger);

                        }
                    }else{
                        appLogger.logMessage("info", "Failed to fetch  Expense types ", "PMService", "getAllExpType", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Failed to fetch Expense types. ",400, null, false, "getAllExpType", tenant, loggedUser, moduleName,appLogger,meteringLogger);
                    }
                }
            
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getAllExpType", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getAllExpType Service completed.", "PMService", "getAllExpType", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getAllExpType", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getAllExpType", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    // ADD NEW EXPENSE TYPE FOR A TENANT
    addNewExpType: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "addNewExpType service initiated", "PMService", "addNewExpType", loggedUser, tenant, moduleName);
        let result;
        try {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.addNewExpType);
                for(let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to add new expense type because of missing parameters : " + JSON.stringify(missingParams), className, "addNewExpType", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "addNewExpType", tenant, loggedUser, moduleName,appLogger,meteringLogger);

                } else {
                    let query=mysqlQueries.addNewExpeType;
                    let param=[body.tenantId,body.expTypeName,body.expTypeDesc,body.loggedUserId,body.loggedUserId];
                    result = await dbOperations.executeQuery(query,param, loggedUser, "addNewExpType", false, null, tenant, appLogger, meteringLogger, moduleName)
                    if (result != undefined && result != null && result != 'Error'){
                        if(result.affectedRows > 0){
                            let expID = result.insertId;
                            let resp = [];
                            resp.push({
                                id:expID,
                                type: body.expTypeName
                            })
                            appLogger.logMessage("info", "Add new Expense types done successfully.", "PMService", "addNewExpType", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Success", "Expense added successfully." , 200, resp, true, "addNewExpType", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }else{
                            appLogger.logMessage("info", "Something went wrong while adding new expense type.", "PMService", "addNewExpType", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "Something went wrong while adding new expense type.",400, null, false, "addNewExpType", tenant, loggedUser, moduleName,appLogger,meteringLogger);

                        }
                    }else{
                        appLogger.logMessage("info", "Failed to add new Expense types ", "PMService", "addNewExpType", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Failed to add new Expense types. ",400, null, false, "addNewExpType", tenant, loggedUser, moduleName,appLogger,meteringLogger);
                    }
                }
            
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addNewExpType", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "addNewExpType Service completed.", "PMService", "addNewExpType", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addNewExpType", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addNewExpType", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
     // ADD NEW EXPENSE FOR A TASK UNDER PROJECT/GROUP/RECURRING JOBS FOR A TENANT
     addExpenditure: async function (body, loggedUser, tenant) {
        let startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "addExpenditure service initiated", "PMService", "addExpenditure", loggedUser, tenant, moduleName);
        let result;
        try {
                let requestParams = Object.keys(body);
                let missingParams = [];
                let signatureKeys = Object.keys(apiSignatures.addExpenditure);
                for(let key of signatureKeys) {
                    if (!requestParams.includes(key)) {
                        missingParams.push(key);
                    }
                }
                if (missingParams.length > 0) {
                    appLogger.logMessage("debug", "Failed to add new expense because of missing parameters : " + JSON.stringify(missingParams), className, "addExpenditure", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Missing parameters: " + JSON.stringify(missingParams), 404, null, false, "addExpenditure", tenant, loggedUser, moduleName,appLogger,meteringLogger);

                } else {
                    if(String(body.isTaskLinked).toLowerCase()=='n'){
                        body['groupName']='Miscellaneous'
                        body['groupDescription']="Miscellaneous "
                        body['groupStatus']="IP"
                        body['projectId']=body.projectID
                        let groupResult = await this.createGroup(body,body.loggedUser, body.tenant)
                        if (groupResult.type.toUpperCase() == 'SUCCESS') {
                            body['groupId'] = groupResult.data[0].ID
                            let taskCreationResult=await supportHandler.createMiscellaneousTask(body,body.loggedUser,body.tenant)
                            if(taskCreationResult.type.toLowerCase()=='success'){
                                body=taskCreationResult.data
                            }
                        }
                    }
                    let query=mysqlQueries.addExpenditure;
                    let param=[body.tenantId,body.projectID,Number(body.taskID),body.expTypeID,body.expAmnt,body.expenseDate,body.description,body.loggedUserId,body.loggedUserId];
                    result = await dbOperations.executeQuery(query,param, loggedUser, "addExpenditure", false, null, tenant, appLogger, meteringLogger, moduleName)
                    if (result != undefined && result != null && result != 'Error'){
                        if(result.affectedRows > 0){
                            let expID = result.insertId;
                            let resp = [];
                            resp.push({
                                id:expID,
                                type: body.taskID
                            })
                            appLogger.logMessage("info", "Add new Expense done successfully.", "PMService", "addExpenditure", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Success", "Expense added successfully." , 200, resp, true, "addExpenditure", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }else{
                            appLogger.logMessage("info", "Something went wrong while adding new expense.", "PMService", "addExpenditure", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "Something went wrong while adding new expense .",400, null, false, "addExpenditure", tenant, loggedUser, moduleName,appLogger,meteringLogger);

                        }
                    }else{
                        appLogger.logMessage("info", "Failed to add new Expense.", "PMService", "addExpenditure", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Warning", "Failed to add new Expense . ",400, null, false, "addExpenditure", tenant, loggedUser, moduleName,appLogger,meteringLogger);
                    }
                }
            
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addExpenditure", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "addExpenditure Service completed.", "PMService", "addExpenditure", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "addExpenditure", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "addExpenditure", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    deleteWidget: async function (req, loggedUser, tenant) {
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        appLogger.logMessage("info", "deleteWidget function called", className, "deleteWidget", req.body.loggedUser, req.body.tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully deleted and refreshed the dashboard data",
            data: {},
            statusCode: 200
        }
        try {
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.deleteWidget);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }

            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to delete widget due to missing parameters: " + JSON.stringify(missingParams), className, "deleteWidget", loggedUser, tenant, moduleName);
                out = {
                    status: "Failure",
                    message: "Missing parameters: " + JSON.stringify(missingParams),
                    statusCode: 400
                }
            } else {
                let dashboardId = req.body.dashboardId;
                let cardId = req.body.cardId;
                let condition = { '_id': ObjectID(dashboardId) }
                let result = await mongoOperations.executeMongoGet(loggedUser, "dashboard", condition, "deleteWidget", tenant, appLogger, meteringLogger, moduleName);
                if (result != null && result != undefined) {
                    for (let chart of result[0].dashboard.cardStructure) {
                        if (chart.cardId) {
                            if (chart.cardId == cardId) {
                                delete result[0].configuration[chart.cardType]
                                break;
                            }
                        }
                        if (Array.isArray(chart.data)) {
                            for (let widget of chart.data) {
                                if (widget.cardId == cardId) {
                                    let isDeleted = false;
                                    if(result[0].configuration.customeWidgets){
                                        for(let customWidget of result[0].configuration.customeWidgets){
                                            if(customWidget.cardId == cardId){
                                                result[0].configuration.customeWidgets.splice(result[0].configuration.customeWidgets.indexOf(customWidget), 1);
                                                isDeleted = true;
                                            }
                                        }
                                    }
                                    if(!isDeleted){
                                        if (result[0].configuration[chart.cardType][widget.type]) {
                                            delete result[0].configuration[chart.cardType][widget.type]
                                            break;
                                        }
                                    }
                                }
                            }
                        } else {
                            //table data
                            if (chart.data.cardId == cardId) {
                                delete result[0].configuration[chart.cardType]
                                break;
                            }
                        }
                    }
                    req.body["configuration"] = result[0].configuration;
                    req.body["dashboardId"] = dashboardId;
                    req.body["dashboardName"] = result[0].dashboard.dashboardName;
                    req.body["dashboardDescription"] = result[0].dashboard.dashboardDescription;
                    out = await this.createDashboard(req, loggedUser, tenant);
                } else {
                    out.status = "Failure";
                    out.message = "Failed to get the widget to delete";
                    out.statusCode = 500;
                    appLogger.logMessage("error", out.message, className, "deleteWidget", loggedUser, tenant, moduleName);
                }
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to delete the widget due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", out.data, className, "deleteWidget", req.body.loggedUser, req.body.tenant, moduleName);
        }
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, "PMService", "deleteWidget", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },

    //CONVERT SUB TASK TO MAIN TASK
    subTaskToMainTask: async function (req, loggedUser, tenant) {
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        appLogger.logMessage("info", "subTaskToMainTask function called", className, "subTaskToMainTask", req.body.loggedUser, req.body.tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully converted sub task to main task",
            data: {},
            statusCode: 200
        }
        try {
            let body=req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.subTaskToMainTask);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }

            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to convert sub task to main taskdue to missing parameters: " + JSON.stringify(missingParams), className, "subTaskToMainTask", loggedUser, tenant, moduleName);
                out = {
                    status: "Failure",
                    message: "Missing parameters: " + JSON.stringify(missingParams),
                    statusCode: 400
                }
            } else {
                let query,param=[]
                query=mysqlQueries.subTaskToMainTask
                param=[null,body.loggedUserId,body.taskId,body.tenantId]
                result = await dbOperations.executeQuery(query,param, loggedUser, "subTaskToMainTask", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error'){
                    if(result.affectedRows>0){
                        appLogger.logMessage("info", "Sub task converted to main task ", className, "subTaskToMainTask", loggedUser, tenant, moduleName);
                        //update the main task effort
                        let res=await supportHandler.updateMainTaskEffort(body,body.loggedUser,body.tenant)
                        if(res.type=='Failure'){
                            appLogger.logMessage("info", "Failed to update effort of main task", className, "subTaskToMainTask", loggedUser, tenant, moduleName);
                                 out.status = "Warning";
                                 out.message = "Failed to update effort of the main task."
                        }else{
                            let updateTaskObj = {
                                'actualCompletionDate':  moment(body.actualCompletionDate).format("YYYY-MM-DD"),
                                'estimatedStartDate':  moment(body.estimatedStartDate).format("YYYY-MM-DD"),
                                'estimatedCompletionDate':  moment(body.estimatedCompletionDate).format("YYYY-MM-DD"),
                                'taskStatusTypeCode': body.taskStatusTypeCode, 'mainTaskStatus': body.mainTaskStatus,
                                'groupId': body.groupId, 'mainTaskId': body.mainTaskId, 'projectId': body.projectId,
                                'type': "MAIN", 'loggedUserId': body.loggedUserId, 'tenantId': body.tenantId
                            }
                            let res1=await supportHandler.taskDateChange(updateTaskObj, body.loggedUser, body.tenant)
                            let res2=await supportHandler.taskStatusChange(updateTaskObj, body.loggedUser, body.tenant)
                            let res3=await BudgetSupport.editClassBudget(body.taskId, 'TASK', body.tenantId, null, null, body.minAmount, body.maxAmount, body.loggedUserId, body.loggedUser, body.tenant, null, body.groupId, body.projectId)
                            await BudgetSupport.editClassBudget(body.taskId, 'SUBTASK', body.tenantId, null, null, 0, 0, body.loggedUserId, body.loggedUser, body.tenant, body.mainTaskId, body.groupId, body.projectId)
                        }
                        if(data.addedToWatchList=='true'){
                            let notifyResult=await supportHandler.watchListNotification(body,'convert_to_subtask',data.loggedUser,data.tenant)
                            appLogger.logMessage("debug", " Result after notify watchers"+JSON.stringify(notifyResult) , className, "assignUserToTask", loggedUser, tenant, moduleName);
                        }
                    }
                }
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to update the dashboard due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", out.data, className, "subTaskToMainTask", req.body.loggedUser, req.body.tenant, moduleName);
        }
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, "PMService", "subTaskToMainTask", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },

    // Convert a task to sub task
    convertMainTaskTosubTask: async function (req, data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "convertTaskToIssue", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.taskId != undefined && data.taskId != null && data.type != null && data.type != undefined) {
                Object.keys(data).forEach(k => data[k] = (data[k] === '' || data[k] === 'null' || data[k] === undefined) ? null : data[k])
                result = await dbOperations.executeQuery(mysqlQueries.fetchSubTask, [data.taskId, data.tenantId], loggedUser, "convertTaskToIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null) {
                    if (result.length > 0) {
                        let ids = []
                        for (id of result) {
                            ids.push(id.ID)
                        }
                        result = await dbOperations.executeQuery(mysqlQueries.updateTaskId, [data.newTaskId, data.loggedUserId, ids, data.tenantId], loggedUser, "convertTaskToIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                        if (result != undefined && result != null) {
                            //If task have subtask
                            if (result.affectedRows > 0) {
                                result = await dbOperations.executeQuery(mysqlQueries.updateStatusofmaintask, ["OBSOLETE", data.loggedUserId, data.taskId, data.tenantId], loggedUser, "convertTaskToIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                                if (result != undefined && result != null) {
                                    if (result.affectedRows > 0) {
                                        // update actual effort
                                        let params = {mainTaskId:data.newTaskId,tenantId:data.tenantId,type:'SUB',loggedUserId:data.loggedUserId}
                                        let updateActualEffort = await supportHandler.updateMainTaskEffort(params,loggedUser,tenant)
                                        if(updateActualEffort.statusCode != 200){
                                            appLogger.logMessage("info", "Failed to update actual effort.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                        }
                                        // update budget
                                        let updateBudgets = await BudgetSupport.editClassBudget(data.taskId, 'TASK', data.tenantId, null, null, 0, 0, data.loggedUserId, loggedUser, tenant, null, data.groupId, data.projectId)
                                        if (updateBudgets.statusCode != 200) {
                                            appLogger.logMessage("info", "Failed to update budget.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                        }
                                        let updateBudget = await BudgetSupport.editClassBudget(data.taskId, 'SUBTASK', data.tenantId, null, null, data.maxAmount, data.minAmount, data.loggedUserId, loggedUser, tenant, data.newTaskId, data.groupId, data.projectId)
                                        if (updateBudget.statusCode != 200) {
                                            appLogger.logMessage("info", "Failed to update budget.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                        }
                                        // update milestone
                                        let updateMilestone = await supportHandler.updateMilestone(data,ids,data.loggedUser, data.tenant)
                                        if(!updateMilestone){
                                            appLogger.logMessage("info", "Failed to update milestone.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                        }                                        
                                        // update taskDate and status change
                                        let updateTaskObj = {
                                            'actualCompletionDate':  moment(data.actualCompletionDate).format("YYYY-MM-DD"),
                                            'estimatedStartDate':  moment(data.estimatedStartDate).format("YYYY-MM-DD"),
                                            'estimatedCompletionDate':  moment(data.estimatedCompletionDate).format("YYYY-MM-DD"),
                                            'taskStatusTypeCode': data.taskStatusTypeCode, 'mainTaskStatus': data.mainTaskStatus,
                                            'groupId': data.groupId, 'mainTaskId': data.newTaskId, 'projectId': data.projectId,
                                            'type': data.type, 'loggedUserId': data.loggedUserId, 'tenantId': data.tenantId
                                        }
                                        await supportHandler.taskDateChange(updateTaskObj, data.loggedUser, data.tenant)
                                        await supportHandler.taskStatusChange(updateTaskObj, data.loggedUser, data.tenant)
                                        result = await responseHandler.sendResponse("Success", "Task is successfully convert to sub task.", 200, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                        appLogger.logMessage("info", "Task is successfully convert to sub task.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                        if(data.addedToWatchList=='true'){
                                            let notifyResult=await supportHandler.watchListNotification(data,'convert_to_maintask',data.loggedUser,data.tenant)
                                            appLogger.logMessage("debug", " Result after notify watchers"+JSON.stringify(notifyResult) , className, "assignUserToTask", loggedUser, tenant, moduleName);
                                        }
                                    } else {
                                        result = await responseHandler.sendResponse("Warning", "Failed to convert main task to sub task.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                        appLogger.logMessage("info", "Failed to convert main task to sub task.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                    }
                                } else {
                                    result = await responseHandler.sendResponse("Warning", "Failed to converted main task to sub task.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                    appLogger.logMessage("info", "Failed to converted main task to sub task.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                }
                            } else {
                                result = await responseHandler.sendResponse("Warning", "Failed to convert sub task under main task.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Failed to convert sub task under main task.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                            }
                        } else {
                            result = await responseHandler.sendResponse("Warning", "Failed to convert sub task under main task.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            appLogger.logMessage("info", "Failed to convert sub task under main task.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                        }
                    } else {
                        //If task have no subtask
                        result = await dbOperations.executeQuery(mysqlQueries.udateMainTaskToSubTask, [data.newTaskId, "SUB", data.loggedUserId, data.taskId, data.tenantId], loggedUser, "convertTaskToIssue", false, null, tenant, appLogger, meteringLogger, moduleName)
                        if (result != undefined && result != null) {
                            if (result.affectedRows > 0) {
                                // update actual effort
                                let params = {mainTaskId:data.newTaskId,tenantId:data.tenantId,type:'SUB',loggedUserId:data.loggedUserId}
                                let updateActualEffort = await supportHandler.updateMainTaskEffort(params,loggedUser,tenant)
                                if(updateActualEffort.statusCode != 200){
                                    appLogger.logMessage("info", "Failed to update actual effort.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                }
                                // update budget
                                let updateBudgets = await BudgetSupport.editClassBudget(data.taskId, 'TASK', data.tenantId, null, null, 0, 0, data.loggedUserId, loggedUser, tenant, null, data.groupId, data.projectId)
                                if (updateBudgets.statusCode != 200) {
                                    appLogger.logMessage("info", "Failed to update budget.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                }
                                let updateBudget = await BudgetSupport.editClassBudget(data.taskId, 'SUBTASK', data.tenantId, null, null, data.maxAmount, data.minAmount, data.loggedUserId, loggedUser, tenant, data.newTaskId, data.groupId, data.projectId)
                                if (updateBudget.statusCode != 200) {
                                    appLogger.logMessage("info", "Failed to update milestone.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                }
                                // update milestone
                                let updateMilestone = await supportHandler.updateMilestone(data, data.taskId, data.loggedUser, data.tenant)
                                if (!updateMilestone) {
                                    appLogger.logMessage("info", "Failed to update milestone.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                                }
                                let updateTaskObj = {
                                    'actualCompletionDate': moment(data.actualCompletionDate).format("YYYY-MM-DD"),
                                    'estimatedStartDate':  moment(data.estimatedStartDate).format("YYYY-MM-DD"),
                                    'estimatedCompletionDate':  moment(data.estimatedCompletionDate).format("YYYY-MM-DD"),
                                    'taskStatusTypeCode': data.taskStatusTypeCode, 'mainTaskStatus': data.mainTaskStatus,
                                    'groupId': data.groupId, 'mainTaskId': data.newTaskId, 'projectId': data.projectId,
                                    'type': data.type, 'loggedUserId': data.loggedUserId, 'tenantId': data.tenantId
                                }
                                await supportHandler.taskDateChange(updateTaskObj, data.loggedUser, data.tenant)
                                await supportHandler.taskStatusChange(updateTaskObj, data.loggedUser, data.tenant)
                                result = await responseHandler.sendResponse("Success", "Task is successfully converted to sub task.", 200, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Task is successfully converted to sub task.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                            } else {
                                result = await responseHandler.sendResponse("Warning", "Failed to convert main task to sub task.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                appLogger.logMessage("info", "Failed to convert main task to sub task.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                            }
                        } else {
                            result = await responseHandler.sendResponse("Warning", "Failed to convert main task to sub task.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            appLogger.logMessage("info", "Failed to convert main task to sub task.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                        }
                        appLogger.logMessage("info", "Failed to get sub tasks.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to get sub tasks.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    appLogger.logMessage("info", "Failed to get sub tasks.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                appLogger.logMessage("info", "Invalid Parameters.", "convertTaskToIssue", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "convertTaskToIssue", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "convertTaskToIssue", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "convertTaskToIssue", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "convertTaskToIssue", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getOverallProjectProgress: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        try {
            let percentage = 0,totalTask = 0, completeTask = 0;
            let obj = {
                totalTask: totalTask,
                completeTask:completeTask,
                percentage:percentage,
                color: "grey",
                message: "No Tasks available."
            };
            appLogger.logMessage("info", "getOverallProjectProgress function begins", "PMService", "getOverallProjectProgress", loggedUser, tenant, moduleName);
            let scale = configData.projectHealth.progress;
            result = await dbOperations.executeQuery(mysqlQueries.viewProjectsByManager,[body.loggedUserId,body.tenantId,body.loggedUserId], loggedUser, "getProjectDetails", false, null, tenant, appLogger, meteringLogger, moduleName);
            if (result != null && result != undefined && result != 'Error' && result.length > 0) {
                result = result.filter(x => x.PROJECT_ID == body.projectId);
                if(result[0].TOTAL_TASKS != 0){
                    totalTask = Number(result[0].TOTAL_TASKS)
                    completeTask = Number(result[0].COMPLETED_TASK)
                    percentage = ((Number(result[0].COMPLETED_TASK)/Number(result[0].TOTAL_TASKS)) * 100).toFixed(2)
                }
                let res = scale.filter(x => percentage > x.minvalue && percentage <= x.maxvalue)
                obj['percentage'] = percentage
                obj['completeTask'] = completeTask
                obj['totalTask'] = totalTask
                obj['color'] = (percentage == 0 && totalTask == 0) ? "grey" : res[0].color;
                obj['message'] = (percentage == 0 && totalTask == 0) ? "No Tasks available." : percentage+"% ("+completeTask+"/"+totalTask+") of tasks are completed."
                appLogger.logMessage("info", "Project details fetched successfully.", +JSON.stringify(result), "PMService", "getOverallProjectProgress", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Success", "Project progress fetched successfully.", 200, obj, true, "getOverallProjectProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            } else {
                appLogger.logMessage("info", "Failed to fetch project details", +JSON.stringify(result), "PMService", "getOverallProjectProgress", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Failed to fetch project progress", 400, null, false, "getOverallProjectProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getOverallProjectProgress", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  getOverallProjectProgress" + error.message, "PMService", "getOverallProjectProgress", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured " + JSON.stringify(error), 500, null, false, "getOverallProjectProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "getOverallProjectProgress function completed", "PMService", "getOverallProjectProgress", loggedUser, tenant, moduleName);
        return result;
    },
    getOverallProjectStatus: async function (body,loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        try {
            appLogger.logMessage("info", "getOverallProjectStatus function begins", "PMService", "getOverallProjectStatus", loggedUser, tenant, moduleName);
            let scale = configData.projectHealth.projectStatus;
            let obj = {
                percentage:0,
                color: "grey",
                message: "Project is not started."
            };
            result = await dbOperations.executeQuery(mysqlQueries.getProjectDetails, [body.tenantId, body.projectId], loggedUser, "getProjectDetails", false, null, tenant,appLogger,meteringLogger,moduleName);
            if (result != null && result != undefined && result != 'Error' && result.length > 0) {                
                let CompletionDate = moment(result[0].ACTUAL_COMPLETION_DATE).format("YYYY-MM-DD");
                let StartDate = moment(result[0].ACTUAL_START_DATE).format("YYYY-MM-DD");
                result = await this.getOverallProjectProgress(body, loggedUser, tenant)
                if(result.data.totalTask > 0){
                    let totalProgress = (result.type.toUpperCase() == "SUCCESS") ? result.data.percentage : 0;
                    let balancePendingProgress = 100 - Number(totalProgress)
                    let totalDays = moment(CompletionDate).diff(moment(StartDate), "days")
                    let ActualCompletionDate = moment(StartDate).add(((balancePendingProgress / 100) * totalDays), 'd').format("YYYY-MM-DD")
                    let SchedulePerformance = ((moment(CompletionDate).diff(moment(ActualCompletionDate), "days") / totalDays ) * 100).toFixed(2)
                    let res = scale.filter(x => SchedulePerformance > x.minvalue && SchedulePerformance <= x.maxvalue)
                    obj['percentage'] = SchedulePerformance;
                    obj['color'] = res[0].color;
                    switch(obj.color){
                        case 'Red': obj['message'] = "Needs Attention."
                            break;
                        case 'Amber': obj['message'] = "At Risk."
                            break
                        default : obj['message'] = "On Track."
                            break;
                    }
                }
                result = await responseHandler.sendResponse("Success", "Project details fetched successfully.", 200, obj, true, "getOverallProjectStatus", tenant, loggedUser, moduleName,appLogger,meteringLogger);
            }else{
                appLogger.logMessage("info", "Failed to fetch project details", +JSON.stringify(result), "PMService", "getOverallProjectStatus", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Failed to fetch project details", 400, null, false, "getOverallProjectStatus", tenant, loggedUser, moduleName,appLogger,meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getOverallProjectStatus", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  getOverallProjectStatus" + error.message, "PMService", "getOverallProjectStatus", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured "+JSON.stringify(error), 500, null, false, "getOverallProjectStatus", tenant, loggedUser, moduleName,appLogger,meteringLogger);
        }
        appLogger.logMessage("info", "getOverallProjectStatus function completed", "PMService", "getOverallProjectStatus", loggedUser, tenant, moduleName);
        return result;
    },
    getOverallProjectBudget: async function (body,loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        try {
            appLogger.logMessage("info", "getOverallProjectBudget function begins", "PMService", "getOverallProjectBudget", loggedUser, tenant, moduleName);
            result = await getBalanceAmtOfProject(body.projectId,body.tenantId,loggedUser,tenant)
            let budget = 0,usedAmt = 0,totalBudget = 0, balanceAmt = 0;
            let obj = {
                budget: usedAmt,
                totalBudget: totalBudget,
                balanceAmt:balanceAmt,
                percentage:budget,
                color: "grey",
                message: "Budget is not allocated."
            };
            if(result.data.length != 0){
                let scale = configData.projectHealth.Budget;
                if(Number(result.data[0].BUDGET_AMOUNT_MAX) != 0){
                    totalBudget = Number(result.data[0].BUDGET_AMOUNT_MAX)
                    balanceAmt = Number(result.data[0].BALANCE_AMT) 
                    usedAmt = Number(result.data[0].BUDGET_AMOUNT_MAX)-Number(result.data[0].BALANCE_AMT) 
                    budget = (usedAmt != 0) ? ((usedAmt/Number(result.data[0].BUDGET_AMOUNT_MAX))*100).toFixed(2) : 0
                }
                let res = scale.filter(x => budget > x.minvalue && budget <= x.maxvalue)
                obj['budget'] = usedAmt;
                obj['totalBudget'] = totalBudget;
                obj['balanceAmt'] = balanceAmt;
                obj['percentage'] = budget;
                obj['color'] = (budget == 0 && totalBudget == 0) ? "grey" : res[0].color;
                obj['message'] = (budget == 0 && totalBudget == 0) ? "Budget is not allocated." : budget+"% ("+result.data[0].SYMBOL+usedAmt+") from "+result.data[0].SYMBOL+totalBudget+" is used."
            }
            result = await responseHandler.sendResponse("Success", "Project budget fetched successfully.", 200, obj, true, "getOverallProjectBudget", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getOverallProjectBudget", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  getOverallProjectBudget" + error.message, "PMService", "getOverallProjectBudget", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured "+JSON.stringify(error), 500, null, false, "getOverallProjectBudget", tenant, loggedUser, moduleName,appLogger,meteringLogger);
        }
        appLogger.logMessage("info", "getOverallProjectBudget function completed", "PMService", "getOverallProjectBudget", loggedUser, tenant, moduleName);
        return result;
    },
    getIPProjects: async function (loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result,attachments;
        try {
            appLogger.logMessage("info", "getIPProjects function begins", "PMService", "getIPProjects", loggedUser, tenant, moduleName);
            result = await dbOperations.executeQuery(mysqlQueries.getIPTasks, [], loggedUser, "getIPTasks", false, null, tenant, appLogger, meteringLogger, moduleName);
            if (result != null && result != undefined && result != 'Error'){
            if (result.length > 0) {
                appLogger.logMessage("info", "Project details fetched successfully.", +JSON.stringify(result), "PMService", "getIPProjects", loggedUser, tenant, moduleName);
                let groupTenant = await groupBy(result, "TENANT_ID")
                let tenantName, groupClient, groupProject, destinationPath, fileName, projectName, tenantBasedData = [], clientName, projectBasedData, fileUrls = [], fileNames = [];
                let tenantFolderDetails, projectFolderDetails,sharePointDetails, folderDetails,sharepointUrl,clientDetails;
                let showAttachment = false;
                let token = await getSupportEmailAPIToken(tenant, loggedUser, appLogger, meteringLogger, moduleName);
                destinationPath = configData.attachmentPath+"Clients/"
                if (!fs.existsSync(destinationPath)) {
                    fs.mkdirSync(destinationPath);
                }
                for (let tenantId of Object.keys(groupTenant)) {
                    showAttachment = false;
                    destinationPath = destinationPath+tenantId+"/"
                    if (!fs.existsSync(destinationPath)) {
                        fs.mkdirSync(destinationPath);
                    }
                    tenantName = result.filter((x) => x.TENANT_ID == Number(tenantId))[0].TENANT_NAME;
                    tenantFolderDetails = await OneDrive.createSubFolder(tenantName, null, token,loggedUser,tenant,appLogger,meteringLogger,moduleName, true)
                    groupClient = await groupBy(groupTenant[tenantId], "CLIENT_ID")
                    for (let clientId of Object.keys(groupClient)) {
                        destinationPath = destinationPath+ clientId+"/"
                        if (!fs.existsSync(destinationPath)) {
                            fs.mkdirSync(destinationPath);
                        }
                        clientName = result.filter((x) => x.CLIENT_ID == Number(clientId))[0].CLIENT_NAME;
                        projectFolderDetails = await OneDrive.createSubFolder(clientName, tenantFolderDetails.Id,token,loggedUser,tenant,appLogger,meteringLogger,moduleName, false)
                        groupProject = await groupBy(groupClient[clientId], "ID")
                        for (let projectId of Object.keys(groupProject)) {
                            projectBasedData = []
                            destinationPath = destinationPath+ projectId+"/"
                            if (!fs.existsSync(destinationPath)) {
                                fs.mkdirSync(destinationPath);
                            }
                            let createProject = true;
                            projectName = result.filter((x) => x.ID == Number(projectId))[0].PROJECT_NAME;
                            for(let file of groupProject[projectId]){
                                attachments = []
                                fileNames = (file.FILE_NAMES != null && file.FILE_NAMES != undefined) ? file.FILE_NAMES.split(",") : [];
                                fileUrls = (file.FILE_URLS != null && file.FILE_URLS != undefined) ? file.FILE_URLS.split(",") : [];
                                for(let i = 0;i< fileUrls.length ;i++){
                                    if(createProject){
                                        folderDetails = await OneDrive.createSubFolder(moment().format("DD-MMM-YYYY"), projectFolderDetails.Id,token,loggedUser,tenant,appLogger,meteringLogger,moduleName, false)
                                        createProject = false;
                                        sharePointDetails = await OneDrive.createSubFolder(projectName, folderDetails.Id,token,loggedUser,tenant,appLogger,meteringLogger,moduleName, false)
                                    }
                                    showAttachment = true;
                                    await OneDrive.uploadFile(fileNames[i], fileUrls[i].split("=")[1],sharePointDetails.Id, token,loggedUser,tenant,appLogger,meteringLogger,moduleName)
                                    sharepointUrl = await OneDrive.setReadOnlyPermission( folderDetails.Id,token,loggedUser,tenant,appLogger,meteringLogger,moduleName)
                                }
                            }
                            projectBasedData.push({
                                TASKS: groupProject[projectId].map(({ TASK_NAME }) => ({ TASK_NAME }))
                            })
                            fileName = tenantName+"_"+clientName+"_"+projectName+"_"+moment().format("DD-MM-YYYY")+".pdf"
                            let param = {
                                "query": JSON.stringify(projectBasedData)
                            }
                            let key = String(tenantName).toUpperCase()+"_"+tenantId;
                            let image = await ImageHandler.fetchLogo(key,loggedUser,tenant,appLogger,meteringLogger,moduleName);
                            response = await axios.post(process.env.pythonHostUrl + ":" + process.env.pythonPort + configData.formatContent, param);
                            await supportHandler.generateClientPdf(fileName, destinationPath, sharepointUrl, response, image, tenantName,loggedUser,tenant,showAttachment,projectName)
                            let resp = await dbOperations.executeQuery(mysqlQueries.getPMDetails, [projectId], loggedUser, "getPMDetails", false, null, tenant, appLogger, meteringLogger, moduleName);
                            let content = fs.readFileSync(destinationPath+fileName).toString("base64");
                            attachments.push({
                                "@odata.type": "#microsoft.graph.fileAttachment",
                                "name": fileName ,
                                "contentType": "application/pdf","contentBytes": content
                            })
                            if (resp != null && resp != undefined && resp != 'error' && resp.length > 0) {
                                let sub = mailConfig.clientSummary.sub
                                sub = sub.replace("{{projectName}}",projectName)
                                let message = mailConfig.clientSummary.message
                                message = message.replace("{{projectName}}",projectName)
                                let managerEmail = resp.map(x => x.Email).join(",")
                                await sendMail(managerEmail, null, sub, message, loggedUser, tenant, attachments, true, appLogger, meteringLogger, moduleName)
                            }
                            clientDetails = await dbOperations.executeQuery(mysqlQueries.getClientDetails, [projectId], loggedUser, "getClientDetails", false, null, tenant, appLogger, meteringLogger, moduleName);            
                            await supportHandler.sendSummaryPdf(clientDetails,fileName,loggedUser, tenant,appLogger, meteringLogger, moduleName)
                            destinationPath = destinationPath.split('/').splice(0,7).join('/')+"/"
                            await sleep(3000);
                        }
                        destinationPath = destinationPath.split('/').splice(0, 6).join('/') + "/"
                        }
                        destinationPath = destinationPath.split('/').splice(0, 5).join('/') + "/"
                }
                result = await responseHandler.sendResponse("Success", "Project progress fetched successfully.", 200, tenantBasedData, true, "getIPProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            } else {
                appLogger.logMessage("info", "No tasks are available", +JSON.stringify(result), "PMService", "getIPProjects", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Success", "No tasks are available", 400, null, false, "getIPProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            } else {
                appLogger.logMessage("info", "Failed to fetch project details", +JSON.stringify(result), "PMService", "getIPProjects", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Success", "Failed to fetch project progress", 400, null, false, "getIPProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getIPProjects", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  getIPProjects " + error.message, "PMService", "getIPProjects", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured " + JSON.stringify(error), 500, null, false, "getIPProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "getIPProjects function completed", "PMService", "getIPProjects", loggedUser, tenant, moduleName);
        return result;
    },

   
    completedTaskCountForPM: async function (req, loggedUser, tenant) {
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        appLogger.logMessage("info", "completedTaskCountForPM function called", className, "completedTaskCountForPM", req.body.loggedUser, req.body.tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully fetched completed project count",
            data: {},
            statusCode: 200
        }
        try {
            let body=req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.completedTaskCountForPM);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }

            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch completed task count due to missing parameters: " + JSON.stringify(missingParams), className, "completedProjectCountForPM", loggedUser, tenant, moduleName);
                out = {
                    status: "Failure",
                    message: "Missing parameters: " + JSON.stringify(missingParams),
                    statusCode: 400
                }
            } else {
                let query,param=[],labelArray=[],seriesArray=[]
                let dataArray=[]
                query=mysqlQueries.completedTaskCountForPM
                param=[body.loggedUserId,body.tenantId,body.startDate,body.endDate]
                result = await dbOperations.executeQuery(query,param, loggedUser, "completedTaskCountForPM", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error'){
                    if(result.length>0){
                        appLogger.logMessage("info", "Completed project count fetch successfully", className, "completedProjectCountForPM", loggedUser, tenant, moduleName);
                        for (let x of result) {
                            labelArray.push(x.FULL_NAME)
                            seriesArray.push(x.TASK_COUNT)
                        }
                        let obj = { 'series': seriesArray, 'label': labelArray }
                        dataArray.push(obj)
                        out.data=dataArray
                        out.message="Completed task count fetch successfully"
                        out.statusCode=200
                        out.status="Success"
                        
                    }else{
                        out.message="No data available"
                        out.statusCode=404
                        out.status="Warning"
                        out.data=[]
                    }
                }else{
                    out.message="Failed to fetch task count"
                    out.statusCode=404
                    out.status="Warning"
                    out.data=[]
                }
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to  fetch completed task count due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", out.data, className, "completedTaskCountForPM", req.body.loggedUser, req.body.tenant, moduleName);
        } 
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, "PMService", "completedTaskCountForPM", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },

    // FETCH TAGS FROM TASK AND ISSUE IN A PROJECT
    fetchTag: async function (req, loggedUser, tenant) {
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        appLogger.logMessage("info", "fetchTag function called", className, "fetchTag", req.body.loggedUser, req.body.tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully fetched tags",
            data: {},
            statusCode: 200
        }
        try {
            let body=req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.fetchTag);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }

            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch tags due to missing parameters: " + JSON.stringify(missingParams), className, "fetchTag", loggedUser, tenant, moduleName);
                out = {
                    status: "Failure",
                    message: "Missing parameters: " + JSON.stringify(missingParams),
                    statusCode: 400
                }
            } else {
                let query,param=[],tagArray=[]
                query=mysqlQueries.fetchTag
                param=[body.projectId,body.tenantId,body.projectId,body.tenantId]
                result = await dbOperations.executeQuery(query,param, loggedUser, "fetchTag", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error'){
                    if(result.length>0){
                        appLogger.logMessage("info", "Fetch tags  successfully", className, "fetchTag", loggedUser, tenant, moduleName);
                        for(let data of result){
                            if(!tagArray.includes(data.TASK_TAG) && data.TASK_TAG != null && data.TASK_TAG.trim() != "" && data.TASK_TAG != undefined){
                                tagArray.push(data.TASK_TAG)
                            }
                            if(!tagArray.includes(data.ISSUE_TAG) && data.ISSUE_TAG != null && data.ISSUE_TAG.trim() != "" && data.ISSUE_TAG != undefined){
                                tagArray.push(data.ISSUE_TAG)
                            }
                        }
                        out.data=tagArray
                        out.message="Tag fetched successfully"
                        out.statusCode=200
                        out.status="Success"
                        
                    }else{
                        out.data=[]
                        out.message="No tag available"
                        out.statusCode=404
                        out.status="Warning"
                    }
                }else {
                    out.data=[]
                        out.message="Failed to fetch tags"
                        out.statusCode=404
                        out.status="Warning"
                }
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to fetch tags  due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", out.data, className, "fetchTag", req.body.loggedUser, req.body.tenant, moduleName);
        } 
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, "PMService", "fetchTag", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },

    // FETCH TAGS FROM TASK AND ISSUE IN A PROJECT
    updateTag: async function (req, loggedUser, tenant) {
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        appLogger.logMessage("info", "updateTag function called", className, "updateTag", req.body.loggedUser, req.body.tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully mapped tag",
            data: {},
            statusCode: 200
        }
        try {
            let body=req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.updateTag);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }

            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to map tag due to missing parameters: " + JSON.stringify(missingParams), className, "fetchTag", loggedUser, tenant, moduleName);
                out = {
                    status: "Failure",
                    message: "Missing parameters: " + JSON.stringify(missingParams),
                    statusCode: 400
                }
            } else {
                let query,param=[];tagArray=[]
                if(body.tag!=null && body.tag!=undefined && body.tag!='null' && body.tag!='undefined'){
                    if(body.task_tag=='true'  ){
                        query=mysqlQueries.updateTaskTag
                        param=[body.tag,body.loggedUserId,body.taskId,body.tenantId]
                    }else if(body.issue_tag=='true'){
                        query=mysqlQueries.updateIssueTag
                        param=[body.tag,body.loggedUserId,body.issueId,body.tenantId]
                    }
                    
                    result = await dbOperations.executeQuery(query,param, loggedUser, "updateTag", false, null, tenant, appLogger, meteringLogger, moduleName)
                    if (result != undefined && result != null && result != 'Error'){
                        if(result.affectedRows>0){
                            appLogger.logMessage("info", "Tag mapped  successfully", className, "updateTag", loggedUser, tenant, moduleName);
                            out.data=[]
                            out.message="Tag mapped successfully"
                            out.statusCode=200
                            out.status="Success"
                            
                        }else{
                            out.data=[]
                            out.message="No changes for the  tag "
                            out.statusCode=404
                            out.status="Warning"
                        }
                    }else {
                        out.data=[]
                            out.message="Failed to map tags"
                            out.statusCode=404
                            out.status="Warning"
                    }
                }else{
                    out.status="Warning";
                    out.message="Please provide valid tag name."
                    out.statusCode=400
                    out.data=[]

                }
                
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to map tag due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", out.data, className, "updateTag", req.body.loggedUser, req.body.tenant, moduleName);
        } 
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, "PMService", "updateTag", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },

    completedTaskCountForEmp: async function (req, loggedUser, tenant) {
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        appLogger.logMessage("info", "completedTaskCountForEmp function called", className, "completedTaskCountForEmp", req.body.loggedUser, req.body.tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully fetched completed task count",
            data: {},
            statusCode: 200
        }
        try {
            let body=req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.completedTaskCountForEmp);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }

            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch completed project count due to missing parameters: " + JSON.stringify(missingParams), className, "completedTaskCountForEmp", loggedUser, tenant, moduleName);
                out = {
                    status: "Failure",
                    message: "Missing parameters: " + JSON.stringify(missingParams),
                    statusCode: 400
                }
            } else {
                let query,param=[],labelArray=[],seriesArray=[]
                let dataArray=[]
                query=mysqlQueries.completedTasKCountForEmp
                param=[body.loggedUserId,body.tenantId,body.startDate,body.endDate]
                result = await dbOperations.executeQuery(query,param, loggedUser, "completedTaskCountForEmp", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error'){
                    if(result.length>0){
                        appLogger.logMessage("info", "Completed project count fetch successfully", className, "completedTaskCountForEmp", loggedUser, tenant, moduleName);
                        for (let x of result) {
                            labelArray.push(x.PROJECT_NAME)
                            seriesArray.push(x.TASK_COUNT)
                        }
                        let obj = { 'series': seriesArray, 'label': labelArray }
                        dataArray.push(obj)
                        out.data=dataArray
                        out.message="Completed task count fetch successfully"
                        out.statusCode=200
                        out.status="Success"
                        
                    }else{
                        out.message="No data available"
                        out.statusCode=404
                        out.status="Warning"
                        out.data=[]
                    }
                }else{
                    out.message="Failed to fetch task count"
                    out.statusCode=404
                    out.status="Warning"
                    out.data=[]
                }
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to  fetch completed task count due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", out.data, className, "completedTaskCountForEmp", req.body.loggedUser, req.body.tenant, moduleName);
        } 
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, "PMService", "completedTaskCountForEmp", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },

    fetchIssuesForDashboard: async function (req, loggedUser, tenant) {
        startDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        appLogger.logMessage("info", "fetchIssuesForDashboard function called", className, "fetchIssuesForDashboard", req.body.loggedUser, req.body.tenant, moduleName);
        let out = {
            status: "Success",
            message: "Successfully fetched issues",
            data: {},
            statusCode: 200
        }
        try {
            let body=req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.completedTaskCountForEmp);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }

            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch issues due to missing parameters: " + JSON.stringify(missingParams), className, "completedTaskCountForEmp", loggedUser, tenant, moduleName);
                out = {
                    status: "Failure",
                    message: "Missing parameters: " + JSON.stringify(missingParams),
                    statusCode: 400
                }
            } else {
                let query,param=[]
                if(body.role=='employee'){
                    query=mysqlQueries.getIssueByUser
                    param=[body.loggedUserId]
                }else if(body.role=='project_manager'){
                    query=mysqlQueries.fetchIssuesForPM
                    param=[body.loggedUserId,body.tenantId]

                }
                result = await dbOperations.executeQuery(query,param, loggedUser, "fetchIssuesForDashboard", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result != 'Error'){
                    if(result.length>0){
                        appLogger.logMessage("info", "Completed project count fetch successfully", className, "completedTaskCountForEmp", loggedUser, tenant, moduleName);
                        
                        out.data=result
                        out.message="Issued fetched successfully"
                        out.statusCode=200
                        out.status="Success"
                        
                    }else{
                        out.message="No data available"
                        out.statusCode=404
                        out.status="Warning"
                        out.data=[]
                    }
                }else{
                    out.message="Failed to fetch issues"
                    out.statusCode=404
                    out.status="Warning"
                    out.data=[]
                }
            }
        } catch (error) {
            out.status = "Failure";
            out.message = "Internal server error";
            out.data = "Failed to  fetch issues due to: " + JSON.stringify(error.message);
            appLogger.logMessage("error", out.data, className, "fetchIssuesForDashboard", req.body.loggedUser, req.body.tenant, moduleName);
        } 
        endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
        diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, "PMService", "fetchIssuesForDashboard", startDateTime, endDateTime, diffInMS, moduleName);
        return out;
    },
    getProjectMainTasks: async function (body,loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        try {
            let tasks = []
            appLogger.logMessage("info", "getProjectMainTasks function begins", "PMService", "getProjectMainTasks", loggedUser, tenant, moduleName);
            result = await this.getMainTasks(body);
            if(result.status.toUpperCase() == "SUCCESS"){
                tasks = [].concat(...result.data.map(x => x.TASK));
            }
            result = await responseHandler.sendResponse("Success", "Project budget fetched successfully.", 200, tasks, true, "getProjectMainTasks", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getProjectMainTasks", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  getProjectMainTasks" + error.message, "PMService", "getProjectMainTasks", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured "+JSON.stringify(error), 500, null, false, "getProjectMainTasks", tenant, loggedUser, moduleName,appLogger,meteringLogger);
        }
        appLogger.logMessage("info", "getProjectMainTasks function completed", "PMService", "getProjectMainTasks", loggedUser, tenant, moduleName);
        return result;
    },
    //EDIT PROJECT DETAILS 
    editProjectDetails: async function (body,loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        try {
            appLogger.logMessage("debug", "editProjectDetails function begins with body"+JSON.stringify(body), "PMService", "editProjectDetails", loggedUser, tenant, moduleName);
            
            let query,param=[]
            query=mysqlQueries.getProjectDetails
            param=[body.tenantId,body.projectId]
            result = await dbOperations.executeQuery(query,param, loggedUser, "editProjectDetails", false, null, tenant, appLogger, meteringLogger, moduleName)
            appLogger.logMessage("debug", "Result of project details are "+JSON.stringify(result), "PMService", "editProjectDetails", loggedUser, tenant, moduleName);
            if (result != undefined && result != null && result != 'Error'){
                if(result.length>0){
                    if(result[0].PROJECT_STATUS_TYPE_CODE=='COM'){
                        result = await responseHandler.sendResponse("Success", "You cannot edit any details of completed project.", 200, null, false, "editProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }else {
                        // check whether  project name is changes , if changed then validate the new 
                        //and and check it is already  exists

                        let canUpdate=null
                        if(body.projectName!=result[0].PROJECT_NAME){
                            let formatedProjectName = await validationHandler.validateString(body.projectName, body.loggedUser, body.tenant, appLogger, meteringLogger, moduleName);
                            body.projectName = formatedProjectName;
                            let isExists = await supportHandler.isProjectNameExists(body.projectName, body.projectTypeCode, body.tenantId, body.loggedUser, body.tenant);
                            if (isExists != null){
                                if (isExists == 0){
                                    canUpdate=true
                                }else{
                                    canUpdate=false
                                    result = await responseHandler.sendResponse("Warning", "Project name exists.", 200, null, false, "editProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                    appLogger.logMessage("info", "Project name exists ", "PMService", "editProjectDetails", loggedUser, tenant, moduleName);
    
                                }
                            }
                        }else {
                            canUpdate=true
                        }


                        if(canUpdate){
                            query=mysqlQueries.updateProjectDetails
                            param=[body.projectName,body.projectDescription,
                                            body.estimatedStartDate,body.estimatedCompletionDate,
                                        body.loggedUserId,body.projectId,body.tenantId]
                            result = await dbOperations.executeQuery(query,param, loggedUser, "editProjectDetails", false, null, tenant, appLogger, meteringLogger, moduleName)
                            appLogger.logMessage("debug", "Result of project details are "+JSON.stringify(result), "PMService", "editProjectDetails", loggedUser, tenant, moduleName);
                            if (result != undefined && result != null && result != 'Error'){
                                if(result.affectedRows>0){
                                    result = await responseHandler.sendResponse("Success", "Project details updated successfully.", 200, null, false, "editProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                }else{
                                    result = await responseHandler.sendResponse("Success", "No change for project details.", 404, null, false, "editProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                                 }
                            }else{
                                    result = await responseHandler.sendResponse("Warning", "Failed to update project details.", 404, null, false, "editProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                                }
                        }else if(!canUpdate){
                            result = await responseHandler.sendResponse("Warning", "Project name exists.", 200, null, false, "editProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                            appLogger.logMessage("info", "Project name exists ", "PMService", "editProjectDetails", loggedUser, tenant, moduleName);

                        }else{
                            appLogger.logMessage("info", "Failed to check project name exists ", "PMService", "editProjectDetails", loggedUser, tenant, moduleName);
                            result = await responseHandler.sendResponse("Warning", "Failed to check project name exists.", 200, null, false, "editProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                        }
                        
                    }

                }else{
                    appLogger.logMessage("info", "Failed to compare project details with exiting data.", "PMService", "editProjectDetails", loggedUser, tenant, moduleName);
                    result = await responseHandler.sendResponse("Warning", "Failed to compare project details with exiting data.", 400, null, false, "editProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            }else{
                appLogger.logMessage("info", "Failed to compare project details with exiting data.", "PMService", "editProjectDetails", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Failed to compare project details with exiting data.", 400, null, false, "editProjectDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "editProjectDetails", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  editProjectDetails" + error.message, "PMService", "editProjectDetails", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured "+JSON.stringify(error), 500, null, false, "editProjectDetails", tenant, loggedUser, moduleName,appLogger,meteringLogger);
        }
        appLogger.logMessage("info", "editProjectDetails function completed", "PMService", "editProjectDetails", loggedUser, tenant, moduleName);
        return result;
    },

    //API TO ADD TASK TO WATCH LIST
    //REMOVE TASK FROM WATCH LIST 
    updateTaskWatchList: async function (body,loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        try {
            appLogger.logMessage("debug", "updateTaskWatchList function begins with body"+JSON.stringify(body), "PMService", "updateTaskWatchList", loggedUser, tenant, moduleName);
            if(body.addToWatchList!=null && body.addToWatchList!=undefined && body.addToWatchList!='null' && body.addToWatchList!='undefined'
                && body.taskId!=null && body.taskId!=undefined){
                let query,param=[]
                let message;
                
                //  if task type is main , then add its sub task to the watchable list
                let taskIdArray=[]
                if(body.type=='MAIN'){
                    query=mysqlQueries.getSubTask
                    param=[body.taskId,['NS','OPEN','IP','HOLD'],body.tenantId]
                    result = await dbOperations.executeQuery(query,param, loggedUser, "updateTaskWatchList", false, null, tenant, appLogger, meteringLogger, moduleName)
                    appLogger.logMessage("debug", "Result after fetching sub tasks "+JSON.stringify(result), "PMService", "updateTaskWatchList", loggedUser, tenant, moduleName);
                    if(result!=undefined && result!=null && result!='Error'){
                        if(result.length>0){
                            appLogger.logMessage("info", "Sub tasks fetched ", "PMService", "updateTaskWatchList", loggedUser, tenant, moduleName);
                            for(let data of result){
                                taskIdArray.push(data.ID)
                            }
                        }
                    }else{
                        result = await responseHandler.sendResponse("Warning", "Failed to fetch sub tasks", 400, null, false, "updateTaskWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
        
                    }
                }
                taskIdArray.push(body.taskId)
                if(String(body.addToWatchList).toUpperCase()=='Y'){
                    message="Task added to watchlist successfully."
                    param=[]
                    
                    for(let data of taskIdArray){
                        let record=[]
                        record.push(body.tenantId)
                        record.push('TASK')
                        record.push(data)
                        record.push(body.loggedUserId)
                        record.push('ACTIVE')
                        record.push(body.loggedUserId)
                        record.push(body.loggedUserId)
                        param.push(record)
                        record=[]
                    }
                    param=[param]
                    query=mysqlQueries.setWatchList

                }else if(String(body.addToWatchList).toUpperCase()=='N'){
                    message="Task removed from watchlist successfully."
                    param=[]
                    param=['INACTIVE',body.loggedUserId,taskIdArray,'TASK',body.tenantId]
                    query=mysqlQueries.updateWatchList

                }
                    result = await dbOperations.executeQuery(query,param, loggedUser, "updateTaskWatchList", false, null, tenant, appLogger, meteringLogger, moduleName)
                appLogger.logMessage("debug", "Result of updating task watch list "+JSON.stringify(result), "PMService", "updateTaskWatchList", loggedUser, tenant, moduleName);
                if(result!=undefined && result!=null && result!='Error'){
                    if(result.affectedRows>0){
                        appLogger.logMessage("info", message, "PMService", "updateTaskWatchList", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", message, 200, null, false, "updateTaskWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
    
                    }else{
                        result = await responseHandler.sendResponse("Warning", "No change to the watch list", 400, null, false, "updateWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
    
                    }
                }else{
                    result = await responseHandler.sendResponse("Warning", "Failed to update watch list", 400, null, false, "updateTaskWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
    
                }
            }else{
                appLogger.logMessage("info", "Invalid parameters ", "PMService", "updateTaskWatchList", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid parameters ", 400, null, false, "updateTaskWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);

            }
            
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "updateTaskWatchList", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  updateTaskWatchList" + error.message, "PMService", "updateTaskWatchList", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured "+JSON.stringify(error), 500, null, false, "updateTaskWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
        }
        appLogger.logMessage("info", "updateTaskWatchList function completed", "PMService", "updateWatchList", loggedUser, tenant, moduleName);
        return result;
    },

    //API TO ADD PROJECT TO WATCH LIST, SET THE COLUMN VALUE IS_WATCHABLE 'Y'
    //REMOVE PROJECT FROM WATCH LIST ,SET CLOUMN VALUE IS_WATCHABLE 'N'
    updateProjectWatchList: async function (body,loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        try {
            appLogger.logMessage("debug", "updateProjectWatchList function begins with body"+JSON.stringify(body), "PMService", "updateProjectWatchList", loggedUser, tenant, moduleName);
            if(body.addToWatchList!=null && body.addToWatchList!=undefined && body.addToWatchList!='null' && body.addToWatchList!='undefined'
                && body.taskId!=null && body.taskId!=undefined){
                let query,param=[]
                let projectIdArray=[]
                projectIdArray.push(boy.projectId)
                if(String(body.addToWatchList).toUpperCase()=='Y'){
                    query=mysqlQueries.setWatchList
                    
                    for(let data of projectIdArray){
                        let record=[]
                        record.push(body.tenantId)
                        record.push('PROJECT')
                        record.push(data)
                        record.push(body.loggedUserId)
                        record.push('ACTIVE')
                        param.push(record)
                        record=[]


                    }
                }else if(String(body.addToWatchList).toUpperCase()=='N'){
                    param=['INACTIVE',projectIdArray,'PROJECT',body.tenantId]
                    query=mysqlQueries.updateWatchList
                }
                query=mysqlQueries.updateProjectWatchList
                result = await dbOperations.executeQuery(query,param, loggedUser, "updateProjectWatchList", false, null, tenant, appLogger, meteringLogger, moduleName)
                appLogger.logMessage("debug", "Result of updating project watch list "+JSON.stringify(result), "PMService", "updateProjectWatchList", loggedUser, tenant, moduleName);
                if(result!=undefined && result!=null && result!='Error'){
                    if(result.affectedRows>0){
                        appLogger.logMessage("info", "Project watch list updated successfully ", "PMService", "updateProjectWatchList", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Task watch list updated successfully ", 200, null, false, "updateProjectWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
    
                    }else{
                        result = await responseHandler.sendResponse("Warning", "No change to the watch list", 400, null, false, "updateProjectWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
    
                    }
                }else{
                    result = await responseHandler.sendResponse("Warning", "Failed to update watch list", 400, null, false, "updateProjectWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
    
                }
            }else{
                appLogger.logMessage("info", "Invalid parameters ", "PMService", "updateProjectWatchList", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid parameters ", 400, null, false, "updateProjectWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);

            }
            
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "updateProjectWatchList", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  updateProjectWatchList" + error.message, "PMService", "updateProjectWatchList", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured "+JSON.stringify(error), 500, null, false, "updateProjectWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
        }
        appLogger.logMessage("info", "updateProjectWatchList function completed", "PMService", "updateProjectWatchList", loggedUser, tenant, moduleName);
        return result;
    },

    //FETCH TASKS/PROJECT/ISSUES ADDED TO WATCH LIST
    getWatchList: async function (body,loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        try {
            appLogger.logMessage("debug", "getWatchList function begins with body"+JSON.stringify(body), "PMService", "getWatchList", loggedUser, tenant, moduleName);
            if(body.type!=null && body.type!=undefined && body.type!='null' && body.type!='undefined'){
                let query,param=[]
                
                if(String(body.type).toUpperCase()=='PROJECT'){
                    query=mysqlQueries.getProjectInWatchList
                    param=[body.loggedUser,body.tenantId]
 
                }else if(String(body.type).toUpperCase()=='TASK'){
                    query=mysqlQueries.getTaskInWatchList
                    param=[body.projectId,body.loggedUserId,body.tenantId]
                }else if (String(body.type).toUpperCase()=='ISSUE'){
                    query=mysqlQueries.getIssueInWatchList
                    param=[body.projectId,body.loggedUserId,body.tenantId]

                }
                result = await dbOperations.executeQuery(query,param, loggedUser, "getWatchList", false, null, tenant, appLogger, meteringLogger, moduleName)
                appLogger.logMessage("debug", "Result of fetching watch list "+JSON.stringify(result), "PMService", "getWatchList", loggedUser, tenant, moduleName);
                if(result!=undefined && result!=null && result!='Error'){
                    if(result.length>0){
                        appLogger.logMessage("info", "Watch list fetched successfully ", "PMService", "getWatchList", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Watch list fetched  successfully ", 200, result, true, "getWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
    
                    }else{
                        result = await responseHandler.sendResponse("Warning", "No data  in the watch list", 400, null, false, "getWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
    
                    }
                }else{
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch data from  watch list", 400, null, false, "getWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
                }
            }else{
                appLogger.logMessage("info", "Invalid parameters ", "PMService", "getWatchList", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid parameters ", 400, null, false, "getWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);

            }
            
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "updateProjectWatchList", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  getWatchList" + error.message, "PMService", "getWatchList", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured "+JSON.stringify(error), 500, null, false, "getWatchList", tenant, loggedUser, moduleName,appLogger,meteringLogger);
        }
        appLogger.logMessage("info", "getWatchList function completed", "PMService", "getWatchList", loggedUser, tenant, moduleName);
        return result;
    },

    // ADD COMPLETION PERCENTAGE TO THE  TASK
    addTaskProgress: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        try {
            appLogger.logMessage("debug", "addTaskProgress function begins with body" + JSON.stringify(body), "PMService", "addTaskProgress", loggedUser, tenant, moduleName);
            if (body.taskProgress != null && body.taskProgress != undefined && body.taskId != null && body.taskId != undefined) {
                let query, param = []
                
                query = mysqlQueries.addTaskProgress
                param = [body.taskProgress, body.loggedUserId, body.taskId, body.tenantId]
                result = await dbOperations.executeQuery(query, param, loggedUser, "addTaskProgress", false, null, tenant, appLogger, meteringLogger, moduleName)
                appLogger.logMessage("debug", "Result of fetching watch list " + JSON.stringify(result), "PMService", "addTaskProgress", loggedUser, tenant, moduleName);
                if (result != undefined && result != null && result != 'Error') {
                    if (result.affectedRows > 0) {
                        let mainTaskProgressUpdate = await supportHandler.updateMainTaskProgress(body,body.loggedUser,body.tenant)
                        if(mainTaskProgressUpdate.type=='Success'){
                            result = await responseHandler.sendResponse("Success", "Task Progress updated successfully.", 200, null, false, "addTaskProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                        }else{
                            result = await responseHandler.sendResponse("Warning", "Failed to update the main task progress.", 400, null, false, "addTaskProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                        }
                    } else {
                        result = await responseHandler.sendResponse("Warning", "No change in the task progress", 400, null, false, "addTaskProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);

                    }
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to update task progress", 400, null, false, "addTaskProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid parameters ", "PMService", "addTaskProgress", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid parameters ", 400, null, false, "addTaskProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);

            }

            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "addTaskProgress", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  addTaskProgress" + error.message, "PMService", "addTaskProgress", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured " + JSON.stringify(error), 500, null, false, "addTaskProgress", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "addTaskProgress function completed", "PMService", "addTaskProgress", loggedUser, tenant, moduleName);
        return result;
    },
	
    taskApproval: async function (body, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result,msg,whatsappMsg;
        try {
            appLogger.logMessage("debug", "taskApproval function begins.", "PMService", "taskApproval", loggedUser, tenant, moduleName);
            if (body.taskId != null && body.taskId != undefined && body.status != null && body.status != undefined) {
                msg = (body.status.toLowerCase() == "approved") ? "Failed to approve task." : "Failed to reject task.";
                if(body.status == 'Rejected'){
                    result = await dbOperations.executeQuery(mysqlQueries.taskRejection, ['IP',body.status,body.taskId], loggedUser, "taskApproval", true, [1], tenant, appLogger, meteringLogger, moduleName)
                }else{
                    result = await dbOperations.executeQuery(mysqlQueries.changeTaskApprovalStatus, [body.status,body.taskId], loggedUser, "taskApproval", true, [1], tenant, appLogger, meteringLogger, moduleName)
                } 
                if(result!=undefined && result!=null && result!='Error'){
                    if(result.affectedRows>0){
                        let sub,message;
                        if(body.status.toLowerCase() != "approved"){
                            sub = mailConfig.task.rejectTask.sub;
                            message = mailConfig.task.rejectTask.message;
                            message = message.replace("{comment}",body.comment)
                            whatsappMsg = "Your task '"+body.taskName+"' has been rejected by "+body.approverName+" in '"+body.projectName+"'"
                            result = await dbOperations.executeQuery(mysqlQueries.addComment, [body.tenantId,body.taskId,'A1007',body.comment,null], loggedUser, "taskApproval", true, [6,7], tenant, appLogger, meteringLogger, moduleName)
                            if(result != undefined && result !=null && result !='Error'){
                                if(result.affectedRows == 0){
                                    result = await responseHandler.sendResponse("Warning", msg, 400, null, false, "taskApproval", tenant, loggedUser, moduleName,appLogger,meteringLogger);
                                    return result
                                }
                            }else{
                                result = await responseHandler.sendResponse("Warning", msg, 400, null, false, "taskApproval", tenant, loggedUser, moduleName,appLogger,meteringLogger);
                                return result
                            }
                        }else{
                            sub = mailConfig.task.approveTask.sub
                            message = mailConfig.task.approveTask.message
                            whatsappMsg = "Your task '"+body.taskName+"' has been approved by "+body.approverName+" in '"+body.projectName+"'"
                        }
                        let userData = [{ 'Id': body.assigneeId, 'Email': body.assigneeEmail }]
                        sub = sub.replace("{projectName}",body.projectName)
                        sub = sub.replace("{taskId}",body.taskId)
                        message = message.replace("{projectName}",body.projectName)
                        message = message.replace("{approverName}",body.approverName)
                        message = message.replace("{taskId}",body.taskId)
                        message = message.replace("{taskName}",body.taskName)
                        message = message.replace("{taskDescription}",body.taskDescription)
                        sendMails(userData, null, null, sub, message, loggedUser, tenant, null, false, body.tenantId, appLogger, meteringLogger, moduleName)
                        await supportHandler.notifyUser(whatsappMsg, body.phno, body.tenantId, body.whatsappId, loggedUser, tenant)
                        await supportHandler.notifyInApp(body.loggedUserId,body.assigneeId,whatsappMsg,body.taskId,"TASK",body.tenantId,loggedUser, tenant)
                        appLogger.logMessage("info", "Task "+body.status.toLowerCase()+" successfully. ", "PMService", "taskApproval", loggedUser, tenant, moduleName);
                        result = await responseHandler.sendResponse("Success", "Task "+body.status.toLowerCase()+" successfully. ", 200, null, false, "taskApproval", tenant, loggedUser, moduleName,appLogger,meteringLogger);
                    }else{
                        result = await responseHandler.sendResponse("Warning", msg, 400, null, false, "taskApproval", tenant, loggedUser, moduleName,appLogger,meteringLogger);
                    }
                }else{
                    result = await responseHandler.sendResponse("Warning", msg, 400, null, false, "taskApproval", tenant, loggedUser, moduleName,appLogger,meteringLogger);
                }
            } else {
                appLogger.logMessage("info", "Invalid parameters ", "PMService", "taskApproval", loggedUser, tenant, moduleName);
                result = await responseHandler.sendResponse("Warning", "Invalid parameters ", 400, null, false, "taskApproval", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "taskApproval", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  taskApproval" + error.message, "PMService", "taskApproval", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured " + JSON.stringify(error), 500, null, false, "taskApproval", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "taskApproval function completed", "PMService", "taskApproval", loggedUser, tenant, moduleName);
        return result;
    },
    watcherDailySummary: async function (loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let result;
        try {
            appLogger.logMessage("debug", "watcherDailySummary function begins.", "PMService", "watcherDailySummary", loggedUser, tenant, moduleName);
            result = await dbOperations.executeQuery(mysqlQueries.getAllWatchlist, [], loggedUser, "watcherDailySummary", false, null, tenant, appLogger, meteringLogger, moduleName)
            if (result != undefined && result != null && result != 'Error') {
                if (result.length > 0) {
                    let sub = "Your Watchlist.";
                    let message,userData,projectGroup,projectData,fileName,attachments=[],content;
                    let destinationPath = configData.attachmentPath+"Summary_PDF/"
                    if (!fs.existsSync(destinationPath)) {
                        fs.mkdirSync(destinationPath);
    }
                    let token = await getSupportEmailAPIToken(tenant, loggedUser, appLogger, meteringLogger, moduleName);
                    let userGroup = await groupBy(result, "Id");
                    for (let userId of Object.keys(userGroup)) {
                        attachments =[]
                        destinationPath = destinationPath + userId + "/"
                        if (!fs.existsSync(destinationPath)) {
                            fs.mkdirSync(destinationPath);
                        }
                        projectGroup = await groupBy(userGroup[userId], "PROJECT_ID");
                        userData = result.filter((x) => x.Id == Number(userId))[0];
                        for (let projectId of Object.keys(projectGroup)) {
                            destinationPath = destinationPath + moment().format("DD_MM_YYYY") + "/"
                            if (!fs.existsSync(destinationPath)) {
                                fs.mkdirSync(destinationPath);
                            }
                            projectData = result.filter((x) => x.PROJECT_ID == Number(projectId))[0];
                            fileName = projectData.PROJECT_NAME+"_"+userId+"_"+moment().format("DD_MM_YYYY")+".pdf"
                            await supportHandler.generateWatcherPdf(fileName, destinationPath, projectGroup[projectId], loggedUser, tenant)
                            if (fs.existsSync(String(destinationPath+fileName))) {
                                content = fs.readFileSync(destinationPath+fileName).toString("base64");
                                attachments.push({
                                    "@odata.type": "#microsoft.graph.fileAttachment",
                                    "name": fileName ,
                                    "contentType": "application/pdf","contentBytes": content
                                })
                                await supportHandler.sendSummaryPdf([userData],fileName,loggedUser, tenant,appLogger, meteringLogger, moduleName)
                            }
                            destinationPath = destinationPath.split('/').splice(0, 6).join('/') + "/"
                        }
                        message = `Hi ${userData.FULL_NAME},<br>This is your update for your watchlist.`
                        await sendMail(userData.EMAIL, null, sub, message, loggedUser, tenant, attachments, true, appLogger, meteringLogger, moduleName)
                        await sleep(3000);
                        destinationPath = destinationPath.split('/').splice(0, 5).join('/') + "/"
                    }
                    result = await responseHandler.sendResponse("Success", "Summary report send successfully.", 200, projectGroup, true, "watcherDailySummary", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    appLogger.logMessage("info", "summary report send successfully.", "PMService", "watcherDailySummary", loggedUser, tenant, moduleName);
                } else {
                    result = await responseHandler.sendResponse("Warning", "No data found.", 400, null, false, "watcherDailySummary", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                    appLogger.logMessage("info", "No data found.", "PMService", "watcherDailySummary", loggedUser, tenant, moduleName);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Failed to fetch data.", 400, null, false, "watcherDailySummary", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                appLogger.logMessage("info", "failed to fetch data", "PMService", "watcherDailySummary", loggedUser, tenant, moduleName);
            }
            endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
            diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "watcherDailySummary", startDateTime, endDateTime, diffInMS, moduleName);
        } catch (error) {
            appLogger.logMessage("error", "Error occured in  watcherDailySummary" + error.message, "PMService", "watcherDailySummary", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Error", "Error occured " + JSON.stringify(error), 500, null, false, "watcherDailySummary", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        appLogger.logMessage("info", "watcherDailySummary function completed", "PMService", "watcherDailySummary", loggedUser, tenant, moduleName);
        return result;
    },
    updateIssueDetails: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "updateIssueDetails Service initiated.", "PMService", "updateIssueDetails", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.issueId != undefined && data.issueId != null && data.assignedTo != undefined && data.assignedTo != null
                && data.severity!=null && data.severity!=undefined && data.priority!=null  && data.priority!=undefined) {
                result = await dbOperations.executeQuery(mysqlQueries.updateIssueDetails, [data.severity,data.priority,data.loggedUserId, data.issueId], loggedUser, "updateIssueDetails", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.affectedRows > 0) {
                    result = await responseHandler.sendResponse("Success", "Issue details updated  successfully.", 200, null, false, "updateIssueDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to update issue details.", 400, null, false, "updateIssueDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "updateIssueDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "updateIssueDetails", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "updateIssueDetails Service completed.", "PMService", "updateIssueDetails", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "updateIssueDetails", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "updateIssueDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getProjectOwnerDetails: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "getProjectOwnerDetails Service initiated.", "PMService", "getProjectOwnerDetails", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.projectId != undefined && data.projectId != null ){
                result = await dbOperations.executeQuery(mysqlQueries.getProjectOwnerDetail, [data.projectId], loggedUser, "getProjectOwnerDetails", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.length > 0) {
                    result = await responseHandler.sendResponse("Success", "Project owner details fetched  successfully.", 200, result, true, "getProjectOwnerDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch project owner  details.", 400, null, false, "getProjectOwnerDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getProjectOwnerDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getProjectOwnerDetails", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "getProjectOwnerDetails Service completed.", "PMService", "getProjectOwnerDetails", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getProjectOwnerDetails", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getProjectOwnerDetails", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getPlannerProjects: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "getPlannerProjects", loggedUser, tenant, moduleName);
        let result;
        let query;
        let param=[];
        try {
            if (data.loggedUserId != undefined && data.loggedUserId != null && data.loadAll!=null && data.loadAll!=undefined && data.fromDate != undefined && data.fromDate != null && data.toDate != undefined && data.toDate != null){
                if(data.loadAll == 'true'){
                    query = mysqlQueries.getPlannerProjects
                    param = [data.loggedUserId,data.fromDate,data.toDate]
                }else{
                    query = mysqlQueries.getSpecificPlannerProjects
                    param = [data.loggedUserId,JSON.parse(data.projects)]
                }
                result = await dbOperations.executeQuery(query, param, loggedUser, "getPlannerProjects", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.length > 0) {
                    result = await responseHandler.sendResponse("Success", "Projects details fetched  successfully.", 200, result, true, "getPlannerProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch project  details.", 400, null, false, "getPlannerProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getPlannerProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getPlannerProjects", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "getPlannerProjects", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getPlannerProjects", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getPlannerProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getPlannerResources: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "getPlannerResources", loggedUser, tenant, moduleName);
        let result;
        let query;
        let param=[];
        try {
            if (data.loadAll!=null && data.loadAll!=undefined && data.fromDate != undefined && data.fromDate != null && data.toDate != undefined && data.toDate != null ){
                if(data.loadAll == 'true'){
                    query = mysqlQueries.getPlannerResources
                    param = [data.loggedUserId,data.fromDate,data.toDate]
                }else{
                    query = mysqlQueries.getSpecificPlannerResources
                    param = [JSON.parse(data.resources)]
                }
                result = await dbOperations.executeQuery(query, param, loggedUser, "getPlannerResources", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.length > 0) {
                    result = await responseHandler.sendResponse("Success", "Resources details fetched  successfully.", 200, result, true, "getPlannerResources", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch Resources  details.", 400, null, false, "getPlannerResources", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getPlannerResources", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getPlannerResources", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "getPlannerResources", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getPlannerResources", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getPlannerResources", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getPlannerDataOnProjects: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "getPlannerDataOnProjects", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.projects != undefined && data.projects != null && data.fromDate != undefined && data.fromDate != null && data.toDate != undefined && data.toDate != null ){
                result = await dbOperations.executeQuery(mysqlQueries.getPlannerDataOnProjects, [JSON.parse(data.projects),data.fromDate,data.toDate], loggedUser, "getPlannerDataOnProjects", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.length > 0) {
                    let lookup = await dbOperations.executeQuery(mysqlQueries.getLookupStatus, ['PROJECT_STATUS', data.tenantId], loggedUser, "getLookupStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                    let priorityLookup = await dbOperations.executeQuery(mysqlQueries.getLookupStatus, ['TASK_PRIORITY', data.tenantId], loggedUser, "getLookupStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                    for(let res of result){
                        let lookupAction = [{
                            "LOOKUP_CODE": res.STATUS_CODE,
                            "DISPLAY_VALUE": res.STATUS_DISPLAY_VALUE
                        }]
                        if (lookup != undefined && lookup != null && lookup.length > 0) {
                            let index = lookup.findIndex(x => x.LOOKUP_CODE === "CLOSED")
                            lookup[index].DISPLAY_VALUE = "Close";
                            index = lookup.findIndex(x => x.LOOKUP_CODE === "COM")
                            lookup[index].DISPLAY_VALUE = "Complete";
                            if (res.STATUS_CODE == "OPEN") {
                                let index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                lookup[index].STATUS_DISPLAY_VALUE = "Start";
                                lookupAction = lookupAction.concat(lookup.filter(x => ['IP', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                            } else if (res.STATUS_CODE == "IP") {
                                lookupAction = lookupAction.concat(lookup.filter(x => ['HOLD', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                            } else if (res.STATUS_CODE == "HOLD") {
                                let index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                lookup[index].DISPLAY_VALUE = "Resume";
                                lookupAction = lookupAction.concat(lookup.filter(x => ['IP', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                            }
                        }
                        let teamMembers = await dbOperations.executeQuery(mysqlQueries.getProjectTeamMembers, [res.PROJECT_ID], loggedUser, "getProjectTeamMembers", false, null, tenant, appLogger, meteringLogger, moduleName)
                        res["STATUS"] = lookupAction
                        res['PRIORITY']=priorityLookup
                        res['MEMBERS']=teamMembers
                    }
                    result = await responseHandler.sendResponse("Success", "Projects details fetched  successfully.", 200, result, true, "getPlannerDataOnProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch project  details.", 400, null, false, "getPlannerDataOnProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getPlannerDataOnProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getPlannerDataOnProjects", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "getPlannerDataOnProjects", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getPlannerDataOnProjects", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getPlannerDataOnProjects", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getPlannerDataOnResources: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "getPlannerDataOnResources", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.resources != undefined && data.resources != null && data.fromDate != undefined && data.fromDate != null && data.toDate != undefined && data.toDate != null ){
                result = await dbOperations.executeQuery(mysqlQueries.getPlannerDataOnResources, [JSON.parse(data.resources),data.loggedUserId,data.fromDate,data.toDate,data.loggedUserId], loggedUser, "getPlannerDataOnResources", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.length > 0) {
                    let lookup = await dbOperations.executeQuery(mysqlQueries.getLookupStatus, ['PROJECT_STATUS', data.tenantId], loggedUser, "getLookupStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                    let priorityLookup = await dbOperations.executeQuery(mysqlQueries.getLookupStatus, ['TASK_PRIORITY', data.tenantId], loggedUser, "getLookupStatus", false, null, tenant, appLogger, meteringLogger, moduleName)
                    for(let res of result){
                        let lookupAction = [{
                            "LOOKUP_CODE": res.STATUS_CODE,
                            "DISPLAY_VALUE": res.STATUS_DISPLAY_VALUE
                        }]
                        if (lookup != undefined && lookup != null && lookup.length > 0) {
                            let index = lookup.findIndex(x => x.LOOKUP_CODE === "CLOSED")
                            lookup[index].DISPLAY_VALUE = "Close";
                            index = lookup.findIndex(x => x.LOOKUP_CODE === "COM")
                            lookup[index].DISPLAY_VALUE = "Complete";
                            if (res.STATUS_CODE == "OPEN") {
                                let index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                lookup[index].DISPLAY_VALUE = "Start";
                                lookupAction = lookupAction.concat(lookup.filter(x => ['IP', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                            } else if (res.STATUS_CODE == "IP") {
                                lookupAction = lookupAction.concat(lookup.filter(x => ['HOLD', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                            } else if (res.STATUS_CODE == "HOLD") {
                                let index = lookup.findIndex(x => x.LOOKUP_CODE === "IP")
                                lookup[index].DISPLAY_VALUE = "Resume";
                                lookupAction = lookupAction.concat(lookup.filter(x => ['IP', 'COM', "CLOSED"].includes(x.LOOKUP_CODE)))
                            }
                        }
                        let teamMembers = await dbOperations.executeQuery(mysqlQueries.getProjectTeamMembers, [res.PROJECT_ID], loggedUser, "getProjectTeamMembers", false, null, tenant, appLogger, meteringLogger, moduleName)
                        res["STATUS"] = lookupAction
                        res['PRIORITY']=priorityLookup
                        res['MEMBERS']=teamMembers
                    }
                    result = await responseHandler.sendResponse("Success", "Resources details fetched  successfully.", 200, result, true, "getPlannerDataOnResources", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch Resources  details.", 400, null, false, "getPlannerDataOnResources", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getPlannerDataOnResources", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getPlannerDataOnResources", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "getPlannerDataOnResources", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getPlannerDataOnResources", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getPlannerDataOnResources", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    getPlannerData: async function (data, loggedUser, tenant) {
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        appLogger.logMessage("info", "Service initiated.", "PMService", "getPlannerData", loggedUser, tenant, moduleName);
        let result;
        try {
            if (data.fromDate != undefined && data.fromDate != null && data.toDate != undefined && data.toDate != null){
                result = await dbOperations.executeQuery(mysqlQueries.getPlannerData, [data.loggedUserId,data.fromDate,data.toDate], loggedUser, "getPlannerData", false, null, tenant, appLogger, meteringLogger, moduleName)
                if (result != undefined && result != null && result.length > 0) {
                    result = await responseHandler.sendResponse("Success", "Data details fetched  successfully.", 200, result, true, "getPlannerData", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                } else {
                    result = await responseHandler.sendResponse("Warning", "Failed to fetch data   details.", 400, null, false, "getPlannerData", tenant, loggedUser, moduleName, appLogger, meteringLogger);
                }
            } else {
                result = await responseHandler.sendResponse("Warning", "Invalid Parameters.", 400, null, false, "getPlannerData", tenant, loggedUser, moduleName, appLogger, meteringLogger);
            }
            endDateTime = moment().format("YYYY-MM-DD HH:mm:ss.SSS");
            diffInMS = moment(endDateTime).diff(moment(startDateTime), "ms");
            meteringLogger.logMessage(tenant, loggedUser, "PMService", "getPlannerData", startDateTime, endDateTime, diffInMS, moduleName);
            appLogger.logMessage("info", "Service completed.", "PMService", "getPlannerData", loggedUser, tenant, moduleName, moduleName);
        } catch (e) {
            appLogger.logMessage("error", e.message, "PMService", "getPlannerData", loggedUser, tenant, moduleName);
            result = await responseHandler.sendResponse("Failure", e.message, 500, null, false, "getPlannerData", tenant, loggedUser, moduleName, appLogger, meteringLogger);
        }
        return result;
    },
    updateTaskPriority: async function (req) {
        appLogger.logMessage("info", "updateTaskPriority service invoked by: " + req.loggedUser, className, "updateTaskPriority", req.body.loggedUser, req.body.tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully updated the task priority",
            statusCode: 200,
            data: {}
        }
        try {
            let body = req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.updateTaskPriority);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to updateTaskPriority tasks due to missing parameters: " + JSON.stringify(missingParams), className, "updateTaskPriority", req.body.loggedUser, req.body.tenant, moduleName);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 400;
            } else {
                let updateTaskPriority = mysqlQueries.updateTaskPriority;
                let param = [req.body.priorityCode, req.body.loggedUserId,req.body.taskId];
                appLogger.logMessage("debug", "Assign parameters: " + req.body.priority + " and taskId: " + req.body.taskId, className, "updateTaskPriority", req.body.loggedUser, req.body.tenant, moduleName);
                result = await dbOperations.executeQuery(updateTaskPriority, param, req.body.loggedUser, "updateTaskPriority", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                if (result) {
                    if (result.affectedRows > 0) {
                        out.status = "Success";
                        out.statusCode = 200;
                        out.message = "Priority changed successfully";
                        if (body.assignedTo != body.loggedUserId) {
                            if (body.projectName != null && body.projectName != undefined
                                && body.taskId != null && body.taskId != undefined
                                && body.priority != null && body.priority != undefined
                                && body.taskName != null && body.taskName != undefined
                                && body.groupName != null && body.groupName != undefined
                                && body.taskDescription != null && body.taskDescription != undefined
                                && body.estimatedStartDate != null && body.estimatedStartDate != undefined
                                && body.estimatedCompletionDate != null && body.estimatedCompletionDate != undefined
                                && body.updatedByName != null && body.updatedByName != undefined && body.assigneeEmail !=null && body.assigneeEmail!=undefined) {
                                let sub = mailConfig.task.priortyChange.sub
                                let mes = mailConfig.task.priortyChange.message
                                let message;
                                sub = sub.replace('{projectName}', body.projectName)
                                sub = sub.replace('{updatedByName}', body.updatedByName)
                                sub = sub.replace('{taskId}', body.taskId)
                                mes = mes.replace('{updatedByName}', body.updatedByName)
                                mes = mes.replace('{taskId}', body.taskId)
                                mes = mes.replace('{projectName}', body.projectName)
                                mes = mes.replace('{taskName}', body.taskName)
                                mes = mes.replace('{groupName}', body.groupName)
                                mes = mes.replace('{taskDescription}', body.taskDescription)
                                mes = mes.replace('{estimatedStartDate}', moment(body.estimatedStartDate).format('DD-MMM-YYYY'))
                                mes = mes.replace('{estimatedCompletionDate}', moment(body.estimatedCompletionDate).format('DD-MMM-YYYY'))
                                mes = mes.replace('{priority}', body.priority)
                                message = mes
                                let userData = [{ 'Id': body.assignedTo, 'Email': body.assigneeEmail }]
                                sendMails(userData, null, null, sub, message, body.loggedUser, body.tenant, null, false, body.tenantId, appLogger, meteringLogger, moduleName)
                            } else {
                                appLogger.logMessage("info", "Invalid parameters for email.", className, "updateTaskPriority", req.body.loggedUser, req.body.tenant, moduleName);
                            }
                        }

                        // if task added to watch list , notify watch list users on assigning 
                        //body['addedToWatchList']=true
                        if(body.addedToWatchList=='true'){
                            let nofifyResult=await supportHandler.watchListNotification(body,'priority_update',body.loggedUser,body.tenant)
                            appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "assignUserToTask", loggedUser, tenant, moduleName);
                        }

                        let message = "Task" +body.taskName+ "(# "+body.taskId+") in project "+body.projectName+" priority has been updated to "+body.priority
                        let assigneeDetails = await dbOperations.executeQuery(mysqlQueries.getAssigneeDetails,[String(body.assigneeEmail).toUpperCase()],body.loggedUser,"getAssigneeDetails",false,null,body.tenant,appLogger, meteringLogger, moduleName)
                        if(assigneeDetails!=null && assigneeDetails!=undefined && assigneeDetails.length>0){
                            let payload = {
                                "message":message,
                                "loggedUser":loggedUser,
                                "whatsappNumber": assigneeDetails[0].WHATSAPP_NUMBER,
                                "tenant": req.body.tenant,
                                "tenantId": req.body.tenantId,
                                "whatsappId":assigneeDetails[0].WHATSAPP_ID
                            }
                            endPoint = config.whatsAppServerUrl + config.whatsAppEndpoints.notifyUser;
                            let notifyResult = await PMSSupport.sendNotificationInWhatsapp(endPoint,payload,req.body.loggedUser,req.body.tenant);
                            appLogger.logMessage("debug", "Response after notifying user about reassiged task: " + JSON.stringify(notifyResult), className, "updateTaskPriority", req.body.loggedUser, req.body.tenant, moduleName); 
                        }else{
                            appLogger.logMessage("info", "Failed to send whatsapp notification due insufficient data" , className, "updateTaskPriority", req.body.loggedUser, req.body.tenant, moduleName); 
                        }
                    } else {
                        appLogger.logMessage("Success", "Task priority updated successfully ", className, "updateTaskPriority", req.body.loggedUser, req.body.tenant, moduleName);
                        out.status = "Success";
                        out.statusCode = 200;
                        out.message = "Reassigned to the same priority.";
                    }
                } else {
                    appLogger.logMessage("error", "Failed to update task priority due to query failed", className, "updateTaskPriority", req.body.loggedUser, req.body.tenant, moduleName);
                    out.status = "Warning";
                    out.statusCode = 404;
                    out.message = "Failed to update task priority";
                }
            }
        } catch (error) {
            appLogger.logMessage("error", "Error while re-assigning task due to: " + JSON.stringify(error.message), className, "updateTaskPriority", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
            out.statusCode = 500;
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "updateTaskPriority", startDateTime, endDateTime, diffInMS, moduleName);
        appLogger.logMessage("info", "updateTaskPriority is completed", className, "updateTaskPriority", req.body.loggedUser, req.body.tenant, moduleName);
        return out;
    },
    updateTaskStatus: async function (req) {
        appLogger.logMessage("info", "updateTaskStatus service invoked by: " + req.loggedUser, className, "updateTaskStatus", req.body.loggedUser, req.body.tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully updated the task status.",
            statusCode: 200,
            data: {}
        }
        try {
            let body = req.body
            let taskdata = JSON.parse(req.body.taskData)
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.updateTaskStatus);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to updateTaskStatus tasks due to missing parameters: " + JSON.stringify(missingParams), className, "updateTaskStatus", req.body.loggedUser, req.body.tenant, moduleName);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 400;
            } else {
              let subStatus
              if(taskdata.APPROVAL_REQUIRED && taskdata.APPROVAL_REQUIRED.toUpperCase() == 'Y'){      
              subStatus = 'Approved'
              }else{
                subStatus = null
              }
                let updateTaskStatus = mysqlQueries.updateTaskStatus;
                let param = [req.body.statusCode, req.body.loggedUserId,subStatus,req.body.taskId];
                appLogger.logMessage("debug", "Assign parameters: " + req.body.statusCode + " and taskId: " + req.body.taskId, className, "updateTaskStatus", req.body.loggedUser, req.body.tenant, moduleName);
                result = await dbOperations.executeQuery(updateTaskStatus, param, req.body.loggedUser, "updateTaskStatus", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                if (result) {
                    if (result.affectedRows > 0) {
                        if(body.flag == 'true' && body.projectStatus == 'NS'){
                            if(body.statusCode == 'IP'){
                                let updateProjectStatus = await dbOperations.executeQuery(mysqlQueries.updateProjectStatusFromPlanningPage, [req.body.loggedUserId ,req.body.projectId] , req.body.loggedUser, "updateProjectStatus", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                                if (updateProjectStatus) {
                                    if (updateProjectStatus.affectedRows > 0) {
                                        out.status = "Success";
                                        out.statusCode = 200;
                                        out.message = "Status changed successfully";
                                    }
                                }
                                    else{
                                        out.status = "Warning";
                                        out.statusCode = 400;
                                        out.message = "Failed to update project status";
                                    }
                            }else{
                                out.status = "Success";
                                out.statusCode = 200;
                                out.message = "Status changed successfully";
                            }

                        }else{
                            out.status = "Success";
                            out.statusCode = 200;
                            out.message = "Status changed successfully";
                        }
                        if (body.assignedTo != body.loggedUserId) {
                            if (body.projectName != null && body.projectName != undefined
                                && body.taskId != null && body.taskId != undefined
                                && body.status != null && body.status != undefined
                                && body.taskName != null && body.taskName != undefined
                                && body.groupName != null && body.groupName != undefined
                                && body.taskDescription != null && body.taskDescription != undefined
                                && body.estimatedStartDate != null && body.estimatedStartDate != undefined
                                && body.estimatedCompletionDate != null && body.estimatedCompletionDate != undefined
                                && body.updatedByName != null && body.updatedByName != undefined && body.assigneeEmail !=null && body.assigneeEmail!=undefined) {
                                let sub = mailConfig.task.statusChange.sub
                                let mes = mailConfig.task.statusChange.message
                                let message;
                                sub = sub.replace('{projectName}', body.projectName)
                                sub = sub.replace('{updatedByName}', body.updatedByName)
                                sub = sub.replace('{taskId}', body.taskId)
                                mes = mes.replace('{updatedByName}', body.updatedByName)
                                mes = mes.replace('{taskId}', body.taskId)
                                mes = mes.replace('{projectName}', body.projectName)
                                mes = mes.replace('{taskName}', body.taskName)
                                mes = mes.replace('{groupName}', body.groupName)
                                mes = mes.replace('{taskDescription}', body.taskDescription)
                                mes = mes.replace('{estimatedStartDate}', moment(body.estimatedStartDate).format('DD-MMM-YYYY'))
                                mes = mes.replace('{estimatedCompletionDate}', moment(body.estimatedCompletionDate).format('DD-MMM-YYYY'))
                                mes = mes.replace('{status}', body.status)
                                message = mes
                                let userData = [{ 'Id': body.assignedTo, 'Email': body.assigneeEmail }]
                                sendMails(userData, null, null, sub, message, body.loggedUser, body.tenant, null, false, body.tenantId, appLogger, meteringLogger, moduleName)
                            } else {
                                appLogger.logMessage("info", "Invalid parameters for email.", className, "updateTaskStatus", req.body.loggedUser, req.body.tenant, moduleName);
                            }
                        }
                        if(body.addedToWatchList=='true'){
                            let nofifyResult=await supportHandler.watchListNotification(body,'status_update',body.loggedUser,body.tenant)
                            appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "updateTaskStatus", loggedUser, tenant, moduleName);
                        }
                        let message = "Task" +body.taskName+ "(# "+body.taskId+") in project "+body.projectName+" status has been updated to "+body.status
                        let assigneeDetails = await dbOperations.executeQuery(mysqlQueries.getAssigneeDetails,[String(body.assigneeEmail).toUpperCase()],body.loggedUser,"getAssigneeDetails",false,null,body.tenant,appLogger, meteringLogger, moduleName)
                        if(assigneeDetails!=null && assigneeDetails!=undefined && assigneeDetails.length>0){
                            let payload = {
                                "message":message,
                                "loggedUser":loggedUser,
                                "whatsappNumber": assigneeDetails[0].WHATSAPP_NUMBER,
                                "tenant": req.body.tenant,
                                "tenantId": req.body.tenantId,
                                "whatsappId":assigneeDetails[0].WHATSAPP_ID
                            }
                            endPoint = config.whatsAppServerUrl + config.whatsAppEndpoints.notifyUser;
                            let notifyResult = await PMSSupport.sendNotificationInWhatsapp(endPoint,payload,req.body.loggedUser,req.body.tenant);
                            appLogger.logMessage("debug", "Response after notifying user about reassiged task: " + JSON.stringify(notifyResult), className, "updateTaskStatus", req.body.loggedUser, req.body.tenant, moduleName); 
                        }else{
                            appLogger.logMessage("info", "Failed to send whatsapp notification due insufficient data" , className, "updateTaskStatus", req.body.loggedUser, req.body.tenant, moduleName); 
                        }                 
                    } else {
                        appLogger.logMessage("Success", "Updated to the same status.", className, "updateTaskStatus", req.body.loggedUser, req.body.tenant, moduleName);
                        out.status = "Success";
                        out.statusCode = 200;
                        out.message = "Updated to the same status.";
                    }
                } else {
                    appLogger.logMessage("error", "Failed to update task status due to query failed", className, "updateTaskStatus", req.body.loggedUser, req.body.tenant, moduleName);
                    out.status = "Warning";
                    out.statusCode = 404;
                    out.message = "Failed to update task status";
                }
            }
        } catch (error) {
            appLogger.logMessage("error", "Error while executing function due to: " + JSON.stringify(error.message), className, "updateTaskStatus", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
            out.statusCode = 500;
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "updateTaskStatus", startDateTime, endDateTime, diffInMS, moduleName);
        appLogger.logMessage("info", "updateTaskStatus is completed", className, "updateTaskStatus", req.body.loggedUser, req.body.tenant, moduleName);
        return out;
    },
    updateTaskDates: async function (req) {
        appLogger.logMessage("info", "updateTaskDates service invoked by: " + req.loggedUser, className, "updateTaskDates", req.body.loggedUser, req.body.tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully updated the task dates.",
            statusCode: 200,
            data: {}
        }
        try {
            let body = req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.updateTaskDate);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to updateTaskDates tasks due to missing parameters: " + JSON.stringify(missingParams), className, "updateTaskDates", req.body.loggedUser, req.body.tenant, moduleName);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 400;
            } else {
                let startDate = moment(req.body.estimatedStartDate).format('YYYY-MM-DD')
                let endDate =moment(req.body.estimatedCompletionDate).format('YYYY-MM-DD')
                if(moment(endDate).isBefore(moment(startDate))){
                    appLogger.logMessage("info", "Date mismatch", className, "updateTaskDates", req.body.loggedUser, req.body.tenant, moduleName);
                    out.status = "Warning";
                    out.statusCode = 404;
                    out.message = "The estimated start date must precede or be the same as the estimated completion date.";
                }else{
                    let updateTaskDates = mysqlQueries.updateTaskDates;
                    let param = [req.body.estimatedStartDate,req.body.estimatedStartDate,req.body.estimatedCompletionDate,req.body.estimatedCompletionDate, req.body.loggedUserId,req.body.taskId];
                    appLogger.logMessage("debug", "Assign parameters: " + req.body.statusCode + " and taskId: " + req.body.taskId, className, "updateTaskDates", req.body.loggedUser, req.body.tenant, moduleName);
                    result = await dbOperations.executeQuery(updateTaskDates, param, req.body.loggedUser, "updateTaskDates", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                    if (result) {
                        if (result.affectedRows > 0) {
                            out.status = "Success";
                            out.statusCode = 200;
                            out.message = "Dates changed successfully";
                            if (body.assignedTo != body.loggedUserId) {
                                if (body.projectName != null && body.projectName != undefined
                                    && body.taskId != null && body.taskId != undefined
                                    && body.status != null && body.status != undefined
                                    && body.taskName != null && body.taskName != undefined
                                    && body.groupName != null && body.groupName != undefined
                                    && body.taskDescription != null && body.taskDescription != undefined
                                    && body.estimatedStartDate != null && body.estimatedStartDate != undefined
                                    && body.estimatedCompletionDate != null && body.estimatedCompletionDate != undefined
                                    && body.updatedByName != null && body.updatedByName != undefined && body.assigneeEmail !=null && body.assigneeEmail!=undefined) {
                                    let sub = mailConfig.task.dateChange.sub
                                    let mes = mailConfig.task.dateChange.message
                                    let message;
                                    sub = sub.replace('{projectName}', body.projectName)
                                    sub = sub.replace('{updatedByName}', body.updatedByName)
                                    sub = sub.replace('{taskId}', body.taskId)
                                    mes = mes.replace('{projectName}', body.projectName)
                                    mes = mes.replace('{taskName}', body.taskName)
                                    mes = mes.replace('{groupName}', body.groupName)
                                    mes = mes.replace('{taskDescription}', body.taskDescription)
                                    mes = mes.replace('{estimatedStartDate}', moment(body.estimatedStartDate).format('DD-MMM-YYYY'))
                                    mes = mes.replace('{estimatedCompletionDate}', moment(body.estimatedCompletionDate).format('DD-MMM-YYYY'))
                                    mes = mes.replace('{status}', body.status)
                                    mes = mes.replace('{updatedByName}', body.updatedByName)
                                    mes = mes.replace('{taskId}', body.taskId)
                                    message = mes
                                    let userData = [{ 'Id': body.assignedTo, 'Email': body.assigneeEmail }]
                                    sendMails(userData, null, null, sub, message, body.loggedUser, body.tenant, null, false, body.tenantId, appLogger, meteringLogger, moduleName)
                                } else {
                                    appLogger.logMessage("info", "Invalid parameters for email.", className, "updateTaskDates", req.body.loggedUser, req.body.tenant, moduleName);
                                }
                            }
                            if(body.addedToWatchList=='true'){
                                let nofifyResult=await supportHandler.watchListNotification(body,'status_update',body.loggedUser,body.tenant)
                                appLogger.logMessage("debug", "Response after notifying the user in the watch list: " + JSON.stringify(nofifyResult), className, "updateTaskDates", loggedUser, tenant, moduleName);
                            }
                            let message = "Task" +body.taskName+ "(# "+body.taskId+") in project "+body.projectName+" date has been updated."
                            let assigneeDetails = await dbOperations.executeQuery(mysqlQueries.getAssigneeDetails,[String(body.assigneeEmail).toUpperCase()],body.loggedUser,"getAssigneeDetails",false,null,body.tenant,appLogger, meteringLogger, moduleName)
                            if(assigneeDetails!=null && assigneeDetails!=undefined && assigneeDetails.length>0){
                                let payload = {
                                    "message":message,
                                    "loggedUser":loggedUser,
                                    "whatsappNumber": assigneeDetails[0].WHATSAPP_NUMBER,
                                    "tenant": req.body.tenant,
                                    "tenantId": req.body.tenantId,
                                    "whatsappId":assigneeDetails[0].WHATSAPP_ID
                                }
                                endPoint = config.whatsAppServerUrl + config.whatsAppEndpoints.notifyUser;
                                let notifyResult = await PMSSupport.sendNotificationInWhatsapp(endPoint,payload,req.body.loggedUser,req.body.tenant);
                                appLogger.logMessage("debug", "Response after notifying user about reassiged task: " + JSON.stringify(notifyResult), className, "updateTaskDates", req.body.loggedUser, req.body.tenant, moduleName); 
                            }else{
                                appLogger.logMessage("info", "Failed to send whatsapp notification due insufficient data" , className, "updateTaskDates", req.body.loggedUser, req.body.tenant, moduleName); 
                            }
                        } else {
                            appLogger.logMessage("Success", "Dates are same. ", className, "updateTaskDates", req.body.loggedUser, req.body.tenant, moduleName);
                            out.status = "Success";
                            out.statusCode = 200;
                            out.message = "Dates are same.";
                        }
                    } else {
                        appLogger.logMessage("error", "Failed to update task date to query failed", className, "updateTaskDates", req.body.loggedUser, req.body.tenant, moduleName);
                        out.status = "Warning";
                        out.statusCode = 404;
                        out.message = "Failed to update task date.";
                    }
                }

            }
        } catch (error) {
            appLogger.logMessage("error", "Error while updating task date due to: " + JSON.stringify(error.message), className, "updateTaskDates", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
            out.statusCode = 500;
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "updateTaskDates", startDateTime, endDateTime, diffInMS, moduleName);
        appLogger.logMessage("info", "updateTaskDates is completed", className, "updateTaskDates", req.body.loggedUser, req.body.tenant, moduleName);
        return out;
    },
    // update group order to move groups up and down (in planning move the orderof groups.)
    updateGroupOrder: async function (req) {
        appLogger.logMessage("info", "updateGroupOrder service invoked by: " + req.loggedUser, className, "updateGroupOrder", req.body.loggedUser, req.body.tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully updated group order.",
            statusCode: 200,
            data: {}
        }
        try {
            let body = req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.updateGroupOrder);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to updateGroupOrder  due to missing parameters: " + JSON.stringify(missingParams), className, "updateGroupOrder", req.body.loggedUser, req.body.tenant, moduleName);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 400;
            } else {
                let updateGroupOrder = mysqlQueries.updateGroupOrder;
                let groupData = JSON.parse(body.groupData)
                for (data of groupData) {
                    result = await dbOperations.executeQuery(updateGroupOrder, [data.GROUP_ORDER,body.projectId,body.tenantId,data.GROUP_ID], req.body.loggedUser, "updateGroupOrder", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                    if(result.affectedRows == 0 || result == null || result == 'Error' || result == undefined){
                        break;
                    }
                }
                if (result) {
                    if (result.affectedRows > 0) {
                        out.status = "Success";
                        out.statusCode = 200;
                        out.message = "Group order updated successfully";
                }else{
                    appLogger.logMessage("error", "Failed to update group order due to query failure", className, "updateGroupOrder", req.body.loggedUser, req.body.tenant, moduleName);
                    out.status = "Warning";
                    out.statusCode = 404;
                    out.message = "Group order updation failed.";
                }
                }else{
                    appLogger.logMessage("error", "Failed to update group order due to query failure", className, "updateGroupOrder", req.body.loggedUser, req.body.tenant, moduleName);
                    out.status = "Warning";
                    out.statusCode = 404;
                    out.message = "Group order updation failed.";
                }
                }
            
        } catch (error) {
            appLogger.logMessage("error", "Error while updating task date due to: " + JSON.stringify(error.message), className, "updateGroupOrder", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
            out.statusCode = 500;
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "updateGroupOrder", startDateTime, endDateTime, diffInMS, moduleName);
        appLogger.logMessage("info", "updateGroupOrder is completed", className, "updateGroupOrder", req.body.loggedUser, req.body.tenant, moduleName);
        return out;
    },
    
    // Delete dependent tasks.
    deleteDependency: async function (req) {
        appLogger.logMessage("info", "deleteDependency service invoked by: " + req.loggedUser, className, "deleteDependency", req.body.loggedUser, req.body.tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully deleted dependent tasks.",
            statusCode: 200,
            data: {}
        }
        try {
            let body = req.body
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.deleteDependency);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to delete dependency tasks due to missing parameters: " + JSON.stringify(missingParams), className, "deleteDependency", req.body.loggedUser, req.body.tenant, moduleName);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 400;
            } else {
                if(body.action == 'DELETE_SUCCESSOR'){
                    let query,param
                    query = mysqlQueries.deleteSuccessorDependency;
                    param = [body.taskId,body.successor_task_id,body.tenantId]
                    result = await dbOperations.executeQuery(query, param, req.body.loggedUser, "deleteDependency", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                    if (result.affectedRows > 0 && result != null && result != 'Error' && result != undefined) {
                        query = mysqlQueries.deletePredecessorDependency;
                        param = [body.successor_task_id,body.taskId,body.tenantId]
                        result = await dbOperations.executeQuery(query, param, req.body.loggedUser, "deleteDependency", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                        if (result.affectedRows == 0 || result == null || result == 'Error' || result == undefined) {
                            query = mysqlQueries.revertSuccessorQuery;
                            param = [body.successor_task_id,body.taskId,body.tenantId]
                            result = await dbOperations.executeQuery(query, param, req.body.loggedUser, "deleteDependency", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                        
                        }
                    }
                }else if(body.action == 'DELETE_PREDECESSOR'){
                    let query,param
                    query = mysqlQueries.deletePredecessorDependency;
                    param = [body.taskId,body.predecessor_task_id,body.tenantId]
                    result = await dbOperations.executeQuery(query, param, req.body.loggedUser, "deleteDependency", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                    if (result.affectedRows > 0 && result != null && result != 'Error' && result != undefined) {
                        query = mysqlQueries.deleteSuccessorDependency;
                        param = [body.predecessor_task_id,body.taskId,body.tenantId]
                        result = await dbOperations.executeQuery(query, param, req.body.loggedUser, "deleteDependency", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                        if (result.affectedRows == 0 || result == null || result == 'Error' || result == undefined) {
                            query = mysqlQueries.revertSuccessorQuery;
                            param = [body.successor_task_id,body.taskId,body.tenantId]
                            result = await dbOperations.executeQuery(query, param, req.body.loggedUser, "deleteDependency", false, null, req.body.tenant, appLogger, meteringLogger, moduleName);
                        }
                    }
                }
                if (result) {
                    if (result.affectedRows > 0) {
                        out.status = "Success";
                        out.statusCode = 200;
                        out.message = "Dependent task deleted successfully";
                    } else {
                        appLogger.logMessage("error", "Failed to delete dependent task due to query failure", className, "deleteDependency", req.body.loggedUser, req.body.tenant, moduleName);
                        out.status = "Warning";
                        out.statusCode = 404;
                        out.message = "Dependency task deletion failed.";
                    }
                } else {
                    appLogger.logMessage("error", "Failed to delete dependent task due to query failure", className, "deleteDependency", req.body.loggedUser, req.body.tenant, moduleName);
                    out.status = "Warning";
                    out.statusCode = 404;
                    out.message = "Dependency task deletion failed.";
                }
            }
        } catch (error) {
            appLogger.logMessage("error", "Error while deleting dependent task date due to: " + JSON.stringify(error.message), className, "deleteDependency", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
            out.statusCode = 500;
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "deleteDependency", startDateTime, endDateTime, diffInMS, moduleName);
        appLogger.logMessage("info", "deleteDependency is completed", className, "deleteDependency", req.body.loggedUser, req.body.tenant, moduleName);
        return out;
    },

    // get project details for project summary pag
    getProjectDetailsForSummary: async function (req) {
        appLogger.logMessage("info", "getProjectDetailsForSummary service invoked by: " + req.loggedUser, className, "getProjectDetailsForSummary", req.body.loggedUser, req.body.tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully fetched project details.",
            statusCode: 200,
            data: {}
        }
        try {
            let body = req.body
            let loggedUser = body.loggedUser
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.getProjectDetailsForSummary);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch tenant activity details due to missing parameters: " + JSON.stringify(missingParams), className, "getProjectDetailsForSummary", req.body.loggedUser, req.body.tenant, moduleName);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 400;
            } else {
                let query = mysqlQueries.getProjectDetailsForSummary;
                let param = [body.loggedUserId,body.tenantId,body.loggedUserId,body.projectId];
                let result = await dbOperations.executeQuery(query, param, loggedUser, "getProjectDetailsForSummary", false, null, body.tenant, appLogger, meteringLogger, moduleName);
                if (result) {
                    if (result.length > 0) {
                        out.status = "Success";
                        out.data = result
                        out.statusCode = 200;
                        out.message = "Project details fetched successfully";
                    } else {
                        appLogger.logMessage("error", "Failed to fetch project details due to query failure", className, "getProjectDetailsForSummary", req.body.loggedUser, req.body.tenant, moduleName);
                        out.status = "Warning";
                        out.statusCode = 404;
                        out.message = "Failed to fetch project details.";
                    }
                } else {
                    appLogger.logMessage("error", "Failed to fetch project details due to query failure", className, "getProjectDetailsForSummary", req.body.loggedUser, req.body.tenant, moduleName);
                    out.status = "Warning";
                    out.statusCode = 404;
                    out.message = "Failed to fetch project details.";
                }
            }
        } catch (error) {
            appLogger.logMessage("error", "Error while fetching project details date due to: " + JSON.stringify(error.message), className, "getProjectDetailsForSummary", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
            out.statusCode = 500;
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "getProjectDetailsForSummary", startDateTime, endDateTime, diffInMS, moduleName);
        appLogger.logMessage("info", "getProjectDetailsForSummary is completed", className, "getProjectDetailsForSummary", req.body.loggedUser, req.body.tenant, moduleName);
        return out;
    }, 

    tenantTest: async function (req) {
        appLogger.logMessage("info", "getProjectDetailsForSummary service invoked by: " + req.body.loggedUser, className, "getProjectDetailsForSummary", req.body.loggedUser, req.body.tenant, moduleName);
        startDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        let out = {
            status: "Success",
            message: "Successfully fetched project details.",
            statusCode: 200,
            data: {}
        }
        try {
            let requestParams = Object.keys(req.body);
            let missingParams = [];
            let signatureKeys = Object.keys(apiSignatures.tenantTest);
            for (let key of signatureKeys) {
                if (!requestParams.includes(key)) {
                    missingParams.push(key);
                }
            }
            if (missingParams.length > 0) {
                appLogger.logMessage("debug", "Failed to fetch project details due to missing parameters: " + JSON.stringify(missingParams), className, "getProjectDetailsForSummary", req.body.loggedUser, req.body.tenant, moduleName);
                out.status = "Failed";
                out.message = "Missing parameters: " + JSON.stringify(missingParams);
                out.statusCode = 400;
            } else{
                const currentDate = moment(); 
                const hoursFromUI = req.body.hours; 
                const startDate = moment(currentDate).subtract(hoursFromUI, 'hours');
                if (currentDate.day() === 0) {
                    currentDate.subtract(1, 'days');
                    currentDate.endOf('day'); 
                }
                
                let adjustedStartDate = moment(currentDate).subtract(hoursFromUI, 'hours');
                let sundaysCount = 0;
                let currentDateIter = moment(adjustedStartDate);
                
                while (currentDateIter <= currentDate) {
                    if (currentDateIter.day() === 0) { 
                        sundaysCount++;
                    }
                    currentDateIter.add(1, 'days');
                }
                adjustedStartDate.subtract(sundaysCount,'days');
                if(adjustedStartDate.day()==0){
                    adjustedStartDate.subtract(1,'days');
                }
                let date=adjustedStartDate.format('YYYY-MM-DD HH:mm:ss');
                let query = mysqlQueries.tenantTest;
                let param = [date,date,date,date,date,date,req.body.tenantId];
                let result = await dbOperations.executeQuery(query, param,req.body.loggedUser, "tenantTest", false, null,req.body.tenant, appLogger, meteringLogger, moduleName);
                if ( result != null && result != 'Error' && result != undefined) {
                    if(result.length>0){
                        if(result[0].ISSUE_TRACKER_ID==0 && result[0].PROJECT_ID==0 && result[0].TASK_ID==0 && result[0].WORKLOG_ID==0 && result[0].MILESTON_TASK_ID==0 && result[0].MILESTON_ISSUE_ID==0 ){
                        out.status = "Success";
                        out.statusCode = 200;
                        out.message = "The give tenant is inactive in the last "+req.body.hours+" hours";   
                        }else{
                        let data={
                            "No of projects they worked":result[0].PROJECT_ID,
                            "No of issues they worked":result[0].ISSUE_TRACKER_ID,
                            "No of tasks they worked":result[0].TASK_ID,
                            "No of milestones they worked":result[0].MILESTON_ISSUE_ID+result[0].MILESTON_TASK_ID,
                            "No of worklogs they worked":result[0].WORKLOG_ID
                            
                        }
                        out.status = "Success";
                        out.statusCode = 200;
                        out.message = "The given tenant is active in the last "+req.body.hours+" hours"; 
                        out.data=data

                        }
    
                    }else{
                        appLogger.logMessage("error", "Failed to fetch project details due to query failure", className, "tenantTest", req.body.loggedUser, req.body.tenant, moduleName);
                        out.status = "Warning";
                        out.statusCode = 404;
                        out.message = "Invalid tenant id";
                    }
                }
                else{
                    appLogger.logMessage("error", "Failed to fetch project details due to query failure", className, "tenantTest", req.body.loggedUser, req.body.tenant, moduleName);
                    out.status = "Warning";
                    out.statusCode = 404;
                    out.message = "unable to fetch data";
                }
    }
          
     return(out)
           
        } catch (error) {
            appLogger.logMessage("error", "Error while fetching project details date due to: " + JSON.stringify(error.message), className, "getProjectDetailsForSummary", req.body.loggedUser, req.body.tenant, moduleName);
            out.status = "Failed";
            out.message = "Internal server error";
            out.data = JSON.stringify(error.message);
            out.statusCode = 500;
        }
        endDateTime = moment().format('YYYY-MM-DD HH:mm:ss.SSS');
        diffInMS = moment(endDateTime).diff(moment(startDateTime), 'ms');
        meteringLogger.logMessage(req.body.tenant, req.body.loggedUser, className, "getProjectDetailsForSummary", startDateTime, endDateTime, diffInMS, moduleName);
        appLogger.logMessage("info", "getProjectDetailsForSummary is completed", className, "getProjectDetailsForSummary", req.body.loggedUser, req.body.tenant, moduleName);
        return out;
    },
   
  

    
}

    async function groupBy(objectArray, property) {
        return objectArray.reduce((acc, obj) => {
            const key = obj[property];
            if (!acc[key]) {
                acc[key] = [];
            }
            // Add object to list for given key's value
            acc[key].push(obj);
            return acc;
        }, {});
    }
    function sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
   

